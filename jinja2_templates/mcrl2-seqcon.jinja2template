% *** DEFINITION OF XOR OPERATOR ***

map xor: Bool # Bool -> Bool;
var a, b: Bool;
eqn xor(a,b) = (a || b) && !(a && b);

% *** DEFINITIONS FOR ARRAYS OF INTEGERS AND BOOLEANS ***

{% for i in IntArraySizes %}
{% if loop.first %}sort {% else %}    {% endif %}Int{{i}} = struct AI{{i}}'({% for j in range(0,i) %}{{', ' if not loop.first }}el'{{j}}: Int{% endfor %});
{% endfor %}
{% for b in BoolArraySizes %}
{% if loop.first %}sort {% else %}    {% endif %}Bool{{i}} = struct AB{{i}}'({% for j in range(0,i) %}{{', ' if not loop.first }}el'{{j}}: Bool{% endfor %});
{% endfor %}
{% for i in IntArraySizes %}
{% if loop.first %}map {% else %}    {% endif %}get': Int{{i}} # Int -> Int;
    set': Int{{i}} # Int # Int -> Int{{i}};
{% endfor %}
{% for i in BoolArraySizes %}
{% if loop.first %}map {% else %}    {% endif %}get': Bool{{i}} # Int -> Bool;
    set': Bool{{i}} # Int # Bool -> Bool{{i}};
{% endfor %}
{% for i in IntArraySizes %}
{% if loop.first %}
var i': Int;
    x': Int;
{% endif %}
    Li{{i}}': Int{{i}};
{% endfor %}
{% for i in IntArraySizes %}
{% set iloop = loop %}
eqn (i' < 0) -> get'(Li{{i}}', i') = 0;
(i' > {{i-1}}) -> get'(Li{{i}}', i') = 0;
{% for j in range(0,i) %}
    get'(Li{{i}}', {{j}}) = el'{{j}}(Li{{i}}');
{% endfor %}
{% endfor %}
{% for i in IntArraySizes %}
(i' < 0) -> set'(Li{{i}}', i', x') = Li{{i}}';
(i' > {{i-1}}) -> set'(Li{{i}}', i', x') = Li{{i}}';
{% for j in range(0,i) %}
    set'(Li{{i}}', {{j}}, x') = AI{{i}}'({% for k in range(0,i) %}{{', ' if not loop.first}}{% if k == j %}x'{% else %}el'{{k}}(Li{{i}}'){% endif %}{% endfor %});
{% endfor %}
{% endfor %}
{% for i in BoolArraySizes %}
{% if loop.first %}
var i': Int;
    b': Bool;
{% endif %}
    Lb{{i}}': Bool{{i}};
{% endfor %}
{% for i in BoolArraySizes %}
{% set bloop = loop %}
eqn (i' < 0) -> get'(Lb{{i}}', i') = false;
(i' > {{i-1}}) -> get'(Lb{{i}}', i') = false;
{% for j in range(0,i) %}
{% if bloop.first and loop.first %}eqn {% else %}    {% endif %}get'(Lb{{i}}', {{j}}) = el'{{j}}(Lb{{i}}');
{% endfor %}
{% endfor %}
{% for i in BoolArraySizes %}
(i' < 0) -> set'(Lb{{i}}', i', b') = Lb{{i}}';
(i' > {{i-1}}) -> set'(Lb{{i}}', i', b') = Lb{{i}}';
{% for j in range(0,i) %}
    set'(Lb{{i}}', {{j}}, b') = AB{{i}}'({% for k in range(0,i) %}{{', ' if not loop.first}}{% if k == j %}b'{% else %}el'{{k}}(Lb{{i}}'){% endif %}{% endfor %});
{% endfor %}
{% endfor %}

% ----- START DEFINITIONS OF BASIC MODEL ASPECTS -----

% *** CHANNEL SIZE CONSTANTS ***

{% for ch in model.channels %}
{% if loop.first %}map {% else %}    {% endif %}{{ch.name}}'max: Int;
{% endfor %}
{% for ch in model.channels %}
{% if loop.first %}eqn {% else %}    {% endif %}{{ch.name}}'max = {{ch.size}};
{% endfor %}

% *** CLASS NAMES ***

{% for c in model.classes %}{% if loop.first %}sort Class = struct {% else %} | {% endif %}{{c.name}}{{';' if loop.last }}{% endfor %}


% *** OBJECT NAMES ***

sort Object';
cons {% for o in model.objects %}{{o.name}}, {% endfor %}o_: Object';
map object_index: Object' -> Nat;
var o1', o2': Object';
eqn object_index(o_) = 0;
{%for oo in sorted_objects %}
    object_index({{oo}}) = {{loop.index}};
{% endfor %}
    o1' < o2' = (object_index(o1') < object_index(o2'));
    o1' > o2' = (object_index(o1') > object_index(o2'));
    o1' == o2' = (object_index(o1') == object_index(o2'));

% *** STATEMACHINE NAMES ***

sort Statemachine';
cons {% for stm in statemachinenames %}{{stm}}, {% endfor %}sm_: Statemachine';
map sm_index: Statemachine' -> Nat;
var sm1', sm2': Statemachine';
eqn sm_index(sm_) = 0;
{%for sm in sorted_statemachines %}
    sm_index({{sm}}) = {{loop.index}};
{% endfor %}
    sm1' < sm2' = (sm_index(sm1') < sm_index(sm2'));
    sm1' > sm2' = (sm_index(sm1') > sm_index(sm2'));
    sm1' == sm2' = (sm_index(sm1') == sm_index(sm2'));

% *** STATE NAMES ***

{% for s in states %}{% if loop.first %}sort State' = struct {% else %}| {% endif %}{{s}}{% if loop.last %};{% else %} {% endif %}{% endfor %}


% *** STATEMENT IDS ***

{% for c in model.classes %}{% set cloop = loop %}{% for stm in c.statemachines %}{% set stmloop = loop %}{% for tr in stm.transitions %}{% if cloop.first and stmloop.first and loop.first %}sort STID' = struct {% else %}| {% endif %}ST'{{tr._tx_position}}{% if cloop.last and stmloop.last and loop.last %}| st_;{% else %} {% endif %}{% endfor %}{% endfor %}{% endfor %}


% *** VARIABLE NAMES ***

sort Var';
cons {% for v in sorted_variables|select("hasnoindex") %}{{', ' if not loop.first }}{{mcrl2varprefix}}{{v[1]}}{{': Var\';' if loop.last }}{% endfor %}

{% for v in sorted_variables|select("hasindex") %}{% if loop.first %}     {% else %}, {% endif %}{{mcrl2varprefix}}{{v[1]}}{% if loop.last %}: Nat -> Var';{% endif %}{% endfor %}

map var_index: Var' -> Nat;
var v1, v2: Var', n': Nat;
{% for v in sorted_variables %}
{% if loop.first %}eqn {% else %}    {% endif %}var_index({{mcrl2varprefix}}{{v[1]}}{{'(n\')' if v is hasindex}}) = {{v[2]}}{{' + n\'' if v is hasindex }};
{% endfor %}
    v1 < v2 = (var_index(v1) < var_index(v2));
    v1 > v2 = (var_index(v1) > var_index(v2));

{% if channeltypes|length > 0 %}
% *** SPECIFICATION OF SIGNALS ***

{% for ct, sset in channeltypes.items() %}
sort Signal'{% for d in ct %}{{d|datatypeacronym}}{% endfor %} = struct {% for signal in sset %}{{signal}}{% if not loop.last %} | {% endif %}{% endfor %}{% if sset|length == 0 %}DUMMY'{% for d in ct %}{{d|datatypeacronym}}{% endfor %}{% endif %};

{% endfor %}
{% endif %}
{% if asynclosslesstypes.union(asynclossytypes)|length > 0 %}
% *** SPECIFICATION OF MESSAGES ***

{% for ct in asynclosslesstypes.union(asynclossytypes) %}
{% set sset = channeltypes[ct] %}
sort M'{% for d in ct %}{{d|datatypeacronym}}{% endfor %} = struct m'{% for d in ct %}{{d|datatypeacronym}}{% endfor %}(el'0: Signal'{% for d in ct %}{{d|datatypeacronym}}{% endfor %}{% for d in ct %}, el'{{ loop.index }}: {{d}}{% endfor %});

{% endfor %}
{% endif %}

% ----- END DEFINITIONS OF BASIC MODEL ASPECTS -----



% ----- START FUNCTIONS TO WORK WITH LISTS OF VARIABLES -----

% *** FUNCTION TO IDENTIFY ARRAY ACCESSES ***

map is_array_access: Var' -> Bool;
var n': Nat;
{% for v in sorted_variables %}
{% if loop.first %}eqn {% else %}    {% endif %}is_array_access({{mcrl2varprefix}}{{v[1]}}{{'(n\')' if v is hasindex}}) = {{v is hasindex|lower}};
{% endfor %}

% *** FUNCTION (WITH AUXILIARY FUNCTIONS) TO SORT ARRAY ACCESSES IN LIST OF VARIABLES ***

map sorted_array_accesses: List(Var') -> List(Var');
var L': List(Var');
eqn sorted_array_accesses([]) = [];
(L' != [] && !is_array_access(head(L'))) -> sorted_array_accesses(L') = [head(L')] ++ sorted_array_accesses(tail(L'));
(is_array_access(head(L'))) -> sorted_array_accesses(L') = sorted_array_accesses(smallerlist(head(L'), L')) ++ [head(L')] ++ sorted_array_accesses(largerlist(head(L'), L'));

map smallerlist: Var' # List(Var') -> List(Var');
var v': Var', L': List(Var');
eqn smallerlist(v', []) = [];
(L' != [] && head(L') < v') -> smallerlist(v', L') = [head(L')] ++ smallerlist(v', tail(L'));
(L' != [] && !(head(L') < v')) -> smallerlist(v', L') = smallerlist(v', tail(L'));

map largerlist: Var' # List(Var') -> List(Var');
var v': Var', L': List(Var');
eqn largerlist(v', []) = [];
(L' != [] && !(v' < head(L'))) -> largerlist(v', L') = largerlist(v', tail(L'));
(L' != [] && v' < head(L')) -> largerlist(v', L') = [head(L')] ++ largerlist(v', tail(L'));

% *** FUNCTION TO QUICKLY COMPARE LISTS OF VARIABLES FOR SPECIFIC CONDITIONS ***

map is_in: Var' # List(Var') -> Bool;
var v': Var', L': List(Var');
eqn is_in(v', []) = false;
(v' == head(L')) -> is_in(v', L') = true;
(L' != [] && v' < head(L')) -> is_in(v', L') = is_in(v', tail(L'));
(v' > head(L')) -> is_in(v', L') = false;

map has_at_least_two: List(Var') -> Bool;
var L': List(Var'), v': Var';
eqn has_at_least_two([]) = false;
    has_at_least_two([v']) = false;
(L' != []) -> has_at_least_two(L') = has_at_least_two1(tail(L'));

map has_at_least_two1: List(Var') -> Bool;
var L': List(Var');
eqn has_at_least_two1([]) = false;
(L' != []) -> has_at_least_two1(L') = true;

map filter_on_two: List(Var') -> List(Var');
var L': List(Var');
eqn filter_on_two(L') = if(has_at_least_two(L'), L', []);

% *** FUNCTIONS TO CONSTRUCT INTERSECTION OF LISTS OF VARIABLES ***

map intersection: List(Var') # List(Var') -> List(Var');
var L1, L2: List(Var');
eqn intersection([], L2) = [];
    intersection(L1, []) = [];
(L1 != [] && L2 != [] && (head(L1) == head(L2))) -> intersection(L1, L2) = [head(L1)] ++ intersection(tail(L1), tail(L2));
(L1 != [] && L2 != [] && (head(L1) > head(L2))) -> intersection(L1, L2) = intersection(L1, tail(L2));
(L1 != [] && L2 != [] && (head(L2) > head(L1))) -> intersection(L1, L2) = intersection(tail(L1), L2);

map intersection_not_empty': List(Var') # List(Var') -> Bool;
var L1, L2: List(Var');
eqn intersection_not_empty'([], L2) = false;
    intersection_not_empty'(L1, []) = false;
(L1 != [] && L2 != [] && (head(L1) == head(L2))) -> intersection_is_empty'(L1, L2) = true;
(L1 != [] && L2 != [] && (head(L1) > head(L2))) -> intersection_is_empty'(L1, L2) = intersection_is_empty'(L1, tail(L2));
(L1 != [] && L2 != [] && (head(L2) > head(L1))) -> intersection_is_empty'(L1, L2) = intersection_is_empty'(tail(L1), L2);

map intersection: List(Var') # List(Var') # List(Var') -> List(Var');
var L1, L2, L3: List(Var');
eqn intersection([], L2, L3) = [];
    intersection(L1, [], L3) = [];
    intersection(L1, L2, []) = [];
(L1 != [] && L2 != [] && L3 != [] && (head(L1) == head(L2)) && (head(L1) == head(L3))) -> intersection(L1, L2, L3) = [head(L1)] ++ intersection(tail(L1), tail(L2), tail(L3));
(L1 != [] && L2 != [] && L3 != [] && (head(L1) > head(L2)) && (head(L1) > head(L3))) -> intersection(L1, L2, L3) = intersection(L1, tail(L2), tail(L3));
(L1 != [] && L2 != [] && L3 != [] && (head(L1) > head(L2)) && (head(L1) == head(L3))) -> intersection(L1, L2, L3) = intersection(L1, tail(L2), L3);
(L1 != [] && L2 != [] && L3 != [] && (head(L1) == head(L2)) && (head(L1) > head(L3))) -> intersection(L1, L2, L3) = intersection(L1, L2, tail(L3));
(L1 != [] && L2 != [] && L3 != [] && (head(L2) > head(L1)) && (head(L2) > head(L3))) -> intersection(L1, L2, L3) = intersection(tail(L1), L2, tail(L3));
(L1 != [] && L2 != [] && L3 != [] && (head(L2) > head(L1)) && (head(L2) == head(L3))) -> intersection(L1, L2, L3) = intersection(tail(L1), L2, L3);
(L1 != [] && L2 != [] && L3 != [] && (head(L3) > head(L2)) && (head(L3) > head(L1))) -> intersection(L1, L2, L3) = intersection(tail(L1), tail(L2), L3);

% *** EXTRACT ONE LIST OF VARIABLES FROM THE OTHER ***

map setminus: List(Var') # List(Var') -> List(Var');
var L1', L2': List(Var');
eqn setminus(L1',[]) = L1';
    setminus([],L2') = [];
(L1' != [] && L2' != [] && head(L1') < head(L2')) -> setminus(L1',L2') = [head(L1')] ++ setminus(tail(L1'),L2');
(L1' != [] && L2' != [] && head(L2') < head(L1')) -> setminus(L1',L2') = setminus(L1',tail(L2'));
(L1' != [] && L2' != [] && head(L1') == head(L2')) -> setminus(L1',L2') = setminus(tail(L1'),tail(L2'));

% *** ONLY KEEP VARIABLES IN THE FIRST LIST THAT APPEAR IN THE SECOND ***

map filter': List(Var') # List(Var') -> List(Var');
var L1', L2': List(Var');
eqn filter'(L1',[]) = [];
    filter'([],L2') = [];
(L1' != [] && L2' != [] && head(L1') < head(L2')) -> filter'(L1',L2') = filter'(tail(L1'),L2');
(L1' != [] && L2' != [] && head(L2') < head(L1')) -> filter'(L1',L2') = filter'(L1',tail(L2'));
(L1' != [] && L2' != [] && head(L1') == head(L2')) -> filter'(L1',L2') = [head(L1')] ++ filter'(tail(L1'),tail(L2'));

% *** UNION OF TWO LISTS OF VARIABLES ***

map union': List(Var') # List(Var') -> List(Var');
var L1, L2: List(Var');
eqn union'([], L2) = L2;
    union'(L1, []) = L1;
(L1 != [] && L2 != [] && head(L1) == head(L2)) -> union'(L1, L2) = [head(L1)] ++ union'(tail(L1), tail(L2));
(L1 != [] && head(L1) < head(L2))  -> union'(L1, L2) = [head(L1)] ++ union'(tail(L1), L2);
(L2 != [] && head(L1) > head(L2))  -> union'(L1, L2) = [head(L2)] ++ union'(L1, tail(L2));

% ----- END FUNCTIONS TO WORK WITH LISTS OF VARIABLES -----



% ----- START SPECIFICATIONS AND FUNCTIONS TO REASON ABOUT MODEL STRUCTURE -----

% *** SPECIFICATION OF OBJECT/STATE MACHINE PAIR, WITH FUNCTIONS ***

sort Object_SM' = struct O'SM'(O': Object', SM': Statemachine');
map lt', gt', eq': Object_SM' # Object_SM' -> Bool;
var osm1', osm2': Object_SM';
eqn lt'(osm1', osm2') = ((O'(osm1') < O'(osm2')) || ((O'(osm1') == O'(osm2')) && (SM'(osm1') < SM'(osm2'))));
    gt'(osm1', osm2') = ((O'(osm1') > O'(osm2')) || ((O'(osm1') == O'(osm2')) && (SM'(osm1') > SM'(osm2'))));
    eq'(osm1', osm2') = ((O'(osm1') == O'(osm2')) && (SM'(osm1') == SM'(osm2')));

map is_in: Object_SM' # List(Object_SM') -> Bool;
var osm1': Object_SM', L': List(Object_SM');
eqn is_in(osm1', []) = false;
(eq'(osm1', head(L'))) -> is_in(osm1', L') = true;
(L' != [] && lt'(osm1', head(L'))) -> is_in(osm1', L') = is_in(osm1', tail(L'));
(gt'(osm1', head(L'))) -> is_in(osm1', L') = false;

map remove: List(Object_SM') # Object_SM' -> List(Object_SM');
var osm': Object_SM';
    L': List(Object_SM');
eqn remove([], osm') = [];
(L' != [] && (eq'(osm', head(L')))) -> remove(L', osm') = tail(L');
(L' != [] && (lt'(osm', head(L')))) -> remove(L', osm') = L';
(L' != [] && (gt'(osm', head(L')))) -> remove(L', osm') = [head(L')] ++ remove(tail(L'),osm');

map intersection: List(Object_SM') # List(Object_SM') -> List(Object_SM');
var L1, L2: List(Object_SM');
eqn intersection([], L2) = [];
    intersection(L1, []) = [];
(L1 != [] && L2 != [] && (eq'(head(L1), head(L2)))) -> intersection(L1, L2) = [head(L1)] ++ intersection(tail(L1), tail(L2));
(L1 != [] && L2 != [] && (gt'(head(L1), head(L2)))) -> intersection(L1, L2) = intersection(L1, tail(L2));
(L1 != [] && L2 != [] && (lt'(head(L1), head(L2)))) -> intersection(L1, L2) = intersection(tail(L1), L2);

map union': List(Object_SM') # List(Object_SM') -> List(Object_SM');
var L1, L2: List(Object_SM');
eqn union'([], L2) = L2;
    union'(L1, []) = L1;
(L1 != [] && L2 != [] && eq'(head(L1), head(L2))) -> union'(L1, L2) = [head(L1)] ++ union'(tail(L1), tail(L2));
(L1 != [] && lt'(head(L1), head(L2)))  -> union'(L1, L2) = [head(L1)] ++ union'(tail(L1), L2);
(L2 != [] && gt'(head(L1), head(L2)))  -> union'(L1, L2) = [head(L2)] ++ union'(L1, tail(L2));

map setminus: List(Object_SM') # List(Object_SM') -> List(Object_SM');
var L1', L2': List(Object_SM');
eqn setminus(L1',[]) = L1';
    setminus([],L2') = [];
(L1' != [] && L2' != [] && head(L1') < head(L2')) -> setminus(L1',L2') = [head(L1')] ++ setminus(tail(L1'),L2');
(L1' != [] && L2' != [] && head(L2') < head(L1')) -> setminus(L1',L2') = setminus(L1',tail(L2'));
(L1' != [] && L2' != [] && head(L1') == head(L2')) -> setminus(L1',L2') = setminus(tail(L1'),tail(L2'));

% *** SPECIFICATION OF TUPLE OF OUTGOING TRANSITIONS OF THE WHOLE SYSTEM ***

sort OutgoingTransitions = struct OT'({% for o in model.objects %}{% set oloop = loop %}{% for sm in o.type.statemachines %}{{', ' if not (oloop.first and loop.first)}}el'{{o.name}}'{{sm.name}}: List(STID'){% endfor %}{% endfor %});

% *** FUNCTION INDICATING WHETHER A TRANSITION IS ENABLED OR NOT ***

map isenabled: Object' # STID'{{model|mcrl2_model_vartypes(True)}} -> Bool;
var {{model|mcrl2_model_vars_with_types(False)}};
{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
{% set smloop = loop %}
{% for tr in sm.transitions %}
{% if oloop.first and smloop.first and loop.first %}eqn {% else %}    {% endif %}isenabled({{o.name}}, ST'{{tr._tx_position}}{{model|mcrl2_model_vars(True)}}) = {% if tr.statements[0]|hascondition(o) %}{{tr.statements[0]|statement_condition(o)}}{% else %}true{% endif %};
{% endfor %}
{% endfor %}
{% endfor %}

% *** FUNCTION INDICATING WHETHER THE LIST OF OUTGOING TRANSITIONS CONTAINS DISABLED TRANSITIONS IN THE GIVEN OBJECT, BUT OF A DIFFERENT STATE MACHINE THAN THE GIVEN ONE ***

map has_disabled': Object' # Statemachine' # OutgoingTransitions{{model|mcrl2_model_vartypes(True)}} -> Bool;
var o1': Object';
    sm1': Statemachine';
    out': OutgoingTransitions;
    {{model|mcrl2_model_vars_with_types(False)}};
{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
{% if oloop.first and loop.first %}eqn {% else %}    {% endif %}has_disabled'({{o.name}},{{sm.name}},out'{{model|mcrl2_model_vars(True)}}) = false{% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o.type.statemachines %}{% if o2 == o and sm2 != sm %} || has_disabled1'({{o2.name}},el'{{o2.name}}'{{sm2.name}}(out'){{model|mcrl2_model_vars(True)}}){% endif %}{% endfor %}{% endfor %};
{% endfor %}
{% endfor %}

map has_disabled1': Object' # List(STID'){{model|mcrl2_model_vartypes(True)}} -> Bool;
var o1': Object';
    L': List(STID');
    {{model|mcrl2_model_vars_with_types(False)}};
eqn has_disabled1'(o1',[]{{model|mcrl2_model_vars(True)}}) = false;
(L' != []) -> has_disabled1'(o1',L'{{model|mcrl2_model_vars(True)}}) = has_disabled2'(o1',L',isenabled(o1',head(L'){{model|mcrl2_model_vars(True)}}){{model|mcrl2_model_vars(True)}});

map has_disabled2': Object' # List(STID') # Bool{{model|mcrl2_model_vartypes(True)}} -> Bool;
var o1': Object';
    L': List(STID');
    b': Bool;
    {{model|mcrl2_model_vars_with_types(False)}};
eqn has_disabled2'(o1',L',false{{model|mcrl2_model_vars(True)}}) = true;
(L' != []) -> has_disabled2'(o1',L',true{{model|mcrl2_model_vars(True)}}) = has_disabled1'(o1',tail(L'){{model|mcrl2_model_vars(True)}});

% *** FUNCTION INDICATING WHETHER A STATEMENT IS SAFE OR NOT ***

map issafe: Object' # STID'{{model|mcrl2_model_vartypes(True)}} -> Bool;
var o1': Object';
    {{model|mcrl2_model_vars_with_types(False)}};
{% for c in model.classes %}
{% set cloop = loop %}
{% for sm in c.statemachines %}
{% set smloop = loop %}
{% for tr in sm.transitions %}
{% if cloop.first and smloop.first and loop.first %}eqn {% else %}    {% endif %}issafe(o1', ST'{{tr._tx_position}}{{model|mcrl2_model_vars(True)}}) = {% if tr.statements[0]|statement_is_safe %}true{% else %}!has_at_least_two(rwpattern(o1', ST'{{tr._tx_position}}{{model|mcrl2_model_vars(True)}})){% endif %};
{% endfor %}
{% endfor %}
{% endfor %}

% *** FUNCTION INDICATING WHETHER A STATEMENT IS (UN)CONDITIONALLY SAFE (FOR AMPLE-SET POR) OR NOT ***

map por_issafe: Object' # STID'{{model|mcrl2_model_vartypes(True)}} -> Bool;
var {{model|mcrl2_model_vars_with_types(False)}};
{% for o in model.objects %}
{% set oloop = loop %}
{% for stm in o.type.statemachines %}
{% set stmloop = loop %}
{% for tr in stm.transitions %}
{% if oloop.first and stmloop.first and loop.first %}eqn {% else %}    {% endif %}{% if tr.statements[0].__class__.__name__ == "Composite" and tr.statements[0].guard != None %}(isenabled({{o.name}}, ST'{{tr._tx_position}}{{model|mcrl2_model_vars(True)}})) -> {% endif %}por_issafe({{o.name}}, ST'{{tr._tx_position}}{{model|mcrl2_model_vars(True)}}) = {{tr.statements[0]|statement_is_por_safe(True)|lower()}};
{% if tr.statements[0].__class__.__name__ == "Composite" and tr.statements[0].guard != None %}    (!isenabled({{o.name}}, ST'{{tr._tx_position}}{{model|mcrl2_model_vars(True)}})) -> por_issafe({{o.name}}, ST'{{tr._tx_position}}{{model|mcrl2_model_vars(True)}}) = {{tr.statements[0]|statement_is_por_safe(False)|lower()}};
{% endif %}
{% endfor %}
{% endfor %}
{% endfor %}

% *** FUNCTION PROVIDING OUTGOING TRANSITIONS PER CLASS/STATEMACHINE/STATE PAIR ***

map outgoing: Class # Statemachine' # State' -> List(STID');
{% for c in model.classes %}
{% set cloop = loop %}
{% for stm in c.statemachines %}
{% set stmloop = loop %}
{% for s in stm.states %}
{% if cloop.first and stmloop.first and loop.first %}eqn {% else %}    {% endif %}outgoing({{c.name}}, {{stm.name}}, {{s.name}}) = [{% for tr in trans[c][stm][s] %}{{', ' if not loop.first }}ST'{{tr._tx_position}}{% endfor %}];
{% endfor %}
{% endfor %}
{% endfor %}

% *** FUNCTION PROVIDING THE CURRENT LIST OF OUTGOING TRANSITIONS OF THE GIVEN STATEMACHINE ***

map sm_outgoing: Object' # Statemachine' # OutgoingTransitions -> List(STID');
var L': OutgoingTransitions;
{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
{% if oloop.first and loop.first %}eqn {% else %}    {% endif %}sm_outgoing({{o.name}}, {{sm.name}}, L') = el'{{o.name}}'{{sm.name}}(L');
{% endfor %}
{% endfor %}

% *** FUNCTION TO UPDATE THE LIST OF OUTGOING TRANSITIONS ***

map update_outgoing: Object' # Statemachine' # State' # OutgoingTransitions -> OutgoingTransitions;
var L': OutgoingTransitions;
    s': State';
{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
{% set smloop = loop %}
{% if oloop.first and loop.first and smloop.first %}eqn {% else %}    {% endif %}update_outgoing({{o.name}}, {{sm.name}}, s', L') = OT'({% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o2.type.statemachines %}{% set sm2loop = loop %}{{', ' if not (o2loop.first and sm2loop.first) }}{% if o == o2 and sm == sm2 %}outgoing({{o.type.name}}, {{sm.name}}, s'){% else %}el'{{o2.name}}'{{sm2.name}}(L'){% endif %}{% endfor %}{% endfor %});
{% endfor %}
{% endfor %}

% ----- END SPECIFICATIONS AND FUNCTIONS TO REASON ABOUT MODEL STRUCTURE -----



% ----- START ACCESS PATTERNS -----

% *** SPECIFICATION OF ACCESS PATTERN ***

% union_plus operator is specifically defined for application on P-summaries (a read to variable x is not needed in pattern if a write to x is also present)

sort AccessPattern' = struct A'(R': List(Var'), W': List(Var'));
map union': AccessPattern' # AccessPattern' -> AccessPattern';
    union_plus': AccessPattern' # AccessPattern' -> AccessPattern';
    union_plus1': AccessPattern' -> AccessPattern';
var a1', a2': AccessPattern';
eqn union'(a1', a2') = A'(union'(R'(a1'),R'(a2')), union'(W'(a1'),W'(a2')));
    union_plus'(a1', a2') = union_plus1'(union'(a1',a2'));
    union_plus1'(a1') = A'(setminus(R'(a1'), W'(a1')), W'(a1'));

map union': List(AccessPattern') -> AccessPattern';
var L': List(AccessPattern');
eqn union'([]) = A'([],[]);
(L' != []) -> union'(L') = union'(head(L'), union'(tail(L')));

map filter': AccessPattern' # List(Var') -> AccessPattern';
var a1': AccessPattern';
    L': List(Var');
eqn filter'(a1',L') = A'(filter'(R'(a1'),L'), filter'(W'(a1'),L'));

map setminus: AccessPattern' # List(Var') -> AccessPattern';
var a1': AccessPattern';
    L': List(Var');
eqn setminus(a1',L') = A'(setminus(R'(a1'),L'), setminus(W'(a1'),L'));

map setminus: AccessPattern' # AccessPattern' -> AccessPattern';
var a1', a2': AccessPattern';
eqn setminus(a1',a2') = A'(setminus(R'(a1'),R'(a2')), setminus(W'(a1'),W'(a2')));

map intersection: AccessPattern' # AccessPattern' -> AccessPattern';
var a1', a2': AccessPattern';
eqn intersection(a1', a2') = A'(intersection(R'(a1'),R'(a2')), intersection(W'(a1'),W'(a2')));

% provide subpattern of first AccessPattern that conflicts with second AccessPattern
map conflicting': AccessPattern' # AccessPattern' -> AccessPattern';
var a1', a2': AccessPattern';
eqn conflicting'(a1',a2') = A'(intersection(R'(a1'), W'(a2')), intersection(W'(a1'), get_vars'(a2')));

% is there a conflict between the two given AccessPatterns?
map are_conflicting': AccessPattern' # AccessPattern' -> Bool;
var a1', a2': AccessPattern';
eqn are_conflicting'(a1', a2') = are_conflicting1'(a1', a2', intersection_not_empty'(R'(a1'),W'(a2')));

map are_conflicting1': AccessPattern' # AccessPattern' # Bool -> Bool;
var a1', a2': AccessPattern';
    b': Bool;
eqn are_conflicting1'(a1', a2',true) = true;
    are_conflicting1'(a1', a2',false) = intersection_not_empty'(W'(a1'), get_vars'(a2'));

map has_at_least_two: AccessPattern' -> Bool;
var a': AccessPattern';
eqn has_at_least_two(a') = has_at_least_two(R'(a') ++ W'(a'));

map not_empty: AccessPattern' -> Bool;
var a': AccessPattern';
eqn not_empty(a') = (R'(a') != [] || W'(a') != []);

map get_vars': AccessPattern' -> List(Var');
var a': AccessPattern';
eqn get_vars'(a') = union'(R'(a'), W'(a'));

% *** SPECIFICATION OF OBJECT/STATE MACHINE/ACCESS PATTERN PAIR ***

sort Object_SM_AccessPattern' = struct O'SM'A'(O': Object', SM': Statemachine', A':AccessPattern');

% *** SPECIFICATION OBJECT/STATE MACHINE/ACCESS PAIR ***

sort Object_SM_Access' = struct O'SM'AC'(O': Object', SM': Statemachine', RW': Bool, V':Var');

% *** PAIRS OF OBJECTS AND STATEMENT IDS ***

sort Object_Statement = struct O'S'(O': Object', ST': STID');

% *** FUNCTION PROVIDING ACCESS PATTERNS OF STATEMENTS ***

map rwpattern_st: Object' # STID' # List(Var') -> AccessPattern';
var filter': List(Var');
{% for o in model.objects %}
{% set oloop = loop %}
{% for stm in o.type.statemachines %}
{% set stmloop = loop %}
{% for tr in stm.transitions %}
{% if oloop.first and stmloop.first and loop.first %}eqn {% else %}{% endif %}(filter' == A'([],[])) -> rwpattern_st({{o.name}}, ST'{{tr._tx_position}},filter') = {{tr.statements[0]|mcrl2_accesspattern(o,True)}};
(filter' != A'([],[])) -> rwpattern_st({{o.name}}, ST'{{tr._tx_position}},filter') = setminus({{tr.statements[0]|mcrl2_accesspattern(o,True)}}, filter');
{% endfor %}
{% endfor %}
{% endfor %}

% *** FUNCTION PROVIDING EXPRESSION ACCESS PATTERNS OF STATEMENTS ***

map rwpattern_st_expression: Object' # Statemachine' # List(Var') -> AccessPattern';
var filter': List(Var');
{% for o in model.objects %}
{% set oloop = loop %}
{% for stm in o.type.statemachines %}
{% set stmloop = loop %}
{% for tr in stm.transitions %}
{% if oloop.first and stmloop.first and loop.first %}eqn {% else %}{% endif %}(filter' == A'([],[])) -> rwpattern_st({{o.name}}, ST'{{tr._tx_position}},filter') = {{tr.statements[0]|mcrl2_accesspattern(o,False)}};
(filter' != A'([],[])) -> rwpattern_st({{o.name}}, ST'{{tr._tx_position}},filter') = setminus({{tr.statements[0]|mcrl2_accesspattern(o,False)}}, filter');
{% endfor %}
{% endfor %}
{% endfor %}

% *** FUNCTIONS TO DETERMINE WHETHER TWO OBJECT/STATEMENT PAIRS ARE CONFLICTING ***

map conflicting': Object' # STID' # STID' # List(Var') -> AccessPattern';
var o': Object';
    st1', st2': STID';
    filter': List(Var');
eqn conflicting'(o',st1',st2') = conflicting'(rw_pattern_st(o',st1',filter'), rw_pattern_st(o',st2',filter'));

map are_conflicting': Object' # STID' # STID' # List(Var') -> Bool;
var o': Object';
    st1', st2': STID';
    filter': List(Var');
eqn are_conflicting'(o',st1',st2') = are_conflicting'(rw_pattern_st(o',st1',filter'), rw_pattern_st(o',st2',filter'));

% ----- END ACCESS PATTERNS -----



% ----- START DEPENDENCY GRAPH STRUCTURE AND BASIC FUNCTIONS -----

% *** P-SUMMARIES ***

sort PS' = struct Psum'({% for o in model.objects %}{% set oloop = loop %}{% for sm in o.type.statemachines %}{{', ' if not (oloop.first and loop.first)}}el'{{o.name}}'{{sm.name}}: AccessPattern'{% endfor %}{% endfor %});
map empty_PS': PS';
eqn empty_PS' = Psum'({% for o in model.objects %}{% set oloop = loop %}{% for sm in o.type.statemachines %}{{', ' if not (oloop.first and loop.first)}}A'([],[]){% endfor %}{% endfor %});

% *** C-SUMMARIES ***

sort CS' = struct str_CS'({% for o in model.objects %}{% set oloop = loop %}{% for sm in o.type.statemachines %}{{', ' if not (oloop.first and loop.first)}}el'{{o.name}}'{{sm.name}}: List(STID'CS'){% endfor %}{% endfor %});
map empty_CS': CS';
eqn empty_CS' = str_CS'({% for o in model.objects %}{% set oloop = loop %}{% for sm in o.type.statemachines %}{{', ' if not (oloop.first and loop.first)}}empty_STID'CS'{% endfor %}{% endfor %});

sort STID'CS' = struct str_STID'CS'(el'STID: STID', el'CSin: List(STID'AP'), el'CSout: List(STID'AP'));
map empty_STID'CS': STID'CS';
eqn empty_STID'CS' = str_STID'CS'(st_, [], []);

sort STID'AP' = struct str_STID'AP'(el'STID: STID', el'AP: AccessPattern');
map empty_STID'AP': STID'AP';
eqn empty_STID'AP' = str_STID'AP'(st_, A'([], []));

% *** FUNCTIONS FOR C-SUMMARIES ***

map get_conflicting_STID's: Object' # STID' # OutgoingTransitions # List(Var') -> List(STID'AP');
var out': OutgoingTransitions;
    filter': List(Var');
{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
{% set smloop = loop %}
{% for tr in sm.transitions %}
{% if (oloop.first and smloop.first and loop.first) %}eqn {% else %}    {% endif %}get_conflicting_STID's({{o.name}},ST'{{tr._tx_position}},out',filter') = {% for sm2 in o.type.statemachines|reject("eq", sm) %}{{' ++ ' if not loop.first}}get_conflicting_STID's1({{o.name}},ST'{{tr._tx_position}},el'{{o.name}}'{{sm2.name}}(out'),filter'){% endfor %});
{% endfor %}
{% endfor %}
{% endfor %}

map get_conflicting_STID's1: Object' # STID' # List(STID') # List(Var') -> List(STID'AP');
var o': Object';
    st': STID';
    Ls': List(STID');
    filter': List(Var');
eqn get_conflicting_STID's1(o',st',[],filter') = [];
(Ls' != []) -> get_conflicting_STID's1(o',st',Ls',filter') = get_conflicting_STID's2(o',st',Ls',filter',conflicting'(o',head(Ls'),st',filter'));

map get_conflicting_STID's2: Object' # STID' # List(STID') # List(Var') # AccessPattern' -> List(STID'AP');
var o': Object';
    st': STID';
    Ls': List(STID');
    filter': List(Var');
    a': AccessPattern';
eqn (a' == A'([],[])) -> get_conflicting_STID's2(o',st',Ls',filter',a') = get_conflicting_STID's1(o',st',tail(Ls'),filter');
(a != A'([],[])) -> get_conflicting_STID's2(o',st',Ls',filter',a') = [str_STID'AP'(head(Ls'),a')] ++ get_conflicting_STID's1(o',st',tail(Ls'),filter');

% which statements have an incoming edge from given statement, and which subset of their accesses is involved in this?

map get_CSin's: Object' # STID' # CS' -> List(STID'AP');
var o': Object;
    st': STID';
    cs': CS';
eqn get_CSin's(o',st',cs') = get_CSin's1(o',st',cs',get_CSout_edges(o',st',cs'));

map get_CSin's1: Object' # STID' # CS' # List(STID'AP') -> List(STID'AP');
var o': Object';
    st': STID';
    cs': CS';
    L': List(STID'AP');
eqn get_CSin's1(o',st',cs',[]) = [];
(L' != []) -> get_CSin's1(o',st',cs',L') = [str_STID'AP'(el'STID(head(L')), get_CSin_edge'(o',el'STID(head(L')),st',cs'))] ++ get_CSin's1(o',st',cs',tail(L'));

% which statements have an outgoing edge to given statement, and which subset of their accesses is involved in this?

map get_CSout's: Object' # STID' # CS' -> List(STID'AP');
var o': Object;
    st': STID';
    cs': CS';
eqn get_CSout's(o',st',cs') = get_CSout's1(o',st',cs',get_CSin_edges(o',st',cs'));

map get_CSout's1: Object' # STID' # CS' # List(STID'AP') -> List(STID'AP');
var o': Object';
    st': STID';
    cs': CS';
    L': List(STID'AP');
eqn get_CSout's1(o',st',cs',[]) = [];
(L' != []) -> get_CSout's1(o',st',cs',L') = [str_STID'AP'(el'STID(head(L')), get_CSout_edge'(o',el'STID(head(L')),st',cs'))] ++ get_CSout's1(o',st',cs',tail(L'));

% *** GET A C-SUMMARY EDGE BETWEEN INSTRUCTIONS ***

map get_CSin_edge': Object' # STID' # STID' # CS' -> AccessPattern';
var st': STID';
    cs': CS';
{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
{% set smloop = loop %}
{% for tr in sm.transitions %}
{% if (oloop.first and smloop.first and loop.first) %}eqn {% else %}    {% endif %}get_CSin_edge'({{o.name}},ST'{{tr._tx_position}},st',cs') = get_CSin_edge1'(ST'{{tr._tx_position}},st',el'{{o.name}}'{{sm.name}}(cs'));
{% endfor %}
{% endfor %}
{% endfor %}

map get_CSin_edge1': STID' # STID' # List(STID'CS') -> AccessPattern';
var st1', st2': STID';
    L': List(STID'CS');
eqn get_CSin_edge1'(st1',st2',[]) = A'([],[]);
(L' != [] && el'STID(head(L')) == st1') -> get_CSin_edge1'(st1',st2',L') = get_CS_edge2'(st2',el'CSin(head(L')));
(L' != [] && el'STID(head(L')) < st1') -> get_CSin_edge1'(st1',st2',L') = get_CSin_edge1'(st1',st2',tail(L'));
(L' != [] && el'STID(head(L')) > st1') -> get_CSin_edge1'(st1',st2',L') = A'([],[]);

map get_CSout_edge': Object' # STID' # STID' # CS' -> AccessPattern';
var st': STID';
    cs': CS';
{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
{% set smloop = loop %}
{% for tr in sm.transitions %}
{% if (oloop.first and smloop.first and loop.first) %}eqn {% else %}    {% endif %}get_CSout_edge'({{o.name}},ST'{{tr._tx_position}},st',cs') = get_CSout_edge1'(ST'{{tr._tx_position}},st',el'{{o.name}}'{{sm.name}}(cs'));
{% endfor %}
{% endfor %}
{% endfor %}

map get_CSout_edge1': STID' # STID' # List(STID'CS') -> AccessPattern';
var st1', st2': STID';
    L': List(STID'CS');
eqn get_CSout_edge1'(st1',st2',[]) = A'([],[]);
(L' != [] && el'STID(head(L')) == st1') -> get_CSout_edge1'(st1',st2',L') = get_CS_edge2'(st2',el'CSout(head(L')));
(L' != [] && el'STID(head(L')) < st1') -> get_CSout_edge1'(st1',st2',L') = get_CSout_edge1'(st1',st2',tail(L'));
(L' != [] && el'STID(head(L')) > st1') -> get_CSout_edge1'(st1',st2',L') = A'([],[]);

map get_CS_edge2': STID' # List(STID'AP') -> AccessPattern';
var st2': STID';
    L': List(STID'AP');
eqn get_CS_edge2'(st2',[]) = A'([],[]);
(L' != [] && el'STID(head(L')) == st2') -> get_CS_edge2'(st2',L') = el'AP(head(L'));
(L' != [] && el'STID(head(L')) < st2') -> get_CS_edge2'(st2',L') = get_CS_edge2'(st2',tail(L'));
(L' != [] && el'STID(head(L')) > st2') -> get_CS_edge2'(st2',L') = A'([],[]);

map get_CSin_edges': Object' # STID' # CS' -> List(STID'AP');
var cs': CS';
{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
{% set smloop = loop %}
{% for tr in sm.transitions %}
{% if (oloop.first and smloop.first and loop.first) %}eqn {% else %}    {% endif %}get_CSin_edges'({{o.name}},ST'{{tr._tx_position}},cs') = get_CSin_edges1'(ST'{{tr._tx_position}},el'{{o.name}}'{{sm.name}}(cs'));
{% endfor %}
{% endfor %}
{% endfor %}

map get_CSin_edges1': STID' # List(STID'CS') -> List(STID'AP');
var st': STID';
    L': List(STID'CS');
eqn get_CSin_edges1'(st',[]) = [];
(L' != [] && el'STID(head(L')) == st') -> get_CSin_edges1'(st',L') = el'CSin(head(L'));
(L' != [] && el'STID(head(L')) < st') -> get_CSin_edges1'(st',L') = get_CSin_edges1'(st',tail(L'));
(L' != [] && el'STID(head(L')) > st') -> get_CSin_edges1'(st',L') = [];

map get_CSout_edges': Object' # STID' # CS' -> List(STID'AP');
var cs': CS';
{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
{% set smloop = loop %}
{% for tr in sm.transitions %}
{% if (oloop.first and smloop.first and loop.first) %}eqn {% else %}    {% endif %}get_CSout_edges'({{o.name}},ST'{{tr._tx_position}},cs') = get_CSout_edges1'(ST'{{tr._tx_position}},el'{{o.name}}'{{sm.name}}(cs'));
{% endfor %}
{% endfor %}
{% endfor %}

map get_CSout_edges1': STID' # List(STID'CS') -> List(STID'AP');
var st': STID';
    L': List(STID'CS');
eqn get_CSout_edges1'(st',[]) = [];
(L' != [] && el'STID(head(L')) == st') -> get_CSout_edges1'(st',L') = el'CSout(head(L'));
(L' != [] && el'STID(head(L')) < st') -> get_CSout_edges1'(st',L') = get_CSout_edges1'(st',tail(L'));
(L' != [] && el'STID(head(L')) > st') -> get_CSout_edges1'(st',L') = [];

% *** SET C-SUMMARY EDGES BETWEEN INSTRUCTIONS ***

map set_CSin_edges': Object' # STID' # List(STID'AP') # AccessPattern' # CS' -> CS';
var st': STID';
    L': List(STID');
    a': AccessPattern';
    cs': CS';
{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
{% set smloop = loop %}
{% for tr in sm.transitions %}
{% if (oloop.first and smloop.first and loop.first) %}eqn {% else %}    {% endif %}set_CSin_edges'({{o.name}},ST'{{tr._tx_position}},L',a',cs') = str_CS'({% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o2.type.statemachines %}{{', ' if not (o2loop.first and loop.first)}}{% if not (o == o2 and sm == sm2) %}el'{{o2.name}}'{{sm2.name}}(cs'){% else %}set_CSin_edges1'({{o.name}},ST'{{tr._tx_position}},create_STID'AP's(L',a'),el'{{o2.name}}'{{sm2.name}}(cs')){% endif %}{% endfor %}{% endfor %});
{% endfor %}
{% endfor %}
{% endfor %}

map set_CSin_edges1': STID' # List(STID'AP') # List(STID'CS') -> List(STID'CS');
var st': STID';
    La': List(STID'AP');
    L': List(STID'CS');
eqn set_CSin_edges1'(st',La',[]) = [str_STID'CS'(st1',La',[])];
(L' != [] && el'STID(head(L')) == st') -> set_CSin_edges1'(st',La',L') = [str_STID'CS'(st',set_CS_edges2'(La',el'CSin(head(L'))),el'CSout(head(L')))] ++ tail(L');
(L' != [] && el'STID(head(L')) < st') -> set_CSin_edges1'(st',La',L') = [head(L')] ++ set_CSin_edges1'(st',La',tail(L'));
(L' != [] && el'STID(head(L')) > st') -> set_CSin_edges1'(st',La',L') = set_CSin_edges1'(st',La',[]) ++ L';

map set_CS_edges2': List(STID'AP') # List(STID'AP') -> List(STID'AP');
var L1', L2': List(STID'AP');
eqn set_CS_edges2'(L1',[]) = L1';
    set_CS_edges2'([],L2') = L2';
(L1' != [] && L2' != [] && el'STID(head(L1')) == el'STID(head(L2'))) -> set_CS_edges2'(L1',L2') = [str_STID'AP'(el'STID(head(L1')),union'(el'AP(head(L1')), el'AP(head(L2'))))] ++ set_CS_edges2'(tail(L1'),tail(L2'));
(L1' != [] && L2' != [] && el'STID(head(L1')) < el'STID(head(L2'))) -> set_CS_edges2'(L1',L2') = [head(L1')] ++ set_CS_edges2'(tail(L1'),L2');
(L1' != [] && L2' != [] && el'STID(head(L1')) > el'STID(head(L2'))) -> set_CS_edges2'(L1',L2') = [head(L2')] ++ set_CS_edges2'(L1',tail(L2'));

map set_CSout_edges': Object' # STID' # List(STID'AP') # AccessPattern' # CS' -> CS';
var st': STID';
    L': List(STID');
    a': AccessPattern';
    cs': CS';
{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
{% set smloop = loop %}
{% for tr in sm.transitions %}
{% if (oloop.first and smloop.first and loop.first) %}eqn {% else %}    {% endif %}set_CSout_edges'({{o.name}},ST'{{tr._tx_position}},L',a',cs') = str_CS'({% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o2.type.statemachines %}{{', ' if not (o2loop.first and loop.first)}}{% if not (o == o2 and sm == sm2) %}el'{{o2.name}}'{{sm2.name}}(cs'){% else %}set_CSout_edges1'({{o.name}},ST'{{tr._tx_position}},create_STID'AP's(L',a'),el'{{o2.name}}'{{sm2.name}}(cs')){% endif %}{% endfor %}{% endfor %});
{% endfor %}
{% endfor %}
{% endfor %}

map set_CSout_edges1': STID' # List(STID'AP') # List(STID'CS') -> List(STID'CS');
var st': STID';
    La': List(STID'AP');
    L': List(STID'CS');
eqn set_CSout_edges1'(st',La',[]) = [str_STID'CS'(st1',[],La')];
(L' != [] && el'STID(head(L')) == st') -> set_CSout_edges1'(st',La',L') = [str_STID'CS'(st',el'CSin(head(L')),set_CS_edges2'(La',el'CSout(head(L'))))] ++ tail(L');
(L' != [] && el'STID(head(L')) < st') -> set_CSout_edges1'(st',La',L') = [head(L')] ++ set_CSout_edges1'(st',La',tail(L'));
(L' != [] && el'STID(head(L')) > st') -> set_CSout_edges1'(st',La',L') = set_CSout_edges1'(st',La',[]) ++ L';

map create_STID'AP's: List(STID'AP') # AccessPattern' -> List(STID'AP');
var L': List(STID'AP');
    a': AccessPattern';
eqn create_STID'AP's([],a') = [];
(L' != []) -> create_STID'AP's(L',a') = [str_STID'AP(el'STID(head(L')),a')] ++ create_STID'AP's(tail(L'),a');

% *** RESET EDGES TO/FROM GIVEN OBJECT/STID PAIR ***

% TODO
map reset_CSout_edges': Object' # STID' # STID' # CS' -> CS';
var st': STID';
    cs': CS';
{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
{% set smloop = loop %}
{% for tr in sm.transitions %}
{% if (oloop.first and smloop.first and loop.first) %}eqn {% else %}    {% endif %}reset_CSout_edges'({{o.name}},ST'{{tr._tx_position}},st',a',cs') = str_CS'({% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o2.type.statemachines %}{{', ' if not (o2loop.first and loop.first)}}{% if not (o == o2 and sm == sm2) %}el'{{o2.name}}'{{sm2.name}}(cs'){% else %}set_CSout_edge1'({{o.name}},ST'{{tr._tx_position}},st',a',el'{{o2.name}}'{{sm2.name}}(cs')){% endif %}{% endfor %}{% endfor %});
{% endfor %}
{% endfor %}
{% endfor %}

% *** FUNCTION TO ADD A GIVEN ACCESSPATTERN OF A GIVEN OBJECT/STATE MACHINE PAIR TO A P-SUMMARY ***

map add_to_PS': Object_SM' # AccessPattern' # PS' -> PS';
var ps': PS';
    a1': AccessPattern';
{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
{% if (oloop.first and loop.first) %}eqn {% else %}    {% endif %}add_to_PS'(O'SM'({{o.name}},{{sm.name}}),a1',ps') = Psum'({% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o2.type.statemachines %}{{', ' if not (o2loop.first and loop.first)}}{% if o == o2 and sm == sm2 %}union_plus'(el'{{o2.name}}'{{sm2.name}}(ps'), a1'){% else %}el'{{o2.name}}'{{sm2.name}}(ps'){% endif %}{% endfor %}{% endfor %});
{% endfor %}
{% endfor %}

% ----- END DEPENDENCY GRAPH STRUCTURE AND BASIC FUNCTIONS -----


% ----- START SEQUENTIAL CONSISTENCY VIOLATION CHECKING ALGORITHM -----

% *** PROCESS TRANSACTION PROCEDURE ***

map process_instruction': Object' # Statemachine' # STID' # CS' # OutgoingTransitions # List(Var') -> CS';
var o1': Object';
    sm1': Statemachine';
    st': STID';
    cs': CS';
    out': OutgoingTransitions;
    filter': List(Var');
eqn process_instruction'(o1',sm1',st',cs',out',filter') = process_instruction1'(o1',sm1',st',cs',get_conflicting_STID's(o1',st',out',filter'), get_CSin's(o1',st',cs'), get_CSout's(o1',st',cs'));

map process_instruction1': Object' # Statemachine' # STID' # CS' # List(STID'AP') # List(STID'AP') # List(STID'AP') -> CS';
var o1': Object';
    sm1': Statemachine';
    st': STID';
    cs': CS';
    conflicts': List(STID'AP');
    in_edges': List(STID'AP');
    out_edges': List(STID'AP');
eqn process_instruction1'(o1',sm1',st',cs',conflicts',in_edges',out_edges') = process_instruction1_C_CSin'(o1',sm1',st',conflicts',in_edges',process_instruction1_C_CSout'(o1',sm1',st',conflicts',out_edges',process_instruction1_C_C'(o1',sm1',st',conflicts',process_instruction1_CS_CS'(o1',sm1',st',in_edges',out_edges',cs'))));

% TODO: remove connections to st', and add C_PS

map process_instruction1_C_CSin': Object' # Statemachine' # STID' # List(STID'AP') # List(STID'AP') # CS' -> CS';
var o1': Object';
    sm1': Statemachine';
    st': STID';
    conflicts': List(STID'AP');
    in_edges': List(STID'AP');
    cs': CS';
eqn process_instruction1_C_CSin'(o',sm1',st',conflicts',in_edges',cs') = process_instruction1_add_edges'(o1',sm1',st',conflicts',in_edges',cs');

map process_instruction1_C_CSout': Object' # Statemachine' # STID' # List(STID'AP') # List(STID'AP') # CS' -> CS';
var o1': Object';
    sm1': Statemachine';
    st': STID';
    conflicts': List(STID'AP');
    out_edges': List(STID'AP');
    cs': CS';
eqn process_instruction1_C_CSout'(o',sm1',st',conflicts',out_edges',cs') = process_instruction1_add_edges'(o1',sm1',st',out_edges',conflicts',cs');

% to do: prevent adding self-loops

map process_instruction1_C_C': Object' # Statemachine' # STID' # List(STID'AP') # CS' -> CS';
var o1': Object';
    sm1': Statemachine';
    st': STID';
    conflicts': List(STID'AP');
    cs': CS';
eqn process_instruction1_C_C'(o',sm1',st',conflicts',cs') = process_instruction1_add_edges'(o1',sm1',st',conflicts',conflicts',cs');

map process_instruction1_CS_CS': Object' # Statemachine' # STID' # List(STID'AP') # List(STID'AP') # CS' -> CS';
var o1': Object';
    sm1': Statemachine';
    st': STID';
    in_edges': List(STID'AP');
    out_edges': List(STID'AP');
    cs': CS';
eqn process_instruction1_C_C'(o',sm1',st',in_edges',out_edges',cs') = process_instruction1_add_edges'(o1',sm1',st',out_edges',in_edges',cs');

map process_instruction1_add_edges': Object' # Statemachine' # STID' # List(STID'AP') # List(STID'AP') # CS' -> CS';
var o1': Object';
    sm1': Statemachine';
    st': STID';
    L1', L2': List(STID'AP');
    cs': CS';
eqn process_instruction1_add_edges'(o',sm1',st',L1',L2',cs') = process_instruction1_add_edges1'(o',sm1',st',L1',L2',process_instruction1_add_edges2'(o',sm1',st',L1',L2',cs'));

map process_instruction1_add_edges1': Object' # Statemachine' # STID' # List(STID'AP') # List(STID'AP') # CS' -> CS';
var o1': Object';
    sm1': Statemachine';
    st': STID';
    L1', L2': List(STID'AP');
    cs': CS';
eqn process_instruction1_add_edges1'(o',sm1',st',L1',[],cs') = cs';
(L2' != []) -> process_instruction1_add_edges1'(o',sm1',st',L1',L2',cs') = process_instruction1_add_edges1'(o',sm1',st',L1',tail(L2'), set_CSin_edges'(o',el'STID(head(L2')),L1',el'AP(head(L2')),cs'));

map process_instruction1_add_edges2': Object' # Statemachine' # STID' # List(STID'AP') # List(STID'AP') # CS' -> CS';
var o1': Object';
    sm1': Statemachine';
    st': STID';
    L1', L2': List(STID'AP');
    cs': CS';
eqn process_instruction1_add_edges2'(o',sm1',st',[],L2',cs') = cs';
(L1' != []) -> process_instruction1_add_edges2'(o',sm1',st',L1',L2',cs') = process_instruction1_add_edges2'(o',sm1',st',tail(L1'),L2', set_CSout_edges'(o',el'STID(head(L1')),L2',el'AP(head(L1')),cs'));

% *** STATEMACHINE/STID PAIR ***

sort SM_STID' = struct SM'S'(SM': Statemachine', ST': STID');

% *** UPDATE BLOCKS (ACCESS PATTERNS) PROCEDURE ***

map update_blocks': OutgoingTransitions # DPGraph'{{model|mcrl2_model_vartypes(True)}} -> DPGraph';
var out': OutgoingTransitions;
    g': DPGraph';
    {{model|mcrl2_model_vars_with_types(False)}};
eqn update_blocks'(out',g'{{model|mcrl2_model_vars(True)}}) = DG'({% for o in model.objects %}{{', ' if not loop.first }}update_blocks1'({{o.name}}, []{% for sm in o.type.statemachines %} ++ get_SM_STIDs'({{sm.name}}, el'{{o.name}}'{{sm.name}}(out')){% endfor %}, el'{{o.name}}(g'){% endfor %}{{model|mcrl2_model_vars(True)}}), PREV'(g'));

map get_SM_STIDs': Statemachine' # List(STID') -> List(SM_STID');
var sm1': Statemachine';
    L': List(STID');
eqn get_SM_STIDs'(sm1',[]) = [];
(L' != []) -> get_SM_STIDs'(sm1',L') = [SM'S'(sm1',head(L'))] ++ get_SM_STIDs'(sm1',tail(L'));

map update_blocks1': Object' # List(SM_STID') # List(DPNode'){{model|mcrl2_model_vartypes(True)}} -> List(DPNode');
var o1': Object';
    L': List(SM_STID');
    LN': List(DPNode');
    {{model|mcrl2_model_vars_with_types(False)}};
eqn update_blocks1'(o1',[],LN'{{model|mcrl2_model_vars(True)}}) = [];
(L' != []) -> update_blocks1'(o1',L',[]{{model|mcrl2_model_vars(True)}}) = [create_new_block'(o1', head(L'){{model|mcrl2_model_vars(True)}})] ++ update_blocks1'(o1',tail(L'),[]{{model|mcrl2_model_vars(True)}});
(L' != [] && LN' != [] && lt'(O'SM'(o1',SM'(head(L'))), OSM'(head(LN')))) -> update_blocks1'(o1',L',LN'{{model|mcrl2_model_vars(True)}}) = [create_new_block'(o1', head(L'){{model|mcrl2_model_vars(True)}})] ++ update_blocks1'(o1',tail(L'),LN'{{model|mcrl2_model_vars(True)}});
(L' != [] && LN' != [] && gt'(O'SM'(o1',SM'(head(L'))), OSM'(head(LN')))) -> update_blocks1'(o1',L',LN'{{model|mcrl2_model_vars(True)}}) = update_blocks1'(o1',L',tail(LN'){{model|mcrl2_model_vars(True)}});
(L' != [] && LN' != [] && eq'(O'SM'(o1',SM'(head(L'))), OSM'(head(LN')))) -> update_blocks1'(o1',L',LN'{{model|mcrl2_model_vars(True)}}) = [N'(OSM'(head(LN')), ST'(head(LN')), rwpattern(o1', ST'(head(LN')){{model|mcrl2_model_vars(True)}}), H'(head(LN')), d'(head(LN')), c'(head(LN')), owner'(head(LN')))] ++ update_blocks1'(o1',tail(L'),tail(LN'){{model|mcrl2_model_vars(True)}});

map create_new_block': Object' # SM_STID'{{model|mcrl2_model_vartypes(True)}} -> DPNode';
var o1': Object';
    s': SM_STID';
    {{model|mcrl2_model_vars_with_types(False)}};
eqn create_new_block'(o1',s'{{model|mcrl2_model_vars(True)}}) = N'(O'SM'(o1',SM'(s')), ST'(s'), rwpattern(o1', ST'(s'){{model|mcrl2_model_vars(True)}}), empty_History', D_init', C_init', []);

% *** DETECT VIOLATIONS PROCEDURE ***

map detect_violations': Object' # Statemachine' # STID' # DPGraph' # List(Var') -> O'SM'ST'Advice';
var o1': Object';
    sm1': Statemachine';
    st': STID';
    g': DPGraph';
    L': List(Var');
eqn detect_violations'(o1',sm1',st',g',L') = detect_violations3'(o1',sm1',st',detect_violations1'(o1', g', get_dpnode'(g',o1',sm1',st'), L'));

map detect_violations1': Object' # DPGraph' # DPNode' # List(Var') -> Advice';
var g': DPGraph';
    n1': DPNode';
    L': List(Var');
{% for o in model.objects %}
{% if loop.first %}eqn {% else %}    {% endif %}detect_violations1'({{o.name}}, g',n1',L') = detect_violations2'(n1', el'{{o.name}}(g') ++ [PREV'(g')], L');
{% endfor %}

map detect_violations2': DPNode' # List(DPNode') # List(Var') -> Advice';
var n1': DPNode';
    L1': List(DPNode');
    L2': List(Var');
eqn detect_violations2'(n1',[],L2') = empty_Advice';
    detect_violations2'(n1',L1',[]) = empty_Advice';
(L1' != [] && L2' != []) -> detect_violations2'(n1',L1',L2') = combine'(perform_C'(n1', head(L1'), L2'), detect_violations2'(n1', tail(L1'), L2'));

map detect_violations3': Object' # Statemachine' # STID' # Advice' -> O'SM'ST'Advice';
var o1': Object';
    sm1': Statemachine';
    st': STID';
    ad': Advice';
eqn (ad' == empty_Advice') -> detect_violations3'(o1',sm1',st',ad') = empty_O'SM'ST'Advice';
(ad' != empty_Advice') -> detect_violations3'(o1',sm1',st',ad') = O'SM'ST'AD'(o1',sm1',st',ad');

% *** OVERALL CHECKING AND PERFORMING OF UPDATE FOR PAIR OF NODES ***

map perform_U': DPNode' # DPNode' # List(Var') -> DPNode';
var n1', n2': DPNode';
    L': List(Var');
eqn perform_U'(n1',n2',L') = perform_U2'(n1', perform_U1'(n1',n2',L'), L');

% *** CHECK AND PERFORM UPDATE 1 ***

map perform_U1': DPNode' # DPNode' # List(Var') -> DPNode';
var n1', n2': DPNode';
    L': List(Var');
eqn perform_U1'(n1',n2',L') = perform_U1_1'(n1',n2', union'(dep_v_b'(n1', n2', L'), d_set'(n2', dep_v_h'(n1', n2', L'), L')));

map perform_U1_1': DPNode' # DPNode' # AccessPattern' ->DPNode';
var n1', n2': DPNode';
    a': AccessPattern';
eqn (!not_empty(a')) -> perform_U1_1'(n1',n2',a') = n2';
(not_empty(a')) -> perform_U1_1'(n1',n2',a') = perform_U1_2'(n1', n2', a', add_osm'(OSM'(n1'), P'(n1'), H'(extract_osm'(n1', OSM'(n2')))), setminus(union'([OSM'(n1')],owner'(n1')), [OSM'(n2')]));

map perform_U1_2': DPNode' # DPNode' # AccessPattern' # History' # List(Object_SM') -> DPNode';
var n1', n2': DPNode';
    a': AccessPattern';
    h1': History';
    L': List(Object_SM');
eqn perform_U1_2'(n1',n2',a',h1',L') = N'(OSM'(n2'), ST'(n2'), P'(n2'), union'(H'(n2'), h1'), update_d'(d'(n2'), h1', a'), update_c'(c'(n2'), L', a'), union'(L', owner'(n2')));

% *** CHECK AND PERFORM UPDATE 2 ***

map perform_U2': DPNode' # DPNode' # List(Var') -> DPNode';
var n1', n2': DPNode';
    L': List(Var');
eqn (!are_competing(n1',n2')) -> perform_U2'(n1',n2',L') = n2';
(are_competing(n1',n2')) -> perform_U2'(n1',n2',L') = perform_U2_1'(n1', n2', dep_o_h'(n1',n2'),L');

map perform_U2_1': DPNode' # DPNode' # List(Object_SM') # List(Var') -> DPNode';
var n1', n2': DPNode';
    L1': List(Object_SM');
    L2': List(Var');
eqn perform_U2_1'(n1',n2',[],L2') = n2';
    perform_U2_1'(n1',n2',L1',[]) = n2';
(L1' != [] && L2' != []) -> perform_U2_1'(n1',n2',L1',L2') = perform_U2_2'(n1', n2', L1', remove(union'([OSM'(n1')], owner'(n1')), OSM'(n2')), L2');

map perform_U2_2': DPNode' # DPNode' # List(Object_SM') # List(Object_SM') # List(Var') -> DPNode';
var n1', n2': DPNode';
    L1',L2': List(Object_SM');
    L3': List(Var');
eqn perform_U2_2'(n1',n2',[],L2',L3') = n2';
    perform_U2_2'(n1',n2',L1',[],L3') = n2';
    perform_U2_2'(n1',n2',L1',L2',[]) = n2';
(L1' != [] && L2' != [] && L3' != []) -> perform_U2_2'(n1',n2',L1',L2',L3') = N'(OSM'(n2'), ST'(n2'), P'(n2'), H'(n2'), d'(n2'), update_c'(c'(n2'), L2', c_set'(n2', L1', L3')), union'(L2',owner'(n2')));

% *** SPECIFICATION OF seqcon VIOLATION RESOLUTION ADVICE ***

sort Advice' = struct AD'(LK': AccessPattern', LO': List(Shuffle'));
map empty_Advice': Advice';
eqn empty_Advice' = AD'(A'([],[]),[]);

% *** SPECIFICATION OF SHUFFLE ORDER ***

sort Shuffle' = struct SH'(SB': AccessPattern', SA': AccessPattern');
map empty_Shuffle': Shuffle';
eqn empty_Shuffle' = SH'(A'([],[]),A'([],[]));

map union': List(Shuffle') # List(Shuffle') -> List(Shuffle');
var L1',L2': List(Shuffle');
eqn union'(L1',[]) = L1';
    union'([],L2') = L2';
(L1' != [] && L2' != [] && head(L1') < head(L2')) -> union'(L1',L2') = [head(L1')] ++ union'(tail(L1'),L2');
(L1' != [] && L2' != [] && head(L1') > head(L2')) -> union'(L1',L2') = [head(L2')] ++ union'(L1',tail(L2'));
(L1' != [] && L2' != [] && head(L1') == head(L2')) -> union'(L1',L2') = [head(L1')] ++ union'(tail(L1'),tail(L2'));

% *** SPECIFICATION OF ADVICE FOR SPECIFIC OBJECT/STATEMACHINE/STID ***

sort O'SM'ST'Advice' = struct O'SM'ST'AD'(O': Object', SM': Statemachine', ST': STID', AD': Advice');
map empty_O'SM'ST'Advice': O'SM'ST'Advice';
eqn empty_O'SM'ST'Advice' = O'SM'ST'AD'(o_, sm_, st_, empty_Advice');

map combine': Advice' # Advice' -> Advice';
var ad1', ad2': Advice';
eqn combine'(ad1',ad2') = combine1'(LO'(ad1'),LO'(ad2'),compute_lockset'(ad1',ad2'));

map combine1': List(Shuffle') # List(Shuffle') # AccessPattern' -> Advice';
var lo1',lo2': List(Shuffle');
    al': AccessPattern';
eqn combine1'(lo1',lo2',al') = AD'(al', combine2'(union'(lo1',lo2'),al'));

map combine2': List(Shuffle') # AccessPattern' -> List(Shuffle');
var L': List(Shuffle');
    a': AccessPattern';
eqn combine2'([],a') = [];
(L' != []) -> combine2'(L',a') = combine3'(union'([SH'(setminus(SB'(head(L')), a'), setminus(SA'(head(L')), a'))], combine2'(tail(L'), a')));

map combine3': List(Shuffle') -> List(Shuffle');
var L': List(Shuffle');
eqn (L' == [empty_Shuffle']) -> combine3'(L') = [];
(L' != [empty_Shuffle']) -> combine3'(L') = L';

% identify which accesses need to be protected
map compute_lockset': Advice' # Advice' -> AccessPattern';
var ad1', ad2': Advice';
eqn (LO'(ad1') == [] || LO'(ad2') == []) -> compute_lockset'(ad1',ad2') = union'(LK'(ad1'), LK'(ad2'));
(LO'(ad1') != [] && LO'(ad2') != []) -> compute_lockset'(ad1',ad2') = union'(LK'(ad1'), union'(LK'(ad2'), compute_lockset1'(LO'(ad1'), LO'(ad2'))));

map compute_lockset1': List(Shuffle') # List(Shuffle') -> AccessPattern';
var L1',L2': List(Shuffle');
eqn compute_lockset1'(L1',[]) = A'([],[]);
    compute_lockset1'([],L2') = A'([],[]);
(L1' != [] && L2' != []) -> compute_lockset1'(L1',L2') = union'(compute_lockset2'(head(L1'),L2'), compute_lockset1'(tail(L1'), L2'));

map compute_lockset2': Shuffle' # List(Shuffle') -> AccessPattern';
var sh': Shuffle';
    L': List(Shuffle');
eqn compute_lockset2'(sh',[]) = A'([],[]);
(L' != []) -> compute_lockset2'(sh',L') = union'(compute_lockset3'(sh', head(L'), intersection(SB'(sh'), SA'(head(L'))), intersection(SB'(head(L')), SA'(sh'))), compute_lockset2'(sh', tail(L')));

map compute_lockset3': Shuffle' # Shuffle' # AccessPattern' # AccessPattern' -> AccessPattern';
var sh1',sh2': Shuffle';
    a1',a2': AccessPattern';
eqn (a1' == A'([],[]) || a2' == A'([],[])) -> compute_lockset3'(sh1',sh2',a1',a2') = A'([],[]);
(a1' != A'([],[]) || a2' != A'([],[])) -> compute_lockset3'(sh1',sh2',a1',a2') = union'(a1',a2');

% *** OVERALL SEQUENTIAL CONSISTENCY VIOLATION CHECK FOR PAIR OF NODES ***

map perform_C': DPNode' # DPNode' # List(Var') -> Advice';
var n1', n2': DPNode';
    L': List(Var');
eqn perform_C'(n1',n2',L') = perform_C_1'(n1', n2', dep_v_b'(n2', n1', L'), L');

map perform_C_1': DPNode' # DPNode' # AccessPattern' # List(Var') -> Advice';
var n1', n2': DPNode';
    b1': AccessPattern';
    L': List(Var');
eqn (!not_empty(b1')) -> perform_C_1'(n1',n2',b1',L') = empty_Advice';
    (not_empty(b1')) -> perform_C_1'(n1',n2',b1',L') = combine'(perform_C1'(n1',n2',b1',L'), perform_C2'(n1',n2',b1',L'));

% *** seqcon VIOLATION CHECK 1 ***

map perform_C1': DPNode' # DPNode' # AccessPattern' # List(Var') -> Advice';
var n1', n2': DPNode';
    b1': AccessPattern';
    L': List(Var');
eqn perform_C1'(n1',n2',b1',L') = perform_C1_1'(union'(b1', d_set'(n1', dep_v_h'(n2', n1', L'), L')));

map perform_C1_1': AccessPattern' -> Advice';
var b': AccessPattern';
eqn (!has_at_least_two(b')) -> perform_C1_1'(b') = empty_Advice';
(has_at_least_two(b')) -> perform_C1_1'(b') = AD'(b', []);

% *** seqcon VIOLATION CHECK 2 ***

map perform_C2': DPNode' # DPNode' # AccessPattern' # List(Var') -> Advice';
var n1', n2': DPNode';
    b1': AccessPattern';
    L': List(Var');
eqn perform_C2'(n1',n2',b1',L') = perform_C2_1'(b1', c_set'(n1', dep_o_b'(n2', n1'), L'));

map perform_C2_1': AccessPattern' # AccessPattern' -> Advice';
var b1', cb': AccessPattern';
eqn (!has_at_least_two(union'(b1', cb'))) -> perform_C2_1'(b1',cb') = empty_Advice';
(has_at_least_two(union'(b1', cb'))) -> perform_C2_1'(b1',cb') = perform_C2_2'(b1', cb', intersection(b1', cb'));

map perform_C2_2': AccessPattern' # AccessPattern' # AccessPattern' -> Advice';
var b1', cb', L': AccessPattern';
eqn perform_C2_2'(b1',cb',L') = AD'(L', [SH'(setminus(b1',L'), setminus(cb',L'))]);

% ----- END seqcon VIOLATION CHECKING ALGORITHM -----



% ----- START POR -----

% *** FUNCTION TO PERFORM (AMPLE-SET BASED) POR ***

map apply_por: OutgoingTransitions{{model|mcrl2_model_vartypes(True)}} -> OutgoingTransitions;
var L': OutgoingTransitions{{model|mcrl2_model_vars_with_types(True)}};
eqn apply_por(OT'({% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o2.type.statemachines %}{% set sm2loop = loop %}{{', ' if not (o2loop.first and sm2loop.first) }}[]{% endfor %}{% endfor %}){{model|mcrl2_model_vars(True)}}) = OT'({% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o2.type.statemachines %}{% set sm2loop = loop %}{{', ' if not (o2loop.first and sm2loop.first) }}[]{% endfor %}{% endfor %});
    apply_por(L'{{model|mcrl2_model_vars(True)}}) = apply_por1_1(L'{{model|mcrl2_model_vars(True)}});

{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
map apply_por{{oloop.index}}_{{loop.index}}: OutgoingTransitions{{model|mcrl2_model_vartypes(True)}} -> OutgoingTransitions;
var L': OutgoingTransitions{{model|mcrl2_model_vars_with_types(True)}};
eqn apply_por{{oloop.index}}_{{loop.index}}(OT'({% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o2.type.statemachines %}{% set sm2loop = loop %}{{', ' if not (o2loop.first and sm2loop.first) }}[]{% endfor %}{% endfor %}){{model|mcrl2_model_vars(True)}}) = OT'({% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o2.type.statemachines %}{% set sm2loop = loop %}{{', ' if not (o2loop.first and sm2loop.first) }}[]{% endfor %}{% endfor %});
    apply_por{{oloop.index}}_{{loop.index}}(L'{{model|mcrl2_model_vars(True)}}) = apply_por{{oloop.index}}_{{loop.index}}_1(L'{{model|mcrl2_model_vars(True)}}, sm_trans_are_ample({{o.name}}, el'{{o.name}}'{{sm.name}}(L'){{model|mcrl2_model_vars(True)}}, []));

map apply_por{{oloop.index}}_{{loop.index}}_1: OutgoingTransitions{{model|mcrl2_model_vartypes(True)}} # List(STID') -> OutgoingTransitions;
var L': OutgoingTransitions{{model|mcrl2_model_vars_with_types(True)}}, LS': List(STID');
eqn apply_por{{oloop.index}}_{{loop.index}}_1(OT'({% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o2.type.statemachines %}{% set sm2loop = loop %}{{', ' if not (o2loop.first and sm2loop.first) }}[]{% endfor %}{% endfor %}){{model|mcrl2_model_vars(True)}}, LS') = OT'({% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o2.type.statemachines %}{% set sm2loop = loop %}{{', ' if not (o2loop.first and sm2loop.first) }}[]{% endfor %}{% endfor %});
(LS' != []) -> apply_por{{oloop.index}}_{{loop.index}}_1(L'{{model|mcrl2_model_vars(True)}}, LS') = OT'({% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o2.type.statemachines %}{% set sm2loop = loop %}{{', ' if not (o2loop.first and sm2loop.first) }}{% if o == o2 and sm == sm2 %}LS'{% else %}[]{% endif %}{% endfor %}{% endfor %});
{% if oloop.last and loop.last %}
(LS' == []) -> apply_por{{oloop.index}}_{{loop.index}}_1(L'{{model|mcrl2_model_vars(True)}}, LS') = L';
{% else %}
(LS' == []) -> apply_por{{oloop.index}}_{{loop.index}}_1(L'{{model|mcrl2_model_vars(True)}}, LS') = apply_por{% if loop.last %}{{oloop.index+1}}_1{% else %}{{oloop.index}}_{{loop.index+1}}{% endif %}(L'{{model|mcrl2_model_vars(True)}});
{% endif %}

{% endfor %}
{% endfor %}
map sm_trans_are_ample: Object' # List(STID'){{model|mcrl2_model_vartypes(True)}} # List(STID') -> List(STID');
var o': Object', L1', L2': List(STID'){{model|mcrl2_model_vars_with_types(True)}};
eqn sm_trans_are_ample(o', []{{model|mcrl2_model_vars(True)}}, L2') = L2';
(L1' != [] && por_issafe(o', head(L1'){{model|mcrl2_model_vars(True)}}) && isenabled(o', head(L1'){{model|mcrl2_model_vars(True)}})) -> sm_trans_are_ample(o', L1'{{model|mcrl2_model_vars(True)}}, L2') = sm_trans_are_ample(o', tail(L1'){{model|mcrl2_model_vars(True)}}, L2' ++ [head(L1')]);
(L1' != [] && por_issafe(o', head(L1'){{model|mcrl2_model_vars(True)}}) && !isenabled(o', head(L1'){{model|mcrl2_model_vars(True)}})) -> sm_trans_are_ample(o', L1'{{model|mcrl2_model_vars(True)}}, L2') = sm_trans_are_ample(o', tail(L1'){{model|mcrl2_model_vars(True)}}, L2');
(L1' != [] && !por_issafe(o', head(L1'){{model|mcrl2_model_vars(True)}})) -> sm_trans_are_ample(o', L1'{{model|mcrl2_model_vars(True)}}, L2') = [];

% ----- END POR -----



% *** ACTIONS TO REPORT DATA ACCESS PATTERNS ***

{% for o in model.objects %}
{% if loop.first %}act {% else %}    {% endif %}rw: Object' # Statemachine' # List(Var') # List(Var');
{% endfor %}
{% for p in object_sync_commpairs %}
{% if loop.first %}act {% else %}    {% endif %}rw: Object' # Statemachine' # List(Var') # List(Var') # Object' # Statemachine' # List(Var') # List(Var');
{% endfor %}
    % report action to report seqcon violation resolutions (detected on-the-fly)
    report: Object' # Statemachine' # STID' # Advice';
    % action indicating that all variables need to be locked;
    lock_all;

% ***  SPECIFICATION OF BEHAVIOUR ***

proc {{model.name}}({% for o in model.objects %}{% set oloop = loop %}{% for stm in o.type.statemachines %}{{', ' if not (oloop.first and loop.first) }}{{o.name}}'{{stm.name}}_state: State'{% endfor %}{% endfor %}{{model|mcrl2_model_vars_with_types(True)}}, outtrans: OutgoingTransitions, depgraph': DPGraph', watchlist': List(Var'), violations': O'SM'ST'Advice', seqcon_check_done: Bool) =
(watchlist' != [] && violations' == empty_O'SM'ST'Advice' && !seqcon_check_done) -> (
{% for o in model.objects %}
{% set oloop = loop %}
{% for sm in o.type.statemachines %}
{% set smloop = loop %}
{% for tr in sm.transitions %}
{% set trloop = loop %}
{% if tr.statements[0].__class__.__name__ != "ReceiveSignal" or ochannel[o][tr.statements[0]].synctype == "async" %}
  (ST'{{tr._tx_position}} in sm_outgoing({{o.name}}, {{sm.name}}, outtrans){% if tr.statements[0]|hascondition(o) %}) -> (({{tr.statements[0]|statement_condition(o)}}{% endif %}) -> (
    {% if syncing_statements[o][tr.statements[0]]|length == 0 %}    {% if check_onthefly %}tau{% else %}rw({{o.name}}, {{sm.name}}, R'(rwpattern({{o.name}}, ST'{{tr._tx_position}}{{model|mcrl2_model_vars(True)}})), W'(rwpattern({{o.name}}, ST'{{tr._tx_position}}{{model|mcrl2_model_vars(True)}}))){% endif %} . {{model.name}}({{o.name}}'{{sm.name}}_state={{tr.target.name}}{{tr.statements[0]|statementstatechanges(o)}}, outtrans={% if apply_por %}apply_por(OT'({% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o.type.statemachines %}{{', ' if not (o2loop.first and loop.first) }}outgoing({{o2.type.name}}, {{sm2.name}}, {% if o == o2 and sm == sm2 %}{{tr.target.name}}{% else %}{{o2.name}}'{{sm2.name}}_state{% endif %}){% endfor %}{% endfor %}){{tr.statements[0]|complete_newstate(o)}}){% else %}update_outgoing({{o.name}}, {{sm.name}}, {{tr.target.name}}, outtrans){% endif %}{% if check_onthefly %}, depgraph'=process_transaction'({{o.name}}, {{sm.name}}, ST'{{tr._tx_position}}, depgraph', watchlist', has_disabled'({{o.name}}, {{sm.name}}, outtrans{{model|mcrl2_model_vars(True)}})), violations'=if(!issafe({{o.name}}, ST'{{tr._tx_position}}{{model|mcrl2_model_vars(True)}}), detect_violations'({{o.name}}, {{sm.name}}, ST'{{tr._tx_position}}, depgraph', watchlist'), empty_O'SM'ST'Advice'), seqcon_check_done=true{% endif %})
  ){% if tr.statements[0]|hascondition(o) %}){% endif %}{%else %}{% for sync in syncing_statements[o][tr.statements[0]] %}    (ST'{{transowner[sync[1]]._tx_position}} in sm_outgoing({{sync[0].name}}, {{statemachine[sync[1]].name}}, outtrans){% if sync[1]|hascondition(sync[0]) %}) -> (({{sync[1]|sync_statement_condition(sync[0], tr.statements[0], o)}}{% endif %}) -> ({% if check_onthefly %}tau{% else %}rw({{o.name}}, {{sm.name}}, {{tr.statements[0]|mcrl2_read_accesspattern(o,True)}}, {{tr.statements[0]|mcrl2_write_accesspattern(o,True)}}, {{sync[0].name}}, {{statemachine[sync[1]].name}}, R'(rwpattern({{sync[0].name}}, ST'{{transowner[sync[1]]._tx_position}}{{model|mcrl2_model_vars(True)}}), W'(rwpattern({{sync[0].name}}, ST'{{transowner[sync[1]]._tx_position}}{{model|mcrl2_model_vars(True)}})))){% endif %} . {{model.name}}({{o.name}}'{{sm.name}}_state={{tr.target.name}}, {{sync[0].name}}'{{statemachine[sync[1]].name}}_state={{transowner[sync[1]].target.name}}{{sync[1]|sync_statementstatechanges(sync[0],tr.statements[0],o)}}, outtrans={% if apply_por %}apply_por(OT'({% for o2 in model.objects %}{% set o2loop = loop %}{% for sm2 in o.type.statemachines %}{{', ' if not (o2loop.first and loop.first) }}outgoing({{o2.type.name}}, {{sm2.name}}, {% if o == o2 and sm == sm2 %}{{tr.target.name}}{% elif sync[0] == o2 and statemachine[sync[1]] == sm2 %}{{transowner[sync[1]].target.name}}{% else %}{{o2.name}}'{{sm2.name}}_state{% endif %}){% endfor %}{% endfor %}){{tr.statements[0]|sync_complete_newstate(o)}}){% else %}update_outgoing({{sync[0].name}}, {{statemachine[sync[1]].name}}, {{transowner[sync[1]].target.name}}, update_outgoing({{o.name}}, {{sm.name}}, {{tr.target.name}}, outtrans)){% endif %}{% if check_onthefly %}, depgraph'=process_transaction'({{o.name}}, {{sm.name}}, ST'{{tr._tx_position}}, depgraph', watchlist', has_disabled'({{o.name}}, {{sm.name}}, outtrans{{model|mcrl2_model_vars(True)}})), violations'=if(!issafe({{o.name}}, ST'{{tr._tx_position}}{{model|mcrl2_model_vars(True)}}), detect_violations'({{o.name}}, {{sm.name}}, ST'{{tr._tx_position}}, depgraph', watchlist'), empty_O'SM'ST'Advice'), seqcon_check_done=true{% endif %}){% if not loop.last %} +{% endif %}{% endfor %} +

  ){% if sync[1]|hascondition(sync[0]) %}){% endif %}{% endif %}{% if not (oloop.last and smloop.last and trloop.last and loop.last) %} +{% endif %}

{% endif %}
{% endfor %}
{% endfor %}
{% endfor %}
){% if check_onthefly %} +{% else %};{% endif %}

{% if check_onthefly %}
(seqcon_check_done && violations' == empty_O'SM'ST'Advice') -> tau . {{model.name}}(depgraph'=update_blocks'(outtrans, depgraph'{{model|mcrl2_model_vars(True)}}), seqcon_check_done=false) +
(seqcon_check_done && violations' != empty_O'SM'ST'Advice') -> report(O'(violations'), SM'(violations'), ST'(violations'), AD'(violations')) . {{model.name}}(depgraph'=update_blocks'(outtrans, depgraph'{{model|mcrl2_model_vars(True)}}){% if lock_onthefly %}, watchlist'=setminus(watchlist',get_vars'(LK'(AD'(violations')))){% endif %}, violations'=empty_O'SM'ST'Advice', seqcon_check_done=false) +
(watchlist' == []) -> lock_all . {{model.name}}();
{% endif %}

init {{model.name}}({% for o in model.objects %}{% set oloop = loop %}{% for sm in o.type.statemachines %}{{', ' if not (oloop.first and loop.first) }}{{sm.initialstate.name}}{% endfor %}{% endfor %}{% for o in model.objects %}{% set oloop = loop %}{% for var in o.type.variables %}, {% for vinit in o.assignments %}{% if var.name == vinit.left.name %}{% if vinit.right == None %}{% if var.type.base == "Integer" or var.type.base == "Byte" %}AI{% else %}AB{% endif %}{{var.type.size}}'({% for v in vinit.rights %}{{v|mcrl2value}}{{',' if not loop.last }}{% endfor %}){% else %}{{vinit.right|mcrl2value}}{% endif %}{% break %}{% endif %}{% if loop.last %}{{var|variabledefault}}{% endif %}{% endfor %}{% if o.assignments|length == 0 %}{{var|variabledefault}}{% endif %}{% endfor %}{% for sm in o.type.statemachines %}{% for var in sm.variables %}, {{var|variabledefault}}{% endfor %}{% endfor %}{% endfor %}{% for ch in model.channels %}{% if ch.synctype == 'async' %}, [], 0{% endif %}{% endfor %}, {% if apply_por %}apply_por({% endif %}OT'({% for o in model.objects %}{% set oloop = loop %}{% for sm in o.type.statemachines %}{{', ' if not (oloop.first and loop.first) }}outgoing({{o.type.name}}, {{sm.name}}, {{sm.initialstate.name}}){% endfor %}{% endfor %}){% if apply_por %}{% for o in model.objects %}{% set oloop = loop %}{% for var in o.type.variables %}, {% for vinit in o.assignments %}{% if var.name == vinit.left.name %}{% if vinit.right == None %}{% if var.type.base == "Integer" or var.type.base == "Byte" %}AI{% else %}AB{% endif %}{{var.type.size}}'({% for v in vinit.rights %}{{v|mcrl2value}}{{',' if not loop.last }}{% endfor %}){% else %}{{vinit.right|mcrl2value}}{% endif %}{% break %}{% endif %}{% if loop.last %}{{var|variabledefault}}{% endif %}{% endfor %}{% if o.assignments|length == 0 %}{{var|variabledefault}}{% endif %}{% endfor %}{% for sm in o.type.statemachines %}{% for var in sm.variables %}, {{var|variabledefault}}{% endfor %}{% endfor %}{% endfor %}{% for ch in model.channels %}{% if ch.synctype == 'async' %}, [], 0{% endif %}{% endfor %}){% endif %}, update_blocks'(OT'({% for o in model.objects %}{% set oloop = loop %}{% for sm in o.type.statemachines %}{{', ' if not (oloop.first and loop.first) }}outgoing({{o.type.name}}, {{sm.name}}, {{sm.initialstate.name}}){% endfor %}{% endfor %}), DG'({% for o in model.objects %}{{', ' if not loop.first }}[]{% endfor %}, empty_DPNode'){% for o in model.objects %}{% set oloop = loop %}{% for var in o.type.variables %}, {% for vinit in o.assignments %}{% if var.name == vinit.left.name %}{% if vinit.right == None %}{% if var.type.base == "Integer" or var.type.base == "Byte" %}AI{% else %}AB{% endif %}{{var.type.size}}'({% for v in vinit.rights %}{{v|mcrl2value}}{{',' if not loop.last }}{% endfor %}){% else %}{{vinit.right|mcrl2value}}{% endif %}{% break %}{% endif %}{% if loop.last %}{{var|variabledefault}}{% endif %}{% endfor %}{% if o.assignments|length == 0 %}{{var|variabledefault}}{% endif %}{% endfor %}{% for sm in o.type.statemachines %}{% for var in sm.variables %}, {{var|variabledefault}}{% endfor %}{% endfor %}{% endfor %}{% for ch in model.channels %}{% if ch.synctype == 'async' %}, [], 0{% endif %}{% endfor %}), [{% for v in unsafe_variables %}{{', ' if not loop.first }}{{mcrl2varprefix}}{{v}}{% endfor %}], empty_O'SM'ST'Advice', false);