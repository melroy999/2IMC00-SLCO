#include <cooperative_groups.h>
using namespace cooperative_groups;

// type of global memory elements used
{% if vectorsize < 32 %}
#define inttype uint32_t
{% else %}
#define inttype uint64_t
{% endif %}
// type of global memory elements used
#define indextype uint32_t
// type of shared memory elements used
#define shared_inttype uint32_t
// type for shared memory cache indices
#define shared_indextype uint16_t
// type of automaton state
{% if max_statesize <= 8 %}
#define statetype uint8_t
{% elif max_statesize <= 16 %}
#define statetype uint16_t
{% elif max_statesize <= 32 %}
#define statetype uint32_t
{% else %}
#define statetype uint64_t
{% endif %}
// types of data elements
#define elem_inttype int32_t
#define elem_chartype int8_t
#define elem_booltype bool
// type for array and channel buffer indexing
{% if max_arrayindexsize <= 8 %}
#define array_indextype int8_t
{% elif max_arrayindexsize <= 16 %}
#define array_indextype int16_t
{% else %}
#define array_indextype int32_t
{% endif %}
// type for indexing in variable buffers
{% if max_buffer_allocs <= 8 %}
#define buffer_indextype int8_t
{% elif max_buffer_allocs <= 16 %}
#define buffer_indextype int16_t
{% else %}
#define buffer_indextype int32_t
{% endif %}
// type for indexing vector nodes
{% if vectortree|length < 2**8 %}
#define vectornode_indextype uint8_t;
{% elif vectortree|length < 2**16 %}
#define vectornode_indextype uint16_t;
{% elif vectortree|length < 2**32 %}
#define vectornode_indextype uint32_t;
{% elif vectortree|length < 2**64 %}
#define vectornode_indextype uint32_t;
{% endif %}

// Constant representing empty array index entry.
#define EMPTY_INDEX -1
// Constant used to initialise state variables.
#define NO_STATE {{no_state_constant}}

// CONSTANTS FOR SHARED MEMORY CACHES
// Number of retries in local cache
#define CACHERETRYFREQ 20
// Empty local cache element (exploits that a vectornode cannot be marked 'new' without being marked 'root')
#define EMPTYVECT32 0xBFFFFFFF
// Empty cache pointer
# define EMPTYCACHEPOINTERS 0xFFFF
// offset in shared memory from which loaded data can be read
#define SH_OFFSET 5
// offset in shared memory from which hash function constants can be read
#define HASHCONSTANTSOFFSET (SH_OFFSET)
// Error value to indicate a full global hash table.
#define HASHTABLE_FULL 0

// Shared memory local progress flags
#define ITERATIONS						(shared[0])
#define CONTINUE						(shared[1])
#define OPENTILECOUNT					(shared[2])
#define WORKSCANRESULT					(shared[3])
#define SCAN							(shared[4])

// CONSTANTS FOR GLOBAL MEMORY HASH TABLE
// Empty hash table element (exploits that a vectornode cannot be marked 'new' without being marked 'root')
{% if vectorsize < 32 %}
#define EMPTYVECTNODE_GLOBAL 0xBFFFFFFF
{% else %}
#define EMPTYVECTNODE_GLOBAL 0xBFFFFFFFFFFFFFFF
{% endif %}

// GPU shared memory array
extern __shared__ volatile shared_inttype shared[];

// GPU constants
static const int WARPSIZE = 32;

// thread ids and dimensions
#define THREAD_ID 				threadIdx.x
#define BLOCK_SIZE				blockDim.x
#define GRID_SIZE 				gridDim.x

// Structure of state vector:
// {{vectorstructure_string}}

// *** START FUNCTIONS FOR VECTOR TREE NODES MANIPULATION AND STORAGE ***

// Mark state as new or old
inline __device__ inttype mark_new(inttype node) {
{% if vectorsize < 32 %}
	return node | 0x80000000;
{% else %}
	return node | 0x8000000000000000;
{% endif %}
}

inline __device__ inttype mark_old(inttype node) {
{% if vectorsize < 32 %}
	return node | 0x7FFFFFFF;
{% else %}
	return node | 0x7FFFFFFFFFFFFFFF;
{% endif %}
}

// Check whether state is new
inline __device__ bool is_new(inttype node) {
{% if vectorsize < 32 %}
	return (node & 0x80000000) != 0;
{% else %}
	return (node & 0x8000000000000000) != 0;
{% endif %}
}

// Check whether the highest 32-bits of a node are set as new
inline __device__ bool head_is_new(shared_inttype node) {
	return (node & 0x80000000) != 0;
}

// Mark whether node is root.
inline __device__ inttype mark_root(inttype node) {
	return node | 0x4000000000000000;
}

// Check whether node is root.
inline __device__ bool is_root(inttype node) {
	return (node & 0x4000000000000000) != 0;
}

// Check whether the highest 32-bits of a node are set as root.
inline __device__ bool head_is_root(shared_inttype node) {
	return (node & 0x40000000) != 0;
}

{% if vectorsize > 62 %}
// Function to traverse one step in state vector tree (stored in shared memory).
inline __device__ shared_indextype sv_step(shared_inttype *d_cache, shared_indextype node_index, bool goright) {
	shared_indextype index = 0;
	shared_inttype tmp = d_cache[node_index+2];
	if (!goright) {
		asm("{\n\t"
			" .reg .u32 t1;\n\t"
			" bfe.u32 t1, %1, 15, 15;\n\t"
			" cvt.u16.u32 %0, t1;\n\t"
			"}" : "=r"(index) : "r"(tmp));
	}
	else {
		asm("{\n\t"
			" .reg .u32 t1;\n\t"
			" bfe.u32 t1, %1, 0, 15;\n\t"
			" cvt.u16.u32 %0, t1;\n\t"
			"}" : "=r"(index) : "r"(tmp));
	}
	return index;
}

// Get left or right half of a vectornode
inline __device__ shared_inttype get_left(inttype node) {
	shared_inttype result;
	asm("{\n\t"
		" .reg .u64 t1;\n\t"
		" bfe.u64 t1, %1, 32, 32;\n\t"
		" cvt.u32.u64 %0, t1;\n\t"
		"}" : "=r"(result) : "l"(node));
	return result;
}

inline __device__ shared_inttype get_right(inttype node) {
	shared_inttype result;
	asm("{\n\t"
		" cvt.u32.u64 %0, %1;\n\t"
		"}" : "=r"(result) : "l"(node));
	return result;
}

{% endif %}

// Retrieval functions for vector parts from shared memory, ignoring shared memory node pointers (d_cache pointers).
inline __device__ inttype get_vectorpart(inttype *d_cache, shared_indextype node_index, vectornode_indextype part_id) {
	switch (part_id) {
	  {% for i in range(0,vectorstructure|length) %}
	  case {{i}}:
	  	return get_vectorpart_{{i}}(d_cache, node_index);
	  {% endfor %}
	  default:
	  	return 0;
	}
}
{% for i in range(0,vectorstructure|length) %}

inline __device__ inttype get_vectorpart_{{i}}(inttype *d_cache, shared_indextype node_index) {
	{% if vectorsize < 64 %}
	return d_cache[node_index];
	{% else %}
	{% if i|get_vector_tree_to_part_navigation|length > 0 %}
	shared_indextype index = node_index;
	{% endif %}
	{% for b in i|get_vector_tree_to_part_navigation %}
	index = sv_step(d_cache, index, {% if b %}true{% else %}false{% endif %});
	{% endfor %}
	inttype part;
	asm("{\n\t"
		" mov.b64 %0,{ %1, %2 };\n\t"
		"}" : "=l"(part) : "r"(d_cache[{% if i|get_vector_tree_to_part_navigation|length > 0 %}index{% else %}node_index{% endif %}]), "r"(d_cache[{% if i|get_vector_tree_to_part_navigation|length > 0 %}index{% else %}node_index{% endif %}+1]));
	return part;

	{% endif %}
}
{% endfor %}

// Retrieval functions for vector tree nodes from shared memory, including shared memory node pointers (d_cache pointers).
inline __device__ void get_vectortree_node(inttype *node, shared_inttype *d_cachepointers, inttype *d_cache, shared_indextype node_index, vectornode_indextype i) {
	switch (i) {
	  {% for i in range(0,vectortree|length) %}
	  case {{i}}:
	  	get_vectortree_node_{{i}}(node, d_cachepointers, d_cache, node_index);
	  {% endfor %}
	  default:
	  	return;
	}
}
{% for i in range(0,vectortree|length) %}

inline __device__ void get_vectortree_node_{{i}}(inttype *node, shared_inttype *d_cachepointers, inttype *d_cache, shared_indextype node_index) {
	{% if i|get_vector_tree_to_node_navigation|length > 0 %}
	shared_indextype index = node_index;
	{% endif %}
	{% for b in i|get_vector_tree_to_node_navigation %}
	index = sv_step(d_cache, index, {% if b %}true{% else %}false{% endif %});
	{% endfor %}
	asm("{\n\t"
		" mov.b64 %0,{ %1, %2 };\n\t"
		"}" : "={% if vectorsize < 32 %}r{% else %}l{% endif %}"(*node) : "r"(d_cache[{% if i|get_vector_tree_to_node_navigation|length > 0 %}index{% else %}node_index{% endif %}]), "r"(d_cache[{% if i|get_vector_tree_to_node_navigation|length > 0 %}index{% else %}node_index{% endif %}+1]));
	*d_cachepointers = d_cache[{% if i|get_vector_tree_to_node_navigation|length > 0 %}index{% else %}node_index{% endif %}+2];
}
{% endfor %}

// Cache pointers set functions.
inline __device__ void set_left_cache_pointer(shared_inttype *pointers, shared_indextype new_pointer) {
	asm("{\n\t"
		" bfi.u32 %0, %1, %0, 15, 15;\n\t"
		"}" : "+r"(*pointers) : "r"(new_pointer));
}

inline __device__ void set_right_cache_pointer(shared_inttype *pointers, shared_indextype new_pointer) {
	asm("{\n\t"
		" bfi.u32 %0, %1, %0, 0, 15;\n\t"
		"}" : "+r"(*pointers) : "r"(new_pointer));
}

// Cache pointers marking functions.
inline __device__ void mark_cache_pointers_new_leaf(shared_inttype *pointers) {
	*pointers = (*pointers & 0x3FFFFFFF) | 0x40000000;
}

inline __device__ void mark_cache_pointers_non_leaf(shared_inttype *pointers) {
	*pointers = *pointers & 0x3FFFFFFF;
}

inline __device__ bool cache_pointers_are_marked_new_leaf(shared_inttype pointers) {
	return (pointers >> 30 == 1);
}

inline __device__ void set_cache_pointers_to_global_address(shared_inttype *pointers, indextype address) {
	*pointers = address | 0x8FFFFFFF;
}

inline __device__ bool cache_pointers_contain_global_address(shared_inttype pointers) {
	return (pointers & 0x80000000) != 0;
}

// Vectornode reset functions.
inline __device__ void reset_left_in_vectortree_node(inttype *node) {
	asm("{\n\t"
		" bfi.u64 %0, 0, %0, 31, 31;\n\t"
		"}" : "+l"(*node));
}

inline __device__ void reset_right_in_vectortree_node(inttype *node) {
	asm("{\n\t"
		" bfi.u64 %0, 0, %0, 0, 31;\n\t"
		"}" : "+l"(*node));
}

// Vectornode set functions.
inline __device__ void set_left_in_vectortree_node(inttype *node, indextype address) {
	asm("{\n\t"
		" bfi.u64 %0, %1, %0, 31, 31;\n\t"
		"}" : "+l"(*node) : "r"(address));
}

inline __device__ void set_right_in_vectortree_node(inttype *node, indextype address) {
	asm("{\n\t"
		" bfi.u64 %0, %1, %0, 0, 31;\n\t"
		"}" : "+l"(*node) : "r"(address));
}

// Vectornode get functions.
inline __device__ indextype get_left_in_vectortree_node(inttype node) {
	indextype result;
	asm("{\n\t"
		" .reg .u64 t1;\n\t"
		" bfe.u64 t1, %1, %0, 31, 31;\n\t"
		" cvt.u32.u64 %0, t1;\n\t"
		"}" : "+r"(result) : "l"(node));
	return result;
}

inline __device__ void get_right_in_vectortree_node(inttype node) {
	indextype result;
	asm("{\n\t"
		" .reg .u64 t1;\n\t"
		" bfe.u64 t1, %1, %0, 0, 31;\n\t"
		" cvt.u32.u64 %0, t1;\n\t"
		"}" : "+r"(result) : "l"(node));
	return result;
}

// Vectornode check for a left or right pointer gap.
inline __device__ bool vectortree_node_contains_left_gap(inttype node) {
	return (node & 0x3FFFFFFF80000000 == 0x3FFFFFFF80000000);
}

inline __device__ bool vectortree_node_contains_right_gaps(inttype node) {
	return (node & 0x000000007FFFFFFF == 0x000000007FFFFFFF);
}

// *** END FUNCTIONS FOR VECTOR TREE NODES MANIPULATION AND STORAGE ***

// *** START KERNELS FOR VECTOR TREE NODES STORAGE AND RETRIEVAL ***

// Find or put a given vectortree node.
inline ___device_ indextype FINDORPUT_SINGLE(inttype *d_q, inttype *node, volatile bool *d_newstate_flags, bool claim_work) {
	indextype addr;
	inttype element;
	shared_inttype shared_addr;
	for (int i = 0; i < NR_HASH_FUNCTIONS, i++) {
		addr = HASHFUNCTION(i, *node);
		element = d_q[addr];
		if (element == EMPTYVECTNODE_GLOBAL) {
			element = atomicCAS(&(d_q[addr]), EMPTYVECTNODE_GLOBAL, *node);
			if (element == EMPTYVECTNODE_GLOBAL) {
				// Successfully stored the node.
				if (is_root(node)) {
					// Try to claim the vector for future work. For this, try to increment the OPENTILECOUNT counter.
					if (claim_work && (shared_addr = atomicAdd((inttype *) &OPENTILECOUNT, d_sv_nints)) < OPENTILELEN) {
						// Store pointer to root in the work tile.
						shared[OPENTILEOFFSET+shared_addr] = (shared_inttype) addr;
					}
					else {
						// There is work available for some block.
						d_newstate_flags[(addr / BLOCK_SIZE) % GRID_SIZE] = True;
					}
				}
				return addr;
			}
		}
		if (element == *node) {
			// The node is already stored.
			return addr;
		}
	}
	// Error: hash table considered full.
	return HASHTABLE_FULL;
}

// Find or put all new vectortree nodes stored in the shared memory cache into the global memory hash table.
__device__ bool FINDORPUT_MANY(shared_inttype *d_cache, inttype *d_q, volatile bool *d_newstate_flags) {
	inttype node;
	indextype = addr;
	{% if vectorsize > 63 %}
	shared_inttype node_pointers;
	shared_inttype node_pointers_child;
	bool work_to_do = False;

	if (THREAD_ID == 0) {
		CONTINUE = 1;
	}
	__syncthreads();
	if (THREAD_ID == 0) {
		CONTINUE = 0;
	}
	__syncthreads();
	for (shared_indextype i = THREAD_ID{% if vectorsize > 63 %}*3{% endif %}; i < d_shared_q_size; i += BLOCK_SIZE{% if vectorsize > 63 %}*3{% endif %}) {
		node_pointers = d_cache[i+2];
		// Check if node is ready for storage. Only new leafs are ready at this point. We rely on old and new non-leafs having pointers with the highest
		// two bits set to zero, empty entries and old leafs having pointers set to zero, and new leafs having pointers set to 0x40000000.
		if (cache_pointers_are_marked_new_leaf(node)) {
			asm("{\n\t"
			" mov.b64 %0,{ %1, %2 };\n\t"
			"}" : "=l"(node) : "r"(d_cache[i]), "r"(d_cache[i+1]));
			// Store node in hash table.
			addr = FINDORPUT_SINGLE(d_q, node, d_newstate_flags, True);
			// Store global memory address in cache.
			set_cache_pointers_to_global_address(&d_cache[i], addr);
		}
		// Node is not ready yet. Check if it can be updated.
		else if (node_pointers != 0) {
			if (head_is_new(d_cache[i])) {
				asm("{\n\t"
				" mov.b64 %0,{ %1, %2 };\n\t"
				"}" : "=l"(node) : "r"(d_cache[i]), "r"(d_cache[i+1]));
				if (vectortree_node_contains_left_gap(node)) {
					// Look up left child and check for presence of global memory address.
					node_pointers_child = sv_step(d_cache, i, False);
					node_pointers_child = d_cache[node_pointers_child+2];
					if (cache_pointers_contain_global_address(node_pointers_child)) {
						set_left_in_vectortree_node(&node, node_pointers_child);
						// Copy back to shared memory.
						d_cache[i] = get_left(node);
						d_cache[i+1] = get_right[node];
					}
				}
				if (vectortree_node_contains_right_gap(node)) {
					// Look up right child and check for presence of global memory address.
					node_pointers_child = sv_step(d_cache, i, True);
					node_pointers_child = d_cache[node_pointers_child+2];
					if (cache_pointers_contain_global_address(node_pointers_child)) {
						set_right_in_vectortree_node(&node, node_pointers_child);
						// Copy back to shared memory.
						d_cache[i] = get_left(node);
						d_cache[i+1] = get_right[node];
					}
				}
				// Ready now?
				if (!vectortree_node_contains_left_gap(node) && !vectortree_node_contains_right_gap(node)) {
					// Possibly reset new bit.
					if (!is_root(node)) {
						node = mark_old(node);
					}
					// Store node in hash table.
					addr = FINDORPUT_SINGLE(d_q, node);
					// Store global memory address in d_cache.
					set_d_cache_pointers_to_global_address(&d_cache[i], addr);							
				}
				else {
					work_to_do = True;
					CONTINUE = 1;
				}
			}
		}
	}
	__syncthreads();
	while (CONTINUE == 1) {
		if (THREAD_ID == 0) {
			CONTINUE = 0;
		}
		__syncthreads();
		if (work_to_do) {
			work_to_do = False;
			for (shared_indextype i = THREAD_ID*3; i < d_shared_q_size; i += BLOCK_SIZE*3) {
				node_pointers_child = d_cache[i];
				// If the node is marked new, this is a node still to be processed.
				if (head_is_new(node_pointers_child)) {
					node_pointers = d_cache[i+2];
					// If this is a root node, processing is only required if the pointers do not contain a global address.
					if (!head_is_root(node_pointers_child) || !cache_pointers_contain_global_address(node_pointers)) {
						asm("{\n\t"
						" mov.b64 %0,{ %1, %2 };\n\t"
						"}" : "=l"(node) : "r"(d_cache[i]), "r"(d_cache[i+1]));
						if (vectortree_node_contains_left_gap(node)) {
							// Look up left child and check for presence of global memory address.
							node_pointers_child = sv_step(d_cache, i, False);
							node_pointers_child = d_cache[node_pointers_child+2];
							if (cache_pointers_contain_global_address(node_pointers_child)) {
								set_left_in_vectortree_node(&node, node_pointers_child);
								// Copy back to shared memory.
								d_cache[i] = get_left(node);
								d_cache[i+1] = get_right[node];
							}
						}
						if (vectortree_node_contains_right_gap(node)) {
							// Look up right child and check for presence of global memory address.
							node_pointers_child = sv_step(d_cache, i, True);
							node_pointers_child = d_cache[node_pointers_child+2];
							if (cache_pointers_contain_global_address(node_pointers_child)) {
								set_right_in_vectortree_node(&node, node_pointers_child);
								// Copy back to shared memory.
								d_cache[i] = get_left(node);
								d_cache[i+1] = get_right[node];
							}
						}
						// Ready now?
						if (!vectortree_node_contains_left_gap(node) && !vectortree_node_contains_right_gap(node)) {
							// Possibly reset new bit.
							if (!is_root(node)) {
								node = mark_old(node);
							}
							// Store node in hash table.
							addr = FINDORPUT_SINGLE(d_q, node);
							// Store global memory address in d_cache.
							set_d_cache_pointers_to_global_address(&d_cache[i], addr);
						}
						else {
							work_to_do = True;
							CONTINUE = 1;
						}
					}
				}
			}
		}
		__syncthreads();
	}
	{% else %}
	for (shared_indextype i = THREAD_ID; i < d_shared_q_size; i += BLOCK_SIZE) {
		node = d_cache[i];
		if is_new(node) {
			addr = FINDORPUT_SINGLE(d_q, node);
		}
	}
	{% endif %}
}

// Retrieve a vectortree from the global hash table and store it in the cache. This is performed in a warp-centric way.
// Address addr points to the root of the requested vectortree.
inline __device__ void FETCH(thread_group treegroup, shared_inttype *cache, inttype *d_q, indextype addr) {
	inttype node, leaf_node;
	indextype node_addr_left = 0;
	indextype node_addr_right = 0;
	indextype node_addr_non_leaf = 0;
	indextype node_addr_leaf = 0;
	shared_inttype cache_pointers;
	shared_indextype cache_addr;
	
	if (treegroup.thread_rank() == 0) {
		node_addr_non_leaf = addr;
		node = d_q[node_addr_non_leaf];
		node_addr_left = get_left_in_vectortree_node(node);
		node_addr_right = get_right_in_vectortree_node(node);
	}
	{% for i in range(1,vectortree_depth)|reverse %}
	{% set first_level_id = (2**i)-1 %}
	{% set prev_level_size = 2**(vectortree_depth-i-1) %}
	// Communicate left child pointer.
	treegroup.shfl_up(node_addr_left, (treegroup.thread_rank()/2)+{{prev_level_size}});
	// If no address has been stored before, an address has been received, and the thread id is odd, store the new address.
	{% if i != 1 %}
	if (node_addr_non_leaf == 0 && node_addr_left != 0 && treegroup.thread_rank() % 2 == 1) {
		node_addr_non_leaf = node_addr_left;
	}
	{% else %}
	if (node_addr_leaf == 0 && node_addr_left != 0 && treegroup.thread_rank() % 2 == 1) {
		node_addr_leaf = node_addr_left;
	}
	{% endif %}
	else {
		node_addr_left = 0;
	}
	// Communicate right child pointer.
	treegroup.shfl_up(node_addr_right, ((treegroup.thread_rank()+1)/2)+{{prev_level_size}});
	{% if i != 1 %}
	if (node_addr_non_leaf == 0 && node_addr_right != 0 && treegroup.thread_rank() % 2 == 0) {
		node_addr_non_leaf = node_addr_right;
	}
	{% else %}
	if (node_addr_leaf == 0 && node_addr_right != 0 && treegroup.thread_rank() % 2 == 1) {
		node_addr_leaf = node_addr_right;
	}
	{% endif %}
	else {
		node_addr_right = 0;
	}
	{% if i != 1 %}
	// Obtain non-leaf node.
	if (node_addr_non_leaf != 0) {
		node = d_q[node_addr_non_leaf];
		node_addr_left = get_left_in_vectortree_node(node);
		node_addr_right = get_right_in_vectortree_node(node);
	}
	{% else %}
	// Obtain leaf node and store it in the cache.
	if (node_addr_leaf != 0) {
		leaf_node = d_q[node_addr_leaf];
		cache_addr = STOREINCACHE(cache, leaf_node, 0);
	}
	{% endif %}
	{% endfor %}
}

// *** END KERNELS FOR VECTOR TREE NODES STORAGE AND RETRIEVAL ***

// Data retrieval functions. Retrieve particular state info from the given state vector part(s).
// Precondition: the given parts indeed contain the requested info.
{% for s in vectorelem_in_structure_map.keys() %}
{% set size = vectorelem_in_structure_map[s][0] %}
inline __device__ void get_{{s|replace("[","_")|replace("]","")|replace("'","_")}}({% if s|is_state %}elem_statetype{% elif size < 32 %}elem_chartype{% else %}elem_inttype{% endif %} *b, inttype part1, inttype part2) {
	asm("{\n\t"
{% if size < 32 %}
		" .reg .u32 t1;\n\t"
{% if vectorelem_in_structure_map[s]|length == 2 %}
		" bfe.u32 t1, %1, {{vectorelem_in_structure_map[s][1][1]}}, {{vectorelem_in_structure_map[s][1][2]}};\n\t"
{% else %}
		" bfe.u32 t1, %2, {{vectorelem_in_structure_map[s][2][1]}}, {{vectorelem_in_structure_map[s][2][2]}};\n\t"
		" bfi.b32 t1, %1, t1, {{vectorelem_in_structure_map[s][2][2]}}, {{vectorelem_in_structure_map[s][1][2]}};\n\t"
{% endif %}
		" cvt.s8.u32 %0, t1;\n\t"
	    "}" : "=r"(*b) : "l"(part1), "l"(part2));
{% else %}
{% if vectorelem_in_structure_map[s]|length == 2 %}
		" bfe.s32 %0, %1, {{vectorelem_in_structure_map[s][1][1]}}, {{vectorelem_in_structure_map[s][1][2]}};\n\t"
	    "}" : "=r"(*b) : "l"(part1), "l"(part2));
{% else %}
		" bfe.s32 %0, %2, {{vectorelem_in_structure_map[s][2][1]}}, {{vectorelem_in_structure_map[s][2][2]}};\n\t"
		" bfi.b32 %0, %1, %0, {{vectorelem_in_structure_map[s][2][2]}}, {{vectorelem_in_structure_map[s][1][2]}};\n\t"
	    "}" : "+r"(*b) : "l"(part1), "l"(part2));
{% endif %}
{% endif %}
}

{% endfor %}
{% if arraynames|length > 0 %}
// Data retrieval functions, including the fetching of required vector parts, for array elements with dynamic indexing.
{% for vname, t, size in arraynames %}
inline __device__ void get_{{vname|replace("[","_")|replace("]","")}}(inttype *d_cache, shared_indextype node_index, {% if t|gettypesize < 32 %}elem_chartype{% else %}elem_inttype{% endif %} *b, array_indextype index) {
	inttype part1, part2;
	switch (index) {
		{% for i in range(0, size) %}
		case {{i}}:
			// Retrieve correct vector part(s).
			{% set PIDs = vectorelem_in_structure_map[vname + "[" + i|string + "]"] %}
			part1 = get_vectorpart_{{PIDs[1][0]}}(d_cache, node_index);
			{% if PIDs|length > 2 %}
			part2 = get_vectorpart_{{PIDs[2][0]}}(d_cache, node_index);
			{% endif %}
			// Get the data.
			get_{{vname|replace("[","_")|replace("]","") + "_" + i|string}}(b, part1, part2);
			break;
		{% endfor %}
		default:
			break;
	}
}

{% endfor %}
{% endif %}
// Retrieval of current state of automaton at position i in state vector.
inline __device__ void get_current_state(statetype *b, inttype *d_cache, shared_indextype node_index, elem_chartype i) {
	inttype part1, part2;
	switch (i) {
		{% for i in range(0,smnames|length) %}
		case {{i}}:
			{% set vinfo = vectorelem_in_structure_map[state_order[i]] %}
			part1 = get_vectorpart_{{vinfo[1][0]}}(d_cache, node_index);
			{% if vinfo|length > 2 %}
			part2 = get_vectorpart_{{vinfo[2][0]}}(d_cache, node_index);
			{% endif %}
			get_{{state_order[i]}}(b, part1, part2);
		{% endfor %}
		default:
			break;
	}
}

// Data update functions. Update particular state info in the given state vector part(s).
// Precondition: the given part indeed needs to contain the indicated fragment (left or right in case the info is split over two parts) of the updated info.
{% for s in vectorelem_in_structure_map.keys() %}
{% set size = vectorelem_in_structure_map[s][0] %}
inline __device__ void set_left_{{s|replace("[","_")|replace("]","")|replace("'","_")}}(inttype *part, {% if size < 32 %}elem_chartype{% else %}elem_inttype{% endif %} x) {
	asm("{\n\t"
		" .reg .u64 t1;\n\t"
{% if size < 32 %}
		" cvt.u64.u8 t1, %1\n\t"
{% else %}
		" cvt.u64.u32 t1, %1\n\t"
{% endif %}
{% if vectorelem_in_structure_map[s]|length > 2 %}
		" shr.b64 t1, t1, {{vectorelem_in_structure_map[s][2][2]}};\n\t"
{% endif %}
		" bfi.b64 %0, t1, %0, {{vectorelem_in_structure_map[s][1][1]}}, {{vectorelem_in_structure_map[s][1][2]}};\n\t"
		"}" : "+l"(*part) : "r"(x);
}

{% if vectorelem_in_structure_map[s]|length > 2 %}
inline __device__ void set_right_{{s|replace("[","_")|replace("]","")|replace("'","_")}}(inttype *part, {% if size < 32 %}elem_chartype{% else %}elem_inttype{% endif %} x) {
	asm("{\n\t"
		" .reg .u64 t1;\n\t"
{% if size < 32 %}
		" cvt.u64.u8 t1, %1\n\t"
{% else %}
		" cvt.u64.u32 t1, %1\n\t"
{% endif %}
		" bfi.b64 %0, t1, %0, {{vectorelem_in_structure_map[s][2][1]}}, {{vectorelem_in_structure_map[s][2][2]}};\n\t"
		"}" : "+l"(*part) : "r"(x);
}

{% endif %}
{% endfor %}
// Data update functions for arrays with dynamic indexing, focussed on one specific vector part.
{% for x in dynamic_write_arrays.keys() %}
// Auxiliary functions for {{dynamic_write_arrays[x][0]}}.
inline __device__ bool array_element_is_in_vectorpart_{{dynamic_write_arrays[x][0]|replace("'","_")}}(array_indextype i, vectornode_indextype pid) {
	switch (pid) {
		{% for p in range(dynamic_write_arrays[x][1], dynamic_write_arrays[x][2]+1) %}
		case {{p}}:
			return (i >= {{(x|get_array_range_in_vectorpart(dynamic_write_arrays[x][0],p))[0]}} && i <= {{(x|get_array_range_in_vectorpart(dynamic_write_arrays[x][0],p))[1]}});
		{% endfor %}
		default:
			return False;
	}
}

// Precondition: array element i is (partially) stored in vector part pid.
inline __device__ bool is_left_vectorpart_for_array_element_{{dynamic_write_arrays[x][0]|replace("'","_")}}(array_indextype i, vectornode_indextype pid) {
	switch (pid) {
		{% for p in range(dynamic_write_arrays[x][1], dynamic_write_arrays[x][2]+1) %}
		case {{p}}:
			return (i >{% if loop.first %}= 0{% else %} {{(x|get_array_range_in_vectorpart(dynamic_write_arrays[x][0],p-1))[1]}}{% endif %} && i <= {{(x|get_array_range_in_vectorpart(dynamic_write_arrays[x][0],p))[1]}});
		{% endfor %}
		default:
			return False;
	}	
}

// Data update function for {{dynamic_write_arrays[x][0]}}.
inline __device__ inttype set_{{dynamic_write_arrays[x][0]|replace("'","_")}}(inttype *part, array_indextype indices, {{x.type|cudatype(True)}} buf, buffer_indextype buf_offset, vectornode_indextype part_id) {
	if (part_id >= {{dynamic_write_arrays[x][1]}} && part_id <= {{dynamic_write_arrays[x][2]}}) {
		for (array_indextype i = 0;; i++) {
			if (indices[i] == EMPTY_INDEX) {
				break;
			}
			if (array_element_is_in_vectorpart_{{dynamic_write_arrays[x][0]|replace("'","_")}}(indices[i], part_id)) {
				if (is_left_vectorpart_for_array_element_{{dynamic_write_arrays[x][0]|replace("'","_")}}(indices[i], part_id)) {
					switch (indices[i]) {
						{% for i in range(dynamic_write_arrays[x][1], dynamic_write_arrays[x][2]+1) %}
						case {{i}}:
							set_left_{{dynamic_write_arrays[x][0]|replace("'","_")}}_{{i}}(part, buf[buf_offset + i]);
							break;
						{% endfor %}
						default:
							break;
					}
				}
				else {
					switch (indices[i]) {
						{% for i in range(dynamic_write_arrays[x][1], dynamic_write_arrays[x][2]+1) %}
						{% if vectorelem_in_structure_map[dynamic_write_arrays[x][0] + "[" + i|string + "]"]|length > 2 %}
						case {{i}}:
							set_right_{{dynamic_write_arrays[x][0]|replace("'","_")}}_{{i}}(part, buf[buf_offset + i]);
							break;
						{% endif %}
						{% endfor %}
						default:
							break;
					}
				}
			}
		}
	}
}
{% endfor %}

// Data update functions for channel buffers, focussed on one specific vector part.
{% for c in model.channels|select("is_async") %}
// Data update function for parameter i of tail element of the buffer of {{c.name}}.
{% for i in range(0,c.type|length+1) %}
{% if i > 0 or signalsize[c] > 0 %}
inline __device__ void set_buffer_tail_element_{{c.name}}_{{i}}(inttype *part, buffer_indextype size, {% if i == 0 %}{% if signalsize[c] <= 8 %}uint8_t{% elif signalsize[c] <= 16 %}uint16_t{% else %}uint32_t{% endif %}{% else %}{{(c.type[i-1])|cudatype(True)}}{% endif %} value, vectornode_indextype part_id) {
	switch (size) {
		{% for n in range(0,c.size) %}
		case {{n}}:
			switch (part_id) {
				{% set PIDs = vectorelem_in_structure_map.get(c.name + "[" + i|string + "][" + n|string + "]") %}
				{% if PIDs != None %}
				case {{PIDs[1][0]}}:
					set_left_{{c.name}}_{{i}}_{{n}}(part, value);
					break;
				{% if PIDs|length > 2 %}
				case {{PIDs[2][0]}}:
					set_right_{{c.name}}_{{i}}_{{n}}(part, value);
					break;
				{% endif %}
				{% endif %}
				default:
					break;
			}
		{% endfor %}
		default:
			break;
	}
}

{% endif %}
{% endfor %}
// Data update function shifting each element of the buffer of {{c.name}} one position towards the head, insofar this is relevant for the given vectorpart.
inline __device__ void shift_buffer_tail_elements_{{c.name}}(inttype *d_cache, shared_indextype node_index, shared_inttype *part, buffer_indextype size, vectornode_indextype part_id) {
	{% if c.size > 1 %}
	inttype part_tmp;
	{% if signalsize[c] > 0 %}
	{% if signalsize <= 2 %}
	bool signal_tmp;
	{% elif signalsize <= 8 %}
	uint8_t signal_tmp;
	{% elif signalsize <= 16 %}
	uint16_t signal_tmp;
	{% elif signalsize <= 32 %}
	uint32_t signal_tmp;
	{% endif %}
	{% endif %}
	{% for t in c.type %}
	{% if t.base == 'Integer' %}
	elem_inttype int_tmp;{{break}}
	{% endif %}
	{% endfor %}
	{% for t in c.type %}
	{% if t.base == 'Byte' %}
	elem_chartype char_tmp;{{break}}
	{% endif %}
	{% endfor %}
	{% for t in c.type %}
	{% if t.base == 'Boolean' %}
	elem_booltype bool_tmp;{{break}}
	{% endif %}
	{% endfor %}

	switch (part_id) {
		{% set parts = async_channel_vectorpart_buffer_range[c] %}
		{% for p in parts.keys() %}
		case {{p}}:
			{% if parts.get(p+1) != None %}
			part_tmp = get_vectorpart(d_cache, node_index, part_id+1);
			{% endif %}
			{% set lower1 = parts[p][0][0] %}
			{% set lower2 = parts[p][0][1] %}
			{% set upper1 = parts[p][1][0] %}
			{% set upper2 = parts[p][1][1] %}
			{% for i in range(0,c.size) %}
			{% for j in range(0,c.type|length+1) %}
			{% if (lower2 < i or (lower2 == i and lower1 <= j)) and (upper2 > i or (upper2 == i and upper1 >= j)) and c|next_buffer_element(j,i) != (-1,-1) and (j > 0 or signalsize[c] > 0) %}
			if ({{i+1}} < size) {
			{% set (nj,ni) = c|next_buffer_element(j,i) %}
			{% if upper2 > ni or (upper2 == ni and upper1 >= nj) %}
				get_{{c.name}}_{{nj}}_{{ni}}(&{% if nj == 0 %}signal_tmp{% else %}{% if c.type[nj-1].base == 'Integer' %}int_tmp{% elif c.type[nj-1].base == 'Byte' %}char_tmp{% else %}bool_tmp{% endif %}{% endif %}, *part, part_tmp);
			{% else %}
				get_{{c.name}}_{{nj}}_{{ni}}(&{% if nj == 0 %}signal_tmp{% else %}{% if c.type[nj-1].base == 'Integer' %}int_tmp{% elif c.type[nj-1].base == 'Byte' %}char_tmp{% else %}bool_tmp{% endif %}{% endif %}, part_tmp, *part);
			{% endif %}
			{% set PIDs = vectorelem_in_structure_map[c.name + "[" + j|string + "][" + i|string + "]"] %}
			{% if PIDs[1][0] == p %}
				set_left_{{c.name}}_{{j}}_{{i}}(part, {% if nj == 0 %}signal_tmp{% else %}{% if c.type[nj-1].base == 'Integer' %}int_tmp{% elif c.type[nj-1].base == 'Byte' %}char_tmp{% else %}bool_tmp{% endif %}{% endif %});
			{% else %}
				set_right_{{c.name}}_{{j}}_{{i}}(part, {% if nj == 0 %}signal_tmp{% else %}{% if c.type[nj-1].base == 'Integer' %}int_tmp{% elif c.type[nj-1].base == 'Byte' %}char_tmp{% else %}bool_tmp{% endif %}{% endif %});
			{% endif %}
			}
			else {
				set_left_{{c.name}}_{{j}}_{{i}}(part, 0);
				break;
			}
			{% endif %}
			{% endfor %}
			{% endfor %}
			break;
		{% endfor %}
		default:
			break;
	}
	{% else %}
	return;
	{% endif %}
}

{% endfor %}
// Auxiliary functions to check for and obtain offset for given array index in the appropriate buffer. The given array of indices is scanned to retrieve the offset.
// Check for presence of offset. If not present, store the index, and return position. if present, return -1.
// This function is used for the retrieval of array elements.
inline __device__ buffer_indextype add_idx(array_indextype *indices, array_indextype index) {
	for (buffer_indextype i = 0;; i++) {
		if (indices[i] == index) {
			return -1;
		}
		elif (indices[i] == EMPTY_INDEX) {
			indices[i] = index;
			return i;
		}
	}
	return -1;
}

// Check for index and return position in indices array. This function is used for processing statements.
// Precondition: provided array contains the requested element.
inline __device__ buffer_indextype idx(array_indextype *indices, array_indextype index) {
	for (buffer_indextype i = 0;; i++) {
		if (indices[i] == index) {
			return i;
		}
		elif (indices[i] == EMPTY_INDEX) {
			return i;
		}
	}
	return -1;
}

{% for c in model.classes %}
{% set cloop = loop %}
{% for sm in c.statemachines %}
{% set smloop = loop %}
{% for a in alphabet[sm] if a in syncactions %}
{% if cloop.first and smloop.first and loop.first %}
// Action execution functions. For each state machine and action requiring synchronisation, there is a function returning for a given
// source state a target state that can be reached by performing the action. In case of non-determinism, repeated calls of the function
// will produce each of the different reachable states.
{% endif %}
inline __device__ statetype get_target_{{sm.name}}_{{a}}(statetype src, statetype prev_tgt) {
	switch (src) {
		{% set atrans = actiontargets[sm][a] %}
		{% for src, tgts in atrans|dictsort %}
		case {{src}}:
			switch (prev_tgt) {
				{% for j in range(0, tgts|length+1) %}
				{% if j == 0 %}
				case -1:
				{% else %}
				case {{tgts[j-1]}}:
				{% endif %}
					{% if j == tgts|length %}
					return -1;
					{% else %}
					return {{tgts[j]}};
					{% endif %}
				{% endfor %}
				default:
					return -1;
			}
		{% endfor %}
		default:
			return -1;
	}
}

{% endfor %}
{% endfor %}
{% endfor %}
{% for ch in model.channels if ch.synctype == 'sync' %}
{% set chloop = loop %}
{% for (o2,sm2,signal) in ch|get_all_syncrecs %}
{% if chloop.first and loop.first %}
// Synchronous message receive functions. For each (object, statemachine) pair, synchronous channel, and message signal, there is a
// function returning for a given source state a target state that can be reached by receiving a message with that signal over that
// channel. in case of non-determinism, repeated calls of the function will produce each of the different reachable states.
{% endif %}
inline __device__ statetype get_target_{{o2.name}}_{{sm2.name}}_{{signal}}(statetype src, statetype prev_tgt) {
	switch (src) {
		{% set trans = o2|get_reccomm_trans(sm2,ch,signal) %}
		{% for s2 in trans.keys()|sort %}
		case {{s2}}:
			switch (prev_tgt) {
				{% set strans = trans[s2] %}
				{% for j in range(0, strans|length) %}
				{% if j == 0 %}
				case -1:
				{% else %}
				case {{strans[j-1]}}:
				{% endif %}
					{% if j == strans|length %}
					return -1;
					{% else %}
					return {{strans[j]}};
					{% endif %}
				{% endfor %}
				default:
					return -1;
			}
		{% endfor %}
		default:
			return -1;
	}
}

{% endfor %}
{% endfor %}
// Successor function. Given a state vector, construct its successor state vectors, and store them in d_cache.
// Vgtid is the identity of the thread calling the function (id of thread inside vector group).
inline __device__ void successor(inttype *d_cache, shared_indextype node_index, uint8_t vgtid) {
	// explore the outgoing transitions of the current state of the automaton assigned to vgtid.
	switch (vgtid) {
		{% for i in range(0,smnames|length) %}
		case {{i}}:
			explore_{{state_order[i]|replace("'","_")}}(d_cache, node_index);
			break;
		{% endfor %}
		default:
			break;
	}
}

// Exploration functions to traverse outgoing transitions of the various states.
{% for i in range(0,smnames|length) %}
inline __device__ void explore_{{state_order[i]|replace("'","_")}}(inttype *d_cache, shared_indextype node_index) {
	// Fetch the current state of the state machine.
	statetype current = get_current_state(d_cache, node_index, {{i}});
	statetype target = NO_STATE;
	inttype part1, part2;
	shared_inttype part_d_cachepointers;
	switch (current) {
		{% for s in smname_to_object[state_order[i]][1].states %}
		{% set o = smname_to_object[state_order[i]][0] %}
		{% set sm = smname_to_object[state_order[i]][1] %}
		{% if s|nr_of_transitions_to_be_processed_by(i,o) %}
		case {{state_id[(sm,s)]}}:
			{% set indent = "" %}
			{% set allocs = s|get_buffer_allocs(o) %}
			{% if allocs[0] + allocs[1] + allocs[2] + allocs[3] > 0 %}
			// Allocate register memory to process transition(s).
			{% endif %}
			{% if allocs[0] > 0 %}
			elem_inttype buf32[{{allocs[0]}}];
			{% endif %}
			{% if allocs[1] > 0 %}
			uint16_t buf16[{{allocs[1]}}];
			{% endif %}
			{% if allocs[2] > 0 %}
			elem_chartype buf8[{{allocs[2]}}];
			{% endif %}
			{% if allocs[3] > 0 %}
			bool buf1[{{allocs[3]}}];
			{% endif %}
			{% set allocs = s|get_buffer_arrayindex_allocs(o) %}
			{% if allocs|length > 0 %}
			// Allocate register memory for dynamic array indexing.
			{% for v in allocs.keys() %}
			array_indextype idx_{{v.name}}[{{allocs[v]}}];
			{% endfor %}
			{% endif %}
			{% set ns = namespace(lastprio=100, prio_nestings=0) %}
			{% for t in s|outgoingtrans(sm.transitions) %}
			{% if t|must_be_processed_by(i,o) %}
			{% if t.priority > ns.lastprio %}
			if (target == NO_STATE) {
			{% set ns.prio_nestings = ns.prio_nestings + 1 %}
			{% set indent = indent + "\t" %}
			{% endif %}
			{% set ns.lastprio = t.priority %}
			{% set st = t.statements[0] %}
			
			{{indent}}// {{s.name}} --{ {{st|getlabel}} }--> {{t.target.name}}
			
			{% set M = t|map_variables_on_buffer(o) %}
			{% set fetched = [-1,-1] %}
			{% if st.__class__.__name__ == 'ReceiveSignal' %}
			{% if st|cudarecsizeguard(M,o) != "" %}
			{{indent}}// Fetch buffer size value.
			{% set ch = connected_channel[(o, st.target)] %}
			{% set VP = [(ch,"_size")]|get_vectorparts(o) %}
			{% set fetched = VP %}
			{{indent}}part1 = get_vectorpart(d_cache, node_index, {{VP[0]}});
			{% if VP|length > 1 %}
			{{indent}}part2 = get_vectorpart(d_cache, node_index, {{VP[1]}});
			{% endif %}
			{{indent}}get_{{ch.name}}_size(&{{M[(ch,"_size")][0]}}[{{M[(ch,"_size")][1]}}], part1, part2);
			{{indent}}if ({{st|cudarecsizeguard(M,o)}}) {
			{% set indent = indent + "\t" %}
			{% endif %}
			{% endif %}
			{% for v in st|statement_varrefs(o,sm)|get_vars if v|has_dynamic_indexing(t,o) %}
			{% if loop.first %}
			{{indent}}// Reset storage of array indices.
			{% endif %}
			for (array_indextype i = 0; i < {{allocs[v]}}; i++) {
				idx_{{v.name}}[i] = EMPTY_INDEX;
			}
			{% endfor %}
			{% set VP = t|transition_read_varrefs(o,True)|select("no_dynamic_indexing",o)|get_vectorparts(o) %}
			{% if VP|length > 0 %}
			{{indent}}// Fetch values of unguarded variables.
			{% endif %}
			{% for i in range(0,VP|length) %}
			{% set VPloop = loop %}
			{% if loop.first %}
			{% if VP[i] != fetched[0] and VP[i] != fetched[1] %}
			{% set fetched = [VP[i],fetched[1]] %}
			{{indent}}part1 = get_vectorpart(d_cache, node_index, {{VP[i]}});
			{% elif VP[i] == fetched[1] %}
			{% set fetched = [fetched[1],fetched[1]] %}
			{{indent}}part1 = part2;
			{% endif %}
			{% endif %}
			{% for (v,j) in t|transition_read_varrefs(o,False)|select("no_dynamic_indexing",o) if vectorelem_in_structure_map[v|scopename(j,o)][1][0] == VP[i] and (vectorelem_in_structure_map[v|scopename(j,o)]|length == 2 or vectorelem_in_structure_map[v|scopename(j,o)][vectorelem_in_structure_map[v|scopename(j,o)]|length-1][0] == VP[i+1]) %}
			{% if (not VPloop.first) and loop.first %}
			{{indent}}part1 = part2;
			{% endif %}
			{% if i+1 < VP|length %}
			{% if VP[i+1] != fetched[0] and VP[i+1] != fetched[1] %}
			{% set fetched = [fetched[0],VP[i+1]] %}
			{{indent}}part2 = get_vectorpart(d_cache, node_index, {{VP[i+1]}});
			{% elif VP[i+1] == fetched[0] %}
			{% set fetched = [fetched[0],fetched[0]] %}
			{{indent}}part2 = part1;
			{% endif %}
			{% endif %}
			{% if v.__class__.__name__ != "Channel" and v.__class__.__name__ != "StateMachine" %}
			{{indent}}get_{{v|scopename(None,o)|replace("'","_")}}{% if j != None %}_{{j|getinstruction(o,{},{})}}{% endif %}(&{{M[v][0]}}[{{M[v][1]}}{% if j != None %} + {{j|getinstruction(o,{},{})}}{% endif %}], part1, part2);
			{% else %}
			{{indent}}get_{{v|scopename(j,o)|replace("[","_")|replace("]","")|replace("'","_")}}(&{{M[(v,j)][0]}}[{{M[(v,j)][1]}}], part1, part2);
			{% endif %}
			{% if v|has_dynamic_indexing(t,o) %}
			{{indent}}// Store array index.
			{{indent}}add_idx(idx_{{v.name}}, {{j|getinstruction(o,{},{})}});
			{% endif %}
			{% endfor %}
			{% endfor %}
			{% for (v,j) in t|transition_sorted_dynamic_read_varrefs(o,True) %}
			{% if loop.first %}
			{{indent}}// Fetch values of unguarded variables involving dynamic array indexing.
			{% endif %}
			{{indent}}// Check for presence of index in buffer indices.
			{{indent}}buffer_indextype i = add_idx(idx_{{v.name}}, {{j|getinstruction(o,M,{})}});
			{{indent}}if (i != -1) {
			{{indent}}	// Fetch value.
			{{indent}}	get_{{v|scopename(None,o)}}(d_cache, node_index, &buf{{v.type|gettypesize}}[{{M[v][1]}}+i], {{j|getinstruction(o,M,{}),{}}});
			{{indent}}}
			{% endfor %}
			{{indent}}// Statement computation.
			{% if st|cudaguard(M,o) != "" %}
			{{indent}}if ({{st|cudaguard(M,o)}}) {
			{% set indent = indent + "\t" %}
			{% endif %}
			{% set VPrem = t|transition_read_varrefs(o,False)|select("no_dynamic_indexing",o)|get_remaining_vectorparts(o,VPs) %}
			{% for i in range(0,VPrem|length) %}
			{% set VPremloop = loop %}
			{% for (v,j) in t|transition_read_varrefs(o,False)|select("no_dynamic_indexing",o)|select("vectorparts_not_covered", o, VP) if vectorelem_in_structure_map[v|scopename(j,o)][1][0] == VPrem[i] and (vectorelem_in_structure_map[v|scopename(j,o)]|length == 2 or vectorelem_in_structure_map[v|scopename(j,o)][vectorelem_in_structure_map[v|scopename(j,o)]|length-1][0] == VPrem[i+1]) %}
			{% if VPremloop.first and loop.first %}
			{{indent}}// Fetch remaining values of unguarded variables (without dynamic array indexing).
			{% if VPrem[i] != fetched[0] and VPrem[i] != fetched[1] %}
			{% set fetched = [VPrem[i],fetched[1]] %}
			{{indent}}part1 = get_vectorpart(d_cache, node_index, {{VPrem[i]}});
			{% elif VPrem[i] == fetched[1] %}
			{% set fetched = [fetched[1],fetched[1]] %}
			{{indent}}part1 = part2;
			{% endif %}
			{% endif %}
			{% if (not VPremloop.first) and loop.first %}
			{{indent}}part1 = part2;
			{% endif %}
			{% if i+1 < VPrem|length %}
			{% if VPrem[i+1] != fetched[0] and VPrem[i+1] != fetched[1] %}
			{% set fetched = [fetched[0],VPrem[i+1]] %}
			{{indent}}part2 = get_vectorpart(d_cache, node_index, {{VPrem[i+1]}});
			{% elif VPrem[i+1] == fetched[0] %}
			{% set fetched = [fetched[1],fetched[1]] %}
			{{indent}}part2 = part1;
			{% endif %}
			{% endif %}
			{{indent}}get_{{v|scopename(None,o)}}{% if j != None %}_{{j|getinstruction(o,{},{})}}{% endif %}(&{{M[v][0]}}[{{M[v][1]}}{% if j != None %} + {{j|getinstruction(o,{},{})}}{% endif %}], part1, part2);
			{% if v|has_dynamic_indexing(t,o) %}
			{{indent}}// Store array index
			{{indent}}add_idx(idx_{{v.name}}, {{j|getinstruction(o,{},{})}});
			{% endif %}
			{% endfor %}
			{% endfor %}
			{% for (v,j) in t|transition_sorted_dynamic_read_varrefs(o,False) %}
			{% if loop.first %}
			{{indent}}// Fetch remaining values of unguarded variables involving dynamic array indexing.
			{% endif %}
			{{indent}}// check for presence of index in buffer indices.
			{{indent}}buffer_indextype i = add_idx(idx_{{v.name}}, {{j|getinstruction(o,M,{})}});
			{{indent}}if (i != -1) {
			{{indent}}	// Fetch value.
			{{indent}}	get_{{v|scopename(None,o)}}(d_cache, node_index, &buf{{v.type|gettypesize}}[{{M[v][1]}}+i], {{j|getinstruction(o,M,{})}});
			{{indent}}}
			{% endfor %}
			{{indent}}// Set target state.
			{{indent}}target = {{state_id[(sm,t.target)]}};
			{% if st|cudastatement(1,o,M) != "" %}
			{{indent}}{{st|cudastatement(indent|length+3,o,M)}}{% endif %}
			{% if st|cudaguard(M,o) != "" %}
			{% set indent = indent[:-1] %}
			{{indentxzzxxxxxccvv}}}
			{% endif %}
			{% if st.__class__.__name__ == "ReceiveSignal" %}
			{% if st|cudarecsizeguard(M,o) != "" %}
			}
			{% endif %}
			{% endif %}
			{% endif %}
			{% for j in range(0, ns.prio_nestings) %}
			{% set indent = indent[:-1] %}
			{{indent}}}
			{% endfor %}
			{% endfor %}
			break;
		{% endif %}
		{% endfor %}
		default:
			break;
	}
}

{% endfor %}