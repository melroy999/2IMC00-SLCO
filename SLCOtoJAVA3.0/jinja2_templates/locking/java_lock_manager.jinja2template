// Lock class to handle locks of global variables
private static class LockManager {
    // The locks
    private final ReentrantLock[] locks;

    LockManager(int noVariables) {
        locks = new ReentrantLock[noVariables];
        for(int i = 0; i < locks.length; i++) {
            locks[i] = new ReentrantLock();
        }
    }

    // Lock method
    {% if settings.priority_queue_locking %}
    void lock(PriorityQueue{{ "<Integer>" }} queue) {
        for (int i = 0; i < end; i++) {
            locks[lock_ids[i]].lock();
        }
    }
    {% else %}
    void lock(int[] lock_ids, int start, int end) {
        Arrays.sort(lock_ids, start, end);
        for (int i = start; i < end; i++) {
            locks[lock_ids[i]].lock();
        }
    }
    {% endif %}

    // Unlock method
    {% if settings.priority_queue_locking %}
    void unlock(Queue{{ "<Integer>" }} queue) {
        while(!queue.isEmpty()) {
            locks[queue.poll()].unlock();
        }
    }
    {% else %}
    void unlock(int[] lock_ids, int end) {
        for (int i = 0; i < end; i++) {
            locks[lock_ids[i]].unlock();
        }
    }
    {% endif %}

    // Unlock method during exceptions
    void exception_unlock() {
        System.err.println("Exception encountered. Releasing all locks currently owned by " + Thread.currentThread().getName() + ".");
        for(ReentrantLock lock: locks) {
            while(lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}