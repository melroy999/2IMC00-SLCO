// VerCors imitation of the lock manager associated with SLCO class {{ model.name }}.
class LockManagerForSlcoClass{{ model.name }} {
    // The class the lock manager is made for.
    final SlcoClass{{ model.name }} c;

    /*@
    // The locking array is given as a ghost parameter.
    given int[] locks;

    // Require and ensure read access to the target class. Moreover, ensure that the target class remains unchanged.
    context Perm(c, 1\2);
    ensures c == \old(c);

    // Require and ensure that the state machine has access to the array variables within the target class.
    {% for v in model.variables | sort(attribute='lock_id') if v.is_array %}
    context Perm(c.{{ v.name }}, 1\2);
    {% endfor %}

    // Require and ensure that the arrays are not null and of the appropriate size.
    context locks != null && locks.length == {{ model.max_lock_id }};
    {% for v in model.variables | sort(attribute='lock_id') if v.is_array %}
    context c.{{ v.name }} != null && c.{{ v.name }}.length == {{ v.type.size }};
    {% endfor %}

    // Put restrictions on the input variables.
    requires lock_id >= 0 && lock_id < {{ model.max_lock_id }};

    // Require and ensure the permission of writing to the target element in the locks array.
    context Perm(locks[lock_id], 1);

    // Require and ensure that the value in the locks array is always a positive value.
    context locks[lock_id] >= 0;

    // Ensure that the locks counter is properly incremented.
    ensures locks[lock_id] == \old(locks[lock_id] + 1);

    // Require and ensure that the right permission is enforced, based on the value in the lock array.
    {% for v in model.variables | sort(attribute='lock_id') %}
    {% if v.is_array %}
    context lock_id >= {{ v.lock_id }} && lock_id < {{ v.type.size + v.lock_id }} ==> (locks[lock_id] > 0 ==> Perm(c.{{ v.name }}[lock_id - {{ v.lock_id }}], 1)) ** (locks[lock_id] == 0 ==> Perm(c.{{ v.name }}[lock_id - {{ v.lock_id }}], 0));
    {% else %}
    context lock_id == {{ v.lock_id }} ==> (locks[lock_id] > 0 ==> Perm(c.{{ v.name }}, 1)) ** (locks[lock_id] == 0 ==> Perm(c.{{ v.name }}, 0));
    {% endif %}
    {% endfor %}
    @*/
    // Lock method.
    void acquire_lock(int lock_id) {
        /*@
        ghost locks[lock_id]++;

        // Assume that the post-condition holds to simulate the effect of Re-entrant locking.
        {% for v in model.variables | sort(attribute='lock_id') %}
        {% if v.is_array %}
        assume lock_id >= {{ v.lock_id }} && lock_id < {{ v.type.size + v.lock_id }} ==> (locks[lock_id] > 0 ==> Perm(c.{{ v.name }}[lock_id - {{ v.lock_id }}], 1)) ** (locks[lock_id] == 0 ==> Perm(c.{{ v.name }}[lock_id - {{ v.lock_id }}], 0));
        {% else %}
        assume lock_id == {{ v.lock_id }} ==> (locks[lock_id] > 0 ==> Perm(c.{{ v.name }}, 1)) ** (locks[lock_id] == 0 ==> Perm(c.{{ v.name }}, 0));
        {% endif %}
        {% endfor %}
        @*/
    }

    /*@
    // The locking array is given as a ghost parameter.
    given int[] locks;

    // Require and ensure read access to the target class. Moreover, ensure that the target class remains unchanged.
    context Perm(c, 1\2);
    ensures c == \old(c);

    // Require and ensure that the state machine has access to the array variables within the target class.
    {% for v in model.variables | sort(attribute='lock_id') if v.is_array %}
    context Perm(c.{{ v.name }}, 1\2);
    {% endfor %}

    // Require and ensure that the arrays are not null and of the appropriate size.
    context locks != null && locks.length == {{ model.max_lock_id }};
    {% for v in model.variables | sort(attribute='lock_id') if v.is_array %}
    context c.{{ v.name }} != null && c.{{ v.name }}.length == {{ v.type.size }};
    {% endfor %}

    // Put restrictions on the input variables.
    requires lock_id >= 0 && lock_id < {{ model.max_lock_id }};

    // Require and ensure the permission of writing to the target element in the locks array.
    context Perm(locks[lock_id], 1);

    // Require that the target lock has been acquired at least once beforehand.
    requires locks[lock_id] > 0;

    // Ensure that the locks counter is properly decremented.
    ensures locks[lock_id] == \old(locks[lock_id] - 1);

    // Require and ensure that the right permission is enforced, based on the value in the lock array.
    {% for v in model.variables | sort(attribute='lock_id') %}
    {% if v.is_array %}
    context lock_id >= {{ v.lock_id }} && lock_id < {{ v.type.size + v.lock_id }} ==> (locks[lock_id] > 0 ==> Perm(c.{{ v.name }}[lock_id - {{ v.lock_id }}], 1)) ** (locks[lock_id] == 0 ==> Perm(c.{{ v.name }}[lock_id - {{ v.lock_id }}], 0));
    {% else %}
    context lock_id == {{ v.lock_id }} ==> (locks[lock_id] > 0 ==> Perm(c.{{ v.name }}, 1)) ** (locks[lock_id] == 0 ==> Perm(c.{{ v.name }}, 0));
    {% endif %}
    {% endfor %}
    @*/
    // Unlock method.
    void release_lock(int lock_id) {
        /*@
        ghost locks[lock_id]--;

        // Assume that the post-condition holds to simulate the effect of Re-entrant locking.
        {% for v in model.variables | sort(attribute='lock_id') %}
        {% if v.is_array %}
        assume lock_id >= {{ v.lock_id }} && lock_id < {{ v.type.size + v.lock_id }} ==> (locks[lock_id] > 0 ==> Perm(c.{{ v.name }}[lock_id - {{ v.lock_id }}], 1)) ** (locks[lock_id] == 0 ==> Perm(c.{{ v.name }}[lock_id - {{ v.lock_id }}], 0));
        {% else %}
        assume lock_id == {{ v.lock_id }} ==> (locks[lock_id] > 0 ==> Perm(c.{{ v.name }}, 1)) ** (locks[lock_id] == 0 ==> Perm(c.{{ v.name }}, 0));
        {% endif %}
        {% endfor %}
        @*/
    }
}