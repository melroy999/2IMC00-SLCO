// Define the states fot the state machine {{ model.name }}
interface {{ model.parent.name }}_{{ model.name }}Thread_States {
    enum States {
        {% for s in model.states %}
        {{ s }}{{ ", " if not loop.last }}
        {% endfor %}
    }
}

// Representation of the SLCO state machine {{ model.name }}
class {{ model.name }}Thread extends Thread implements {{ model.parent.name }}_{{ model.name }}Thread_States {
    // Current state
    private {{ model.name }}Thread.States currentState;

    // Random number generator to handle non-determinism
    private final Random random;

    {% if model.variables | length > 0 %}
    // Thread local variables
    {% for v in model.variables %}
    private {{ v | render_type }} {{ v.name }};
    {% endfor %}

    {% endif %}
    // The lock manager
    private final LockManager lockManager;

    // A list of lock ids that can be reused
    private final LockRequest[] lock_ids;

    {{ model.name }}Thread (LockManager lockManagerInstance) {
        random = new Random();
        lockManager = lockManagerInstance;
        lock_ids = new LockRequest[{ model.total_nr_of_unique_locks }];
        currentState = {{ model.name }}Thread.States.{{ model.initial_state }};
    }

    {% for t in model.transitions %}
    {{ t | render_transition(loop.index) | indent(4, False) }}

    {% endfor %}
    {% for s in model.states %}
    private void exec_{{ s }}() {

    }

    {% endfor %}
    // Execute method
    private void exec() {
        while(true) {
            switch(currentState) {
                {% for s in model.states %}
                case {{ s }} -> exec_{{ s }}();
                {% endfor %}
            }
        }
    }

    // Run method
    public void run() {
        {% if model.uses_class_variables %}
        try {
            exec();
        } catch(Exception e) {
            lockManager.exception_unlock();
            throw e;
        }
        {% else %}
        exec();
        {% endif %}
    }
}