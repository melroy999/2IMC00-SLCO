// > MODEL.START (Telephony)

// >> CLASS.START (GlobalClass)

// VerCors verification instructions for SLCO class GlobalClass.
class GlobalClass {
    // Class variables.
    private final int[] chan;
    private final int[] partner;
    private final int[] callforwardbusy;
    private final int[] record;

    /*@
    // Ensure full access to the class members.
    ensures Perm(this.chan, 1);
    ensures Perm(this.partner, 1);
    ensures Perm(this.callforwardbusy, 1);
    ensures Perm(this.record, 1);

    // Require that the given values are not null.
    requires chan != null;
    requires partner != null;
    requires callforwardbusy != null;
    requires record != null;

    // Ensure that the right values are assigned.
    ensures this.chan == chan;
    ensures this.partner == partner;
    ensures this.callforwardbusy == callforwardbusy;
    ensures this.record == record;
    @*/
    GlobalClass(int[] chan, int[] partner, int[] callforwardbusy, int[] record) {
        // Instantiate the class variables.
        this.chan = chan;
        this.partner = partner;
        this.callforwardbusy = callforwardbusy;
        this.record = record;
    }
}

// >>> STATE_MACHINE.START (User_0)

// VerCors verification instructions for SLCO state machine User_0.
class GlobalClass_User_0Thread {
    // The class the state machine is a part of.
    private final GlobalClass c;

    // Thread local variables.
    private int dev;
    private int mbit;
    // A list of lock requests. A value of 1 denotes that the given target is locked, and 0 implies no lock.
    private final int[] lock_requests;

    /*@
    // Ensure full access to the class members.
    ensures Perm(this.c, 1);

    // Require that the input class is a valid object.
    requires c != null;

    // Ensure that the appropriate starter values are assigned.
    ensures this.c == c;
    @*/
    GlobalClass_User_0Thread(GlobalClass c) {
        // Reference to the parent SLCO class.
        this.c = c;

        // Variable instantiations.
        dev = (char) 1;
        mbit = (char) 0;
        // Instantiate the lock requests array.
        lock_requests = new int[14];
    }

    // SLCO expression wrapper | chan[0] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[0] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [1: chan[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_idle_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        if(c.chan[0] == 255) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[0] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | idle -> dialing | [chan[0] = 255; dev := 0; chan[0] := (0 + 0 * 20)].
    private boolean execute_transition_idle_0() {
        // SLCO composite | [chan[0] = 255; dev := 0; chan[0] := ((0) + (0) * 20)] -> [chan[0] = 255; dev := 0; chan[0] := (0 + 0 * 20)].
        // SLCO expression | chan[0] = 255.
        if(!(t_idle_0_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        dev = (0) & 0xff;
        // SLCO assignment | chan[0] := (0 + 0 * 20).
        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        range_check_assumption_t_0_s_3();
        c.chan[0] = ((0 + 0 * 20)) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | chan[0] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[0] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_idle_1_s_0_n_0() {
        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        if(c.chan[0] != 255) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[0] != 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | idle -> qi | [chan[0] != 255; partner[0] := (chan[0] % 20)].
    private boolean execute_transition_idle_1() {
        // SLCO composite | [chan[0] != 255; partner[0] := ((chan[0]) % 20)] -> [chan[0] != 255; partner[0] := (chan[0] % 20)].
        // SLCO expression | chan[0] != 255.
        if(!(t_idle_1_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[0] := (chan[0] % 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        range_check_assumption_t_1_s_2();
        c.partner[0] = ((Math.floorMod(c.chan[0], 20))) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | (chan[partner[0]] % 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[0]], 20)) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_qi_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[c.partner[0]]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[0]].
        if((Math.floorMod(c.chan[c.partner[0]], 20)) == 0) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[0]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[0]], 20)) == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[0]] % 20) = 0.
    private boolean execute_transition_qi_0() {
        // SLCO expression | ((chan[partner[0]]) % 20) = 0 -> (chan[partner[0]] % 20) = 0.
        if(!(t_qi_0_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[0]] % 20) != 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[0]], 20)) != 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[partner[0]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_qi_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[0]].
        if((Math.floorMod(c.chan[c.partner[0]], 20)) != 0) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[0]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[0]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[0]], 20)) != 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[partner[0]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[0]] % 20) != 0; partner[0] := 255].
    private boolean execute_transition_qi_1() {
        // SLCO composite | [((chan[partner[0]]) % 20) != 0; partner[0] := 255] -> [(chan[partner[0]] % 20) != 0; partner[0] := 255].
        // SLCO expression | (chan[partner[0]] % 20) != 0.
        if(!(t_qi_1_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[0] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        range_check_assumption_t_1_s_2();
        c.partner[0] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[0] := 255].
    private boolean execute_transition_dialing_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [dev := 1; chan[0] := 255] -> [true; dev := 1; chan[0] := 255].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        dev = (1) & 0xff;
        // SLCO assignment | chan[0] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[0] == 1; // Verify lock activity.

        //@ assert lock_requests[0] == 1; // Check c.chan[0].
        range_check_assumption_t_0_s_4();
        c.chan[0] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.chan[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[0] := 0.
    private boolean execute_transition_dialing_1() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[0] := 0] -> partner[0] := 0.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[0].
        range_check_assumption_t_1_s_2();
        c.partner[0] = (0) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[0] := 1.
    private boolean execute_transition_dialing_2() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[0] := 1] -> partner[0] := 1.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[0].
        range_check_assumption_t_2_s_2();
        c.partner[0] = (1) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[0] := 2.
    private boolean execute_transition_dialing_3() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[0] := 2] -> partner[0] := 2.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[0].
        range_check_assumption_t_3_s_2();
        c.partner[0] = (2) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[0] := 3.
    private boolean execute_transition_dialing_4() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[0] := 3] -> partner[0] := 3.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[0].
        range_check_assumption_t_4_s_2();
        c.partner[0] = (3) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[0] := 4.
    private boolean execute_transition_dialing_5() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[0] := 4] -> partner[0] := 4.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[0].
        range_check_assumption_t_5_s_2();
        c.partner[0] = (4) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | partner[0] = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_0_s_0_n_0() {
        lock_requests[5] = lock_requests[5] + 1; // Acquire c.callforwardbusy[0]
        //@ assert lock_requests[5] == 1; // Verify lock activity.
        lock_requests[6] = lock_requests[6] + 1; // Acquire c.callforwardbusy[1]
        //@ assert lock_requests[6] == 1; // Verify lock activity.
        lock_requests[7] = lock_requests[7] + 1; // Acquire c.callforwardbusy[2]
        //@ assert lock_requests[7] == 1; // Verify lock activity.
        lock_requests[8] = lock_requests[8] + 1; // Acquire c.callforwardbusy[3]
        //@ assert lock_requests[8] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.record[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.record[1]
        //@ assert lock_requests[2] == 1; // Verify lock activity.
        lock_requests[3] = lock_requests[3] + 1; // Acquire c.record[2]
        //@ assert lock_requests[3] == 1; // Verify lock activity.
        lock_requests[4] = lock_requests[4] + 1; // Acquire c.record[3]
        //@ assert lock_requests[4] == 1; // Verify lock activity.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        if(c.partner[0] == 0) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
            //@ assert lock_requests[3] == 0; // Verify lock activity.
            lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
            //@ assert lock_requests[4] == 0; // Verify lock activity.
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[0] == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | calling -> busy | partner[0] = 0.
    private boolean execute_transition_calling_0() {
        // SLCO expression | partner[0] = 0.
        if(!(t_calling_0_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | partner[0] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        if(c.partner[0] == 4) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
            //@ assert lock_requests[3] == 0; // Verify lock activity.
            lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
            //@ assert lock_requests[4] == 0; // Verify lock activity.
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[0] == 4);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[0] = 4.
    private boolean execute_transition_calling_1() {
        // SLCO expression | partner[0] = 4.
        if(!(t_calling_1_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | partner[0] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_2_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        if(c.partner[0] == 4) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
            //@ assert lock_requests[3] == 0; // Verify lock activity.
            lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
            //@ assert lock_requests[4] == 0; // Verify lock activity.
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[0] == 4);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | calling -> ringback | partner[0] = 4.
    private boolean execute_transition_calling_2() {
        // SLCO expression | partner[0] = 4.
        if(!(t_calling_2_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | partner[0] != 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        return c.partner[0] != 0;
    }

    // SLCO expression wrapper | partner[0] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        return c.partner[0] != 4;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_2() {
        if(t_calling_3_s_0_n_0()) {
            if(t_calling_3_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        lock_requests[9] = lock_requests[9] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[9] == 1; // Verify lock activity.
        lock_requests[10] = lock_requests[10] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[10] == 1; // Verify lock activity.
        lock_requests[11] = lock_requests[11] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[11] == 1; // Verify lock activity.
        lock_requests[12] = lock_requests[12] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[12] == 1; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | chan[partner[0]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[0]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_3() {
        lock_requests[9] = lock_requests[9] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[9] == 1; // Verify lock activity.
        lock_requests[10] = lock_requests[10] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[10] == 1; // Verify lock activity.
        lock_requests[11] = lock_requests[11] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[11] == 1; // Verify lock activity.
        lock_requests[12] = lock_requests[12] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[12] == 1; // Verify lock activity.
        lock_requests[13] = lock_requests[13] + 1; // Acquire c.chan[c.partner[0]]
        //@ assert lock_requests[13] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[13] == 1; // Check c.chan[c.partner[0]].
        if(c.chan[c.partner[0]] != 255) {
            lock_requests[13] = lock_requests[13] - 1; // Release c.chan[c.partner[0]]
            //@ assert lock_requests[13] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[13] = lock_requests[13] - 1; // Release c.chan[c.partner[0]]
        //@ assert lock_requests[13] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_4() {
        if(t_calling_3_s_0_n_2()) {
            if(t_calling_3_s_0_n_3()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | callforwardbusy[partner[0]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[0]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_5() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[5] == 1; // Check c.callforwardbusy[0].
        //@ assert lock_requests[6] == 1; // Check c.callforwardbusy[1].
        //@ assert lock_requests[7] == 1; // Check c.callforwardbusy[2].
        //@ assert lock_requests[8] == 1; // Check c.callforwardbusy[3].
        if(c.callforwardbusy[c.partner[0]] == 255) {
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            lock_requests[9] = lock_requests[9] - 1; // Release c.chan[0]
            //@ assert lock_requests[9] == 0; // Verify lock activity.
            lock_requests[10] = lock_requests[10] - 1; // Release c.chan[1]
            //@ assert lock_requests[10] == 0; // Verify lock activity.
            lock_requests[11] = lock_requests[11] - 1; // Release c.chan[2]
            //@ assert lock_requests[11] == 0; // Verify lock activity.
            lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
            //@ assert lock_requests[12] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255 && c.callforwardbusy[c.partner[0]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_6() {
        if(t_calling_3_s_0_n_4()) {
            if(t_calling_3_s_0_n_5()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255 && c.callforwardbusy[c.partner[0]] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:3) | calling -> busy | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] = 255; record[partner[0]] := 0].
    private boolean execute_transition_calling_3() {
        // SLCO composite | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] = 255; record[partner[0]] := 0].
        // SLCO expression | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] = 255.
        if(!(t_calling_3_s_0_n_6())) {
            return false;
        }
        // SLCO assignment | record[partner[0]] := 0.
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.record[0].
        //@ assert lock_requests[2] == 1; // Check c.record[1].
        //@ assert lock_requests[3] == 1; // Check c.record[2].
        //@ assert lock_requests[4] == 1; // Check c.record[3].
        range_check_assumption_t_3_s_2();
        c.record[c.partner[0]] = (0) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | partner[0] != 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        if(c.partner[0] != 0) {
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[0] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        if(c.partner[0] != 4) {
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_2() {
        if(t_calling_4_s_0_n_0()) {
            if(t_calling_4_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | chan[partner[0]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[0]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_3() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[9] == 1; // Check c.chan[0].
        //@ assert lock_requests[10] == 1; // Check c.chan[1].
        //@ assert lock_requests[11] == 1; // Check c.chan[2].
        //@ assert lock_requests[12] == 1; // Check c.chan[3].
        if(c.chan[c.partner[0]] != 255) {
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_4() {
        if(t_calling_4_s_0_n_2()) {
            if(t_calling_4_s_0_n_3()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | callforwardbusy[partner[0]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[0]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_5() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[5] == 1; // Check c.callforwardbusy[0].
        //@ assert lock_requests[6] == 1; // Check c.callforwardbusy[1].
        //@ assert lock_requests[7] == 1; // Check c.callforwardbusy[2].
        //@ assert lock_requests[8] == 1; // Check c.callforwardbusy[3].
        if(c.callforwardbusy[c.partner[0]] != 255) {
            lock_requests[9] = lock_requests[9] - 1; // Release c.chan[0]
            //@ assert lock_requests[9] == 0; // Verify lock activity.
            lock_requests[10] = lock_requests[10] - 1; // Release c.chan[1]
            //@ assert lock_requests[10] == 0; // Verify lock activity.
            lock_requests[11] = lock_requests[11] - 1; // Release c.chan[2]
            //@ assert lock_requests[11] == 0; // Verify lock activity.
            lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
            //@ assert lock_requests[12] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255 && c.callforwardbusy[c.partner[0]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_6() {
        if(t_calling_4_s_0_n_4()) {
            if(t_calling_4_s_0_n_5()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255 && c.callforwardbusy[c.partner[0]] != 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:4) | calling -> calling | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] != 255; record[partner[0]] := 0; partner[0] := callforwardbusy[partner[0]]].
    private boolean execute_transition_calling_4() {
        // SLCO composite | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] != 255; record[partner[0]] := 0; partner[0] := callforwardbusy[partner[0]]].
        // SLCO expression | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] != 255.
        if(!(t_calling_4_s_0_n_6())) {
            return false;
        }
        // SLCO assignment | record[partner[0]] := 0.
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.record[0].
        //@ assert lock_requests[2] == 1; // Check c.record[1].
        //@ assert lock_requests[3] == 1; // Check c.record[2].
        //@ assert lock_requests[4] == 1; // Check c.record[3].
        range_check_assumption_t_4_s_2();
        c.record[c.partner[0]] = (0) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        // SLCO assignment | partner[0] := callforwardbusy[partner[0]].
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[5] == 1; // Check c.callforwardbusy[0].
        //@ assert lock_requests[6] == 1; // Check c.callforwardbusy[1].
        //@ assert lock_requests[7] == 1; // Check c.callforwardbusy[2].
        //@ assert lock_requests[8] == 1; // Check c.callforwardbusy[3].
        range_check_assumption_t_4_s_3();
        c.partner[0] = (c.callforwardbusy[c.partner[0]]) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | partner[0] != 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        if(c.partner[0] != 0) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[0]
        //@ assert lock_requests[9] == 0; // Verify lock activity.
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[1]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[2]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[0] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        if(c.partner[0] != 4) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[0]
        //@ assert lock_requests[9] == 0; // Verify lock activity.
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[1]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[2]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_2() {
        if(t_calling_5_s_0_n_0()) {
            if(t_calling_5_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | chan[partner[0]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[0]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_3() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[9] == 1; // Check c.chan[0].
        //@ assert lock_requests[10] == 1; // Check c.chan[1].
        //@ assert lock_requests[11] == 1; // Check c.chan[2].
        //@ assert lock_requests[12] == 1; // Check c.chan[3].
        if(c.chan[c.partner[0]] == 255) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[0]
        //@ assert lock_requests[9] == 0; // Verify lock activity.
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[1]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[2]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_4() {
        if(t_calling_5_s_0_n_2()) {
            if(t_calling_5_s_0_n_3()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[0], 10: chan[1], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:5) | calling -> oalert | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] = 255; record[partner[0]] := 0; chan[partner[0]] := (0 + 0 * 20); chan[0] := (partner[0] + 0 * 20)].
    private boolean execute_transition_calling_5() {
        // SLCO composite | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] = 255; record[partner[0]] := 0; chan[partner[0]] := ((0) + (0) * 20); chan[0] := ((partner[0]) + (0) * 20)] -> [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] = 255; record[partner[0]] := 0; chan[partner[0]] := (0 + 0 * 20); chan[0] := (partner[0] + 0 * 20)].
        // SLCO expression | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] = 255.
        if(!(t_calling_5_s_0_n_4())) {
            return false;
        }
        // SLCO assignment | record[partner[0]] := 0.
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.record[0].
        //@ assert lock_requests[2] == 1; // Check c.record[1].
        //@ assert lock_requests[3] == 1; // Check c.record[2].
        //@ assert lock_requests[4] == 1; // Check c.record[3].
        range_check_assumption_t_5_s_2();
        c.record[c.partner[0]] = (0) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        // SLCO assignment | chan[partner[0]] := (0 + 0 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[9] == 1; // Check c.chan[0].
        //@ assert lock_requests[10] == 1; // Check c.chan[1].
        //@ assert lock_requests[11] == 1; // Check c.chan[2].
        //@ assert lock_requests[12] == 1; // Check c.chan[3].
        range_check_assumption_t_5_s_3();
        c.chan[c.partner[0]] = ((0 + 0 * 20)) & 0xff;
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[1]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[2]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        // SLCO assignment | chan[0] := (partner[0] + 0 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[9] == 1; // Check c.chan[0].
        range_check_assumption_t_5_s_4();
        c.chan[0] = ((c.partner[0] + 0 * 20)) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[0]
        //@ assert lock_requests[9] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[0] := 255; partner[0] := 255; dev := 1].
    private boolean execute_transition_busy_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [chan[0] := 255; partner[0] := 255; dev := 1] -> [true; chan[0] := 255; partner[0] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | chan[0] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        range_check_assumption_t_0_s_3();
        c.chan[0] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | partner[0] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        range_check_assumption_t_0_s_4();
        c.partner[0] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        dev = (1) & 0xff;

        return true;
    }

    // SLCO expression wrapper | (chan[0] % 20) != partner[0].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[0], 20)) != c.partner[0]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        if((Math.floorMod(c.chan[0], 20)) != c.partner[0]) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[0], 20)) != c.partner[0]);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[0] % 20) != partner[0].
    private boolean execute_transition_oalert_0() {
        // SLCO expression | ((chan[0]) % 20) != partner[0] -> (chan[0] % 20) != partner[0].
        if(!(t_oalert_0_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[0] % 20) = partner[0].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[0], 20)) == c.partner[0]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        return (Math.floorMod(c.chan[0], 20)) == c.partner[0];
    }

    // SLCO expression wrapper | (chan[0] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[0] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_1_s_0_n_1() {
        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        if((c.chan[0] / 20) == 1) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[0] % 20) = partner[0] and (chan[0] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[0], 20)) == c.partner[0] && (c.chan[0] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_1_s_0_n_2() {
        if(t_oalert_1_s_0_n_0()) {
            if(t_oalert_1_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[0], 20)) == c.partner[0] && (c.chan[0] / 20) == 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[0] % 20) = partner[0] and (chan[0] / 20) = 1.
    private boolean execute_transition_oalert_1() {
        // SLCO expression | ((chan[0]) % 20) = partner[0] and ((chan[0]) / 20) = 1 -> (chan[0] % 20) = partner[0] and (chan[0] / 20) = 1.
        if(!(t_oalert_1_s_0_n_2())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[0] % 20) = partner[0].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[0], 20)) == c.partner[0]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [1: chan[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_2_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        if((Math.floorMod(c.chan[0], 20)) == c.partner[0]) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | (chan[0] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[0] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_2_s_0_n_1() {
        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        if((c.chan[0] / 20) == 0) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | (chan[0] % 20) = partner[0] and (chan[0] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[0], 20)) == c.partner[0] && (c.chan[0] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_2_s_0_n_2() {
        if(t_oalert_2_s_0_n_0()) {
            if(t_oalert_2_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[0], 20)) == c.partner[0] && (c.chan[0] / 20) == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[0] % 20) = partner[0] and (chan[0] / 20) = 0.
    private boolean execute_transition_oalert_2() {
        // SLCO expression | ((chan[0]) % 20) = partner[0] and ((chan[0]) / 20) = 0 -> (chan[0] % 20) = partner[0] and (chan[0] / 20) = 0.
        if(!(t_oalert_2_s_0_n_2())) {
            return false;
        }

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[0] := 255; chan[partner[0]] := 255].
    private boolean execute_transition_oconnected_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [dev := 1; chan[0] := 255; chan[partner[0]] := 255] -> [true; dev := 1; chan[0] := 255; chan[partner[0]] := 255].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        dev = (1) & 0xff;
        // SLCO assignment | chan[0] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[c.partner[0]]
        //@ assert lock_requests[2] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        range_check_assumption_t_0_s_4();
        c.chan[0] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | chan[partner[0]] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[2] == 1; // Check c.chan[c.partner[0]].
        range_check_assumption_t_0_s_5();
        c.chan[c.partner[0]] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[c.partner[0]]
        //@ assert lock_requests[2] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[0] := 255; partner[0] := ((partner[0] % 20) + 0 * 20)].
    private boolean execute_transition_dveoringout_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [dev := 1; chan[0] := 255; partner[0] := ((((partner[0]) % 20)) + (0) * 20)] -> [true; dev := 1; chan[0] := 255; partner[0] := ((partner[0] % 20) + 0 * 20)].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        dev = (1) & 0xff;
        // SLCO assignment | chan[0] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        range_check_assumption_t_0_s_4();
        c.chan[0] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | partner[0] := ((partner[0] % 20) + 0 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        range_check_assumption_t_0_s_5();
        c.partner[0] = (((Math.floorMod(c.partner[0], 20)) + 0 * 20)) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[0] := 255; partner[0] := 255; dev := 1].
    private boolean execute_transition_unobtainable_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [chan[0] := 255; partner[0] := 255; dev := 1] -> [true; chan[0] := 255; partner[0] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | chan[0] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        range_check_assumption_t_0_s_3();
        c.chan[0] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | partner[0] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        range_check_assumption_t_0_s_4();
        c.partner[0] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        dev = (1) & 0xff;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[0] := 255; partner[0] := 255; dev := 1].
    private boolean execute_transition_ringback_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [chan[0] := 255; partner[0] := 255; dev := 1] -> [true; chan[0] := 255; partner[0] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | chan[0] := 255.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[2] == 1; // Verify lock activity.

        //@ assert lock_requests[2] == 1; // Check c.chan[0].
        range_check_assumption_t_0_s_3();
        c.chan[0] = (255) & 0xff;
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[0]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        // SLCO assignment | partner[0] := 255.
        //@ assert lock_requests[1] == 1; // Check c.partner[0].
        range_check_assumption_t_0_s_4();
        c.partner[0] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        dev = (1) & 0xff;

        return true;
    }

    // SLCO expression wrapper | record[0] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.record[0] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: record[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_ringback_1_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.record[0]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.record[0].
        if(c.record[0] != 255) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.record[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.record[0] != 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | ringback -> calling | [record[0] != 255; partner[0] := record[0]].
    private boolean execute_transition_ringback_1() {
        // SLCO composite | [record[0] != 255; partner[0] := record[0]].
        // SLCO expression | record[0] != 255.
        if(!(t_ringback_1_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[0] := record[0].
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[0] == 1; // Check c.record[0].
        //@ assert lock_requests[1] == 1; // Check c.partner[0].
        range_check_assumption_t_1_s_2();
        c.partner[0] = (c.record[0]) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.record[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | dev != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_talert_0_s_0_n_0() {
        return dev != 1;
    }

    // SLCO expression wrapper | chan[0] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[0] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_talert_0_s_0_n_1() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[c.partner[0]]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[2] == 1; // Verify lock activity.
        //@ assert lock_requests[2] == 1; // Check c.chan[0].
        if(c.chan[0] == 255) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[0]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.chan[0]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[0]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | dev != 1 or chan[0] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1 || c.chan[0] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_talert_0_s_0_n_2() {
        if(t_talert_0_s_0_n_0()) {
            // Short-circuit fix trigger.
            return true;
        }
        if(t_talert_0_s_0_n_1()) {
            // Short-circuit fix trigger.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(dev != 1 || c.chan[0] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[0] = 255.
    private boolean execute_transition_talert_0() {
        // SLCO expression | dev != 1 or chan[0] = 255.
        if(!(t_talert_0_s_0_n_2())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[0]] % 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[0]], 20)) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[partner[0]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_talert_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[0]].
        if((Math.floorMod(c.chan[c.partner[0]], 20)) == 0) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[0]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[0]], 20)) == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[partner[0]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[0]] % 20) = 0.
    private boolean execute_transition_talert_1() {
        // SLCO expression | ((chan[partner[0]]) % 20) = 0 -> (chan[partner[0]] % 20) = 0.
        if(!(t_talert_1_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[0]] % 20) != 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[0]], 20)) != 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[partner[0]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_talert_2_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[0]].
        if((Math.floorMod(c.chan[c.partner[0]], 20)) != 0) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[0]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[0]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[0]], 20)) != 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[partner[0]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[0]] % 20) != 0.
    private boolean execute_transition_talert_2() {
        // SLCO expression | ((chan[partner[0]]) % 20) != 0 -> (chan[partner[0]] % 20) != 0.
        if(!(t_talert_2_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[0]] % 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[0]], 20)) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]], 2: chan[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]], 2: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[c.partner[0]]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[2] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[0]].
        return (Math.floorMod(c.chan[c.partner[0]], 20)) == 0;
    }

    // SLCO expression wrapper | (chan[partner[0]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[c.partner[0]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[partner[0]], 2: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]], 2: chan[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]], 2: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_0_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[0]].
        return (c.chan[c.partner[0]] / 20) == 0;
    }

    // SLCO expression wrapper | (chan[partner[0]] % 20) = 0 and (chan[partner[0]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[0]], 20)) == 0 && (c.chan[c.partner[0]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]], 2: chan[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]], 2: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_0_s_0_n_2() {
        if(t_tpickup_0_s_0_n_0()) {
            if(t_tpickup_0_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[0]], 20)) == 0 && (c.chan[c.partner[0]] / 20) == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]], 2: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[0]] % 20) = 0 and (chan[partner[0]] / 20) = 0; dev := 0; chan[partner[0]] := (0 + 1 * 20); chan[0] := (partner[0] + 1 * 20)].
    private boolean execute_transition_tpickup_0() {
        // SLCO composite | [((chan[partner[0]]) % 20) = 0 and ((chan[partner[0]]) / 20) = 0; dev := 0; chan[partner[0]] := ((0) + (1) * 20); chan[0] := ((partner[0]) + (1) * 20)] -> [(chan[partner[0]] % 20) = 0 and (chan[partner[0]] / 20) = 0; dev := 0; chan[partner[0]] := (0 + 1 * 20); chan[0] := (partner[0] + 1 * 20)].
        // SLCO expression | (chan[partner[0]] % 20) = 0 and (chan[partner[0]] / 20) = 0.
        if(!(t_tpickup_0_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        dev = (0) & 0xff;
        // SLCO assignment | chan[partner[0]] := (0 + 1 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[0]].
        range_check_assumption_t_0_s_3();
        c.chan[c.partner[0]] = ((0 + 1 * 20)) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[0]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | chan[0] := (partner[0] + 1 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[2] == 1; // Check c.chan[0].
        range_check_assumption_t_0_s_4();
        c.chan[0] = ((c.partner[0] + 1 * 20)) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[0]
        //@ assert lock_requests[2] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | chan[partner[0]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[0]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[partner[0]], 2: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 2: chan[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[partner[0]], 2: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[0]].
        if(c.chan[c.partner[0]] == 255) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[0]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[partner[0]] % 20) != 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[0]], 20)) != 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[partner[0]], 2: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 2: chan[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_1_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[0]].
        if((Math.floorMod(c.chan[c.partner[0]], 20)) != 0) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[0]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[0]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[0]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | chan[partner[0]] = 255 or (chan[partner[0]] % 20) != 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[0]] == 255 || (Math.floorMod(c.chan[c.partner[0]], 20)) != 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[partner[0]], 2: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 2: chan[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_1_s_0_n_2() {
        if(t_tpickup_1_s_0_n_0()) {
            // Short-circuit fix trigger.
            return true;
        }
        if(t_tpickup_1_s_0_n_1()) {
            // Short-circuit fix trigger.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[c.partner[0]] == 255 || (Math.floorMod(c.chan[c.partner[0]], 20)) != 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[partner[0]], 2: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[0]] = 255 or (chan[partner[0]] % 20) != 0; dev := 1; partner[0] := 255; chan[0] := 255].
    private boolean execute_transition_tpickup_1() {
        // SLCO composite | [chan[partner[0]] = 255 or ((chan[partner[0]]) % 20) != 0; dev := 1; partner[0] := 255; chan[0] := 255] -> [chan[partner[0]] = 255 or (chan[partner[0]] % 20) != 0; dev := 1; partner[0] := 255; chan[0] := 255].
        // SLCO expression | chan[partner[0]] = 255 or (chan[partner[0]] % 20) != 0.
        if(!(t_tpickup_1_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 1.
        range_check_assumption_t_1_s_2();
        dev = (1) & 0xff;
        // SLCO assignment | partner[0] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        range_check_assumption_t_1_s_3();
        c.partner[0] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | chan[0] := 255.
        //@ assert lock_requests[2] == 1; // Check c.chan[0].
        range_check_assumption_t_1_s_4();
        c.chan[0] = (255) & 0xff;
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[0]
        //@ assert lock_requests[2] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | (chan[0] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[0] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[0]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        return (c.chan[0] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_0_s_0_n_1() {
        if(dev == 0) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[0] / 20) = 1 and dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[0] / 20) == 1 && dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_0_s_0_n_2() {
        if(t_tconnected_0_s_0_n_0()) {
            if(t_tconnected_0_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[0] / 20) == 1 && dev == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[0] / 20) = 1 and dev = 0; dev := 1].
    private boolean execute_transition_tconnected_0() {
        // SLCO composite | [((chan[0]) / 20) = 1 and dev = 0; dev := 1] -> [(chan[0] / 20) = 1 and dev = 0; dev := 1].
        // SLCO expression | (chan[0] / 20) = 1 and dev = 0.
        if(!(t_tconnected_0_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_2();
        dev = (1) & 0xff;

        return true;
    }

    // SLCO expression wrapper | (chan[0] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[0] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_1_s_0_n_0() {
        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        return (c.chan[0] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_1_s_0_n_1() {
        if(dev == 1) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[0] / 20) = 1 and dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[0] / 20) == 1 && dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_1_s_0_n_2() {
        if(t_tconnected_1_s_0_n_0()) {
            if(t_tconnected_1_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[0] / 20) == 1 && dev == 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[0] / 20) = 1 and dev = 1; dev := 0].
    private boolean execute_transition_tconnected_1() {
        // SLCO composite | [((chan[0]) / 20) = 1 and dev = 1; dev := 0] -> [(chan[0] / 20) = 1 and dev = 1; dev := 0].
        // SLCO expression | (chan[0] / 20) = 1 and dev = 1.
        if(!(t_tconnected_1_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 0.
        range_check_assumption_t_1_s_2();
        dev = (0) & 0xff;

        return true;
    }

    // SLCO expression wrapper | (chan[0] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[0] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: chan[0]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_2_s_0_n_0() {
        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        if((c.chan[0] / 20) == 0) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[0] / 20) == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: chan[0]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[0] / 20) = 0; partner[0] := 255; chan[0] := 255].
    private boolean execute_transition_tconnected_2() {
        // SLCO composite | [((chan[0]) / 20) = 0; partner[0] := 255; chan[0] := 255] -> [(chan[0] / 20) = 0; partner[0] := 255; chan[0] := 255].
        // SLCO expression | (chan[0] / 20) = 0.
        if(!(t_tconnected_2_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[0] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        range_check_assumption_t_2_s_2();
        c.partner[0] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[0]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | chan[0] := 255.
        //@ assert lock_requests[1] == 1; // Check c.chan[0].
        range_check_assumption_t_2_s_3();
        c.chan[0] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state idle.
    private void exec_idle() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | idle -> dialing | [chan[0] = 255; dev := 0; chan[0] := (0 + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | idle -> qi | [chan[0] != 255; partner[0] := (chan[0] % 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state dialing.
    private void exec_dialing() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[0] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[0] := 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[0] := 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_2()) {
            return;
        }
        // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[0] := 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[0] := 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[0] := 4.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_5()) {
            return;
        }
        // [SEQ.END]
    }

    // SLCO expression wrapper | partner[0] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[0], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean d_calling_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[0].
        return c.partner[0] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state calling.
    private void exec_calling() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | calling -> busy | partner[0] = 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_0()) {
            return;
        }
        // SLCO expression | partner[0] = 4.
        if(d_calling_0_n_0()) {
            // [SEQ.START]
            // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[0] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_1()) {
                return;
            }
            // SLCO transition (p:0, id:2) | calling -> ringback | partner[0] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_2()) {
                return;
            }
            // [SEQ.END]
        }
        // SLCO transition (p:0, id:3) | calling -> busy | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] = 255; record[partner[0]] := 0].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | calling -> calling | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] != 255; record[partner[0]] := 0; partner[0] := callforwardbusy[partner[0]]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | calling -> oalert | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] = 255; record[partner[0]] := 0; chan[partner[0]] := (0 + 0 * 20); chan[0] := (partner[0] + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_5()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state busy.
    private void exec_busy() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[0] := 255; partner[0] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_busy_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state qi.
    private void exec_qi() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[0]] % 20) = 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[0]] % 20) != 0; partner[0] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state talert.
    private void exec_talert() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[0] = 255.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_0()) {
            return;
        }
        // [DET.START]
        // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[0]] % 20) = 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[0]] % 20) != 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state unobtainable.
    private void exec_unobtainable() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[0] := 255; partner[0] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_unobtainable_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state oalert.
    private void exec_oalert() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[0] % 20) != partner[0].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[0] % 20) = partner[0] and (chan[0] / 20) = 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[0] % 20) = partner[0] and (chan[0] / 20) = 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state errorstate.
    private void exec_errorstate() {
        // There are no transitions starting in state errorstate.
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state oconnected.
    private void exec_oconnected() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[0] := 255; chan[partner[0]] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oconnected_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state dveoringout.
    private void exec_dveoringout() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[0] := 255; partner[0] := ((partner[0] % 20) + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dveoringout_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state tpickup.
    private void exec_tpickup() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[0]] % 20) = 0 and (chan[partner[0]] / 20) = 0; dev := 0; chan[partner[0]] := (0 + 1 * 20); chan[0] := (partner[0] + 1 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[0]] = 255 or (chan[partner[0]] % 20) != 0; dev := 1; partner[0] := 255; chan[0] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state tconnected.
    private void exec_tconnected() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[0] / 20) = 1 and dev = 0; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[0] / 20) = 1 and dev = 1; dev := 0].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[0] / 20) = 0; partner[0] := 255; chan[0] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state ringback.
    private void exec_ringback() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[0] := 255; partner[0] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | ringback -> calling | [record[0] != 255; partner[0] := record[0]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_1()) {
            return;
        }
        // [SEQ.END]
    }
}

// <<< STATE_MACHINE.END (User_0)

// >>> STATE_MACHINE.START (User_1)

// VerCors verification instructions for SLCO state machine User_1.
class GlobalClass_User_1Thread {
    // The class the state machine is a part of.
    private final GlobalClass c;

    // Thread local variables.
    private int dev;
    private int mbit;
    // A list of lock requests. A value of 1 denotes that the given target is locked, and 0 implies no lock.
    private final int[] lock_requests;

    /*@
    // Ensure full access to the class members.
    ensures Perm(this.c, 1);

    // Require that the input class is a valid object.
    requires c != null;

    // Ensure that the appropriate starter values are assigned.
    ensures this.c == c;
    @*/
    GlobalClass_User_1Thread(GlobalClass c) {
        // Reference to the parent SLCO class.
        this.c = c;

        // Variable instantiations.
        dev = (char) 1;
        mbit = (char) 0;
        // Instantiate the lock requests array.
        lock_requests = new int[14];
    }

    // SLCO expression wrapper | chan[1] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[1] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [1: chan[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_idle_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        if(c.chan[1] == 255) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[1] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | idle -> dialing | [chan[1] = 255; dev := 0; chan[1] := (1 + 0 * 20)].
    private boolean execute_transition_idle_0() {
        // SLCO composite | [chan[1] = 255; dev := 0; chan[1] := ((1) + (0) * 20)] -> [chan[1] = 255; dev := 0; chan[1] := (1 + 0 * 20)].
        // SLCO expression | chan[1] = 255.
        if(!(t_idle_0_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        dev = (0) & 0xff;
        // SLCO assignment | chan[1] := (1 + 0 * 20).
        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        range_check_assumption_t_0_s_3();
        c.chan[1] = ((1 + 0 * 20)) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | chan[1] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[1] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_idle_1_s_0_n_0() {
        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        if(c.chan[1] != 255) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[1] != 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | idle -> qi | [chan[1] != 255; partner[1] := (chan[1] % 20)].
    private boolean execute_transition_idle_1() {
        // SLCO composite | [chan[1] != 255; partner[1] := ((chan[1]) % 20)] -> [chan[1] != 255; partner[1] := (chan[1] % 20)].
        // SLCO expression | chan[1] != 255.
        if(!(t_idle_1_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[1] := (chan[1] % 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        range_check_assumption_t_1_s_2();
        c.partner[1] = ((Math.floorMod(c.chan[1], 20))) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | (chan[partner[1]] % 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[1]], 20)) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_qi_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[c.partner[1]]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[1]].
        if((Math.floorMod(c.chan[c.partner[1]], 20)) == 1) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[1]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[1]], 20)) == 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[1]] % 20) = 1.
    private boolean execute_transition_qi_0() {
        // SLCO expression | ((chan[partner[1]]) % 20) = 1 -> (chan[partner[1]] % 20) = 1.
        if(!(t_qi_0_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[1]] % 20) != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[1]], 20)) != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[partner[1]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_qi_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[1]].
        if((Math.floorMod(c.chan[c.partner[1]], 20)) != 1) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[1]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[1]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[1]], 20)) != 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[partner[1]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[1]] % 20) != 1; partner[1] := 255].
    private boolean execute_transition_qi_1() {
        // SLCO composite | [((chan[partner[1]]) % 20) != 1; partner[1] := 255] -> [(chan[partner[1]] % 20) != 1; partner[1] := 255].
        // SLCO expression | (chan[partner[1]] % 20) != 1.
        if(!(t_qi_1_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[1] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        range_check_assumption_t_1_s_2();
        c.partner[1] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[1] := 255].
    private boolean execute_transition_dialing_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [dev := 1; chan[1] := 255] -> [true; dev := 1; chan[1] := 255].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        dev = (1) & 0xff;
        // SLCO assignment | chan[1] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[0] == 1; // Verify lock activity.

        //@ assert lock_requests[0] == 1; // Check c.chan[1].
        range_check_assumption_t_0_s_4();
        c.chan[1] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.chan[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[1] := 0.
    private boolean execute_transition_dialing_1() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[1] := 0] -> partner[1] := 0.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[1].
        range_check_assumption_t_1_s_2();
        c.partner[1] = (0) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[1] := 1.
    private boolean execute_transition_dialing_2() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[1] := 1] -> partner[1] := 1.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[1].
        range_check_assumption_t_2_s_2();
        c.partner[1] = (1) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[1] := 2.
    private boolean execute_transition_dialing_3() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[1] := 2] -> partner[1] := 2.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[1].
        range_check_assumption_t_3_s_2();
        c.partner[1] = (2) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[1] := 3.
    private boolean execute_transition_dialing_4() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[1] := 3] -> partner[1] := 3.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[1].
        range_check_assumption_t_4_s_2();
        c.partner[1] = (3) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[1] := 4.
    private boolean execute_transition_dialing_5() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[1] := 4] -> partner[1] := 4.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[1].
        range_check_assumption_t_5_s_2();
        c.partner[1] = (4) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | partner[1] = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_0_s_0_n_0() {
        lock_requests[5] = lock_requests[5] + 1; // Acquire c.callforwardbusy[0]
        //@ assert lock_requests[5] == 1; // Verify lock activity.
        lock_requests[6] = lock_requests[6] + 1; // Acquire c.callforwardbusy[1]
        //@ assert lock_requests[6] == 1; // Verify lock activity.
        lock_requests[7] = lock_requests[7] + 1; // Acquire c.callforwardbusy[2]
        //@ assert lock_requests[7] == 1; // Verify lock activity.
        lock_requests[8] = lock_requests[8] + 1; // Acquire c.callforwardbusy[3]
        //@ assert lock_requests[8] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.record[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.record[1]
        //@ assert lock_requests[2] == 1; // Verify lock activity.
        lock_requests[3] = lock_requests[3] + 1; // Acquire c.record[2]
        //@ assert lock_requests[3] == 1; // Verify lock activity.
        lock_requests[4] = lock_requests[4] + 1; // Acquire c.record[3]
        //@ assert lock_requests[4] == 1; // Verify lock activity.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        if(c.partner[1] == 1) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
            //@ assert lock_requests[3] == 0; // Verify lock activity.
            lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
            //@ assert lock_requests[4] == 0; // Verify lock activity.
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[1] == 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | calling -> busy | partner[1] = 1.
    private boolean execute_transition_calling_0() {
        // SLCO expression | partner[1] = 1.
        if(!(t_calling_0_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | partner[1] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        if(c.partner[1] == 4) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
            //@ assert lock_requests[3] == 0; // Verify lock activity.
            lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
            //@ assert lock_requests[4] == 0; // Verify lock activity.
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[1] == 4);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[1] = 4.
    private boolean execute_transition_calling_1() {
        // SLCO expression | partner[1] = 4.
        if(!(t_calling_1_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | partner[1] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_2_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        if(c.partner[1] == 4) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
            //@ assert lock_requests[3] == 0; // Verify lock activity.
            lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
            //@ assert lock_requests[4] == 0; // Verify lock activity.
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[1] == 4);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | calling -> ringback | partner[1] = 4.
    private boolean execute_transition_calling_2() {
        // SLCO expression | partner[1] = 4.
        if(!(t_calling_2_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | partner[1] != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        return c.partner[1] != 1;
    }

    // SLCO expression wrapper | partner[1] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        return c.partner[1] != 4;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_2() {
        if(t_calling_3_s_0_n_0()) {
            if(t_calling_3_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        lock_requests[9] = lock_requests[9] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[9] == 1; // Verify lock activity.
        lock_requests[10] = lock_requests[10] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[10] == 1; // Verify lock activity.
        lock_requests[11] = lock_requests[11] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[11] == 1; // Verify lock activity.
        lock_requests[12] = lock_requests[12] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[12] == 1; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | chan[partner[1]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[1]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_3() {
        lock_requests[9] = lock_requests[9] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[9] == 1; // Verify lock activity.
        lock_requests[10] = lock_requests[10] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[10] == 1; // Verify lock activity.
        lock_requests[11] = lock_requests[11] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[11] == 1; // Verify lock activity.
        lock_requests[12] = lock_requests[12] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[12] == 1; // Verify lock activity.
        lock_requests[13] = lock_requests[13] + 1; // Acquire c.chan[c.partner[1]]
        //@ assert lock_requests[13] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[13] == 1; // Check c.chan[c.partner[1]].
        if(c.chan[c.partner[1]] != 255) {
            lock_requests[13] = lock_requests[13] - 1; // Release c.chan[c.partner[1]]
            //@ assert lock_requests[13] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[13] = lock_requests[13] - 1; // Release c.chan[c.partner[1]]
        //@ assert lock_requests[13] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_4() {
        if(t_calling_3_s_0_n_2()) {
            if(t_calling_3_s_0_n_3()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | callforwardbusy[partner[1]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[1]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_5() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[5] == 1; // Check c.callforwardbusy[0].
        //@ assert lock_requests[6] == 1; // Check c.callforwardbusy[1].
        //@ assert lock_requests[7] == 1; // Check c.callforwardbusy[2].
        //@ assert lock_requests[8] == 1; // Check c.callforwardbusy[3].
        if(c.callforwardbusy[c.partner[1]] == 255) {
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            lock_requests[9] = lock_requests[9] - 1; // Release c.chan[1]
            //@ assert lock_requests[9] == 0; // Verify lock activity.
            lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
            //@ assert lock_requests[10] == 0; // Verify lock activity.
            lock_requests[11] = lock_requests[11] - 1; // Release c.chan[2]
            //@ assert lock_requests[11] == 0; // Verify lock activity.
            lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
            //@ assert lock_requests[12] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255 && c.callforwardbusy[c.partner[1]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_6() {
        if(t_calling_3_s_0_n_4()) {
            if(t_calling_3_s_0_n_5()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255 && c.callforwardbusy[c.partner[1]] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:3) | calling -> busy | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] = 255; record[partner[1]] := 1].
    private boolean execute_transition_calling_3() {
        // SLCO composite | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] = 255; record[partner[1]] := 1].
        // SLCO expression | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] = 255.
        if(!(t_calling_3_s_0_n_6())) {
            return false;
        }
        // SLCO assignment | record[partner[1]] := 1.
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.record[0].
        //@ assert lock_requests[2] == 1; // Check c.record[1].
        //@ assert lock_requests[3] == 1; // Check c.record[2].
        //@ assert lock_requests[4] == 1; // Check c.record[3].
        range_check_assumption_t_3_s_2();
        c.record[c.partner[1]] = (1) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | partner[1] != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        if(c.partner[1] != 1) {
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[1] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        if(c.partner[1] != 4) {
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_2() {
        if(t_calling_4_s_0_n_0()) {
            if(t_calling_4_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | chan[partner[1]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[1]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_3() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[9] == 1; // Check c.chan[1].
        //@ assert lock_requests[10] == 1; // Check c.chan[0].
        //@ assert lock_requests[11] == 1; // Check c.chan[2].
        //@ assert lock_requests[12] == 1; // Check c.chan[3].
        if(c.chan[c.partner[1]] != 255) {
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_4() {
        if(t_calling_4_s_0_n_2()) {
            if(t_calling_4_s_0_n_3()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | callforwardbusy[partner[1]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[1]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_5() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[5] == 1; // Check c.callforwardbusy[0].
        //@ assert lock_requests[6] == 1; // Check c.callforwardbusy[1].
        //@ assert lock_requests[7] == 1; // Check c.callforwardbusy[2].
        //@ assert lock_requests[8] == 1; // Check c.callforwardbusy[3].
        if(c.callforwardbusy[c.partner[1]] != 255) {
            lock_requests[9] = lock_requests[9] - 1; // Release c.chan[1]
            //@ assert lock_requests[9] == 0; // Verify lock activity.
            lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
            //@ assert lock_requests[10] == 0; // Verify lock activity.
            lock_requests[11] = lock_requests[11] - 1; // Release c.chan[2]
            //@ assert lock_requests[11] == 0; // Verify lock activity.
            lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
            //@ assert lock_requests[12] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255 && c.callforwardbusy[c.partner[1]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_6() {
        if(t_calling_4_s_0_n_4()) {
            if(t_calling_4_s_0_n_5()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255 && c.callforwardbusy[c.partner[1]] != 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:4) | calling -> calling | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] != 255; record[partner[1]] := 1; partner[1] := callforwardbusy[partner[1]]].
    private boolean execute_transition_calling_4() {
        // SLCO composite | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] != 255; record[partner[1]] := 1; partner[1] := callforwardbusy[partner[1]]].
        // SLCO expression | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] != 255.
        if(!(t_calling_4_s_0_n_6())) {
            return false;
        }
        // SLCO assignment | record[partner[1]] := 1.
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.record[0].
        //@ assert lock_requests[2] == 1; // Check c.record[1].
        //@ assert lock_requests[3] == 1; // Check c.record[2].
        //@ assert lock_requests[4] == 1; // Check c.record[3].
        range_check_assumption_t_4_s_2();
        c.record[c.partner[1]] = (1) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        // SLCO assignment | partner[1] := callforwardbusy[partner[1]].
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[5] == 1; // Check c.callforwardbusy[0].
        //@ assert lock_requests[6] == 1; // Check c.callforwardbusy[1].
        //@ assert lock_requests[7] == 1; // Check c.callforwardbusy[2].
        //@ assert lock_requests[8] == 1; // Check c.callforwardbusy[3].
        range_check_assumption_t_4_s_3();
        c.partner[1] = (c.callforwardbusy[c.partner[1]]) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | partner[1] != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        if(c.partner[1] != 1) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[1]
        //@ assert lock_requests[9] == 0; // Verify lock activity.
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[2]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[1] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        if(c.partner[1] != 4) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[1]
        //@ assert lock_requests[9] == 0; // Verify lock activity.
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[2]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_2() {
        if(t_calling_5_s_0_n_0()) {
            if(t_calling_5_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | chan[partner[1]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[1]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_3() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[9] == 1; // Check c.chan[1].
        //@ assert lock_requests[10] == 1; // Check c.chan[0].
        //@ assert lock_requests[11] == 1; // Check c.chan[2].
        //@ assert lock_requests[12] == 1; // Check c.chan[3].
        if(c.chan[c.partner[1]] == 255) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[1]
        //@ assert lock_requests[9] == 0; // Verify lock activity.
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[2]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_4() {
        if(t_calling_5_s_0_n_2()) {
            if(t_calling_5_s_0_n_3()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[1], 10: chan[0], 11: chan[2], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:5) | calling -> oalert | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] = 255; record[partner[1]] := 1; chan[partner[1]] := (1 + 0 * 20); chan[1] := (partner[1] + 0 * 20)].
    private boolean execute_transition_calling_5() {
        // SLCO composite | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] = 255; record[partner[1]] := 1; chan[partner[1]] := ((1) + (0) * 20); chan[1] := ((partner[1]) + (0) * 20)] -> [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] = 255; record[partner[1]] := 1; chan[partner[1]] := (1 + 0 * 20); chan[1] := (partner[1] + 0 * 20)].
        // SLCO expression | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] = 255.
        if(!(t_calling_5_s_0_n_4())) {
            return false;
        }
        // SLCO assignment | record[partner[1]] := 1.
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.record[0].
        //@ assert lock_requests[2] == 1; // Check c.record[1].
        //@ assert lock_requests[3] == 1; // Check c.record[2].
        //@ assert lock_requests[4] == 1; // Check c.record[3].
        range_check_assumption_t_5_s_2();
        c.record[c.partner[1]] = (1) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        // SLCO assignment | chan[partner[1]] := (1 + 0 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[9] == 1; // Check c.chan[1].
        //@ assert lock_requests[10] == 1; // Check c.chan[0].
        //@ assert lock_requests[11] == 1; // Check c.chan[2].
        //@ assert lock_requests[12] == 1; // Check c.chan[3].
        range_check_assumption_t_5_s_3();
        c.chan[c.partner[1]] = ((1 + 0 * 20)) & 0xff;
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[2]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        // SLCO assignment | chan[1] := (partner[1] + 0 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[9] == 1; // Check c.chan[1].
        range_check_assumption_t_5_s_4();
        c.chan[1] = ((c.partner[1] + 0 * 20)) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[1]
        //@ assert lock_requests[9] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[1] := 255; partner[1] := 255; dev := 1].
    private boolean execute_transition_busy_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [chan[1] := 255; partner[1] := 255; dev := 1] -> [true; chan[1] := 255; partner[1] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | chan[1] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        range_check_assumption_t_0_s_3();
        c.chan[1] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | partner[1] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        range_check_assumption_t_0_s_4();
        c.partner[1] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        dev = (1) & 0xff;

        return true;
    }

    // SLCO expression wrapper | (chan[1] % 20) != partner[1].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[1], 20)) != c.partner[1]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        if((Math.floorMod(c.chan[1], 20)) != c.partner[1]) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[1], 20)) != c.partner[1]);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[1] % 20) != partner[1].
    private boolean execute_transition_oalert_0() {
        // SLCO expression | ((chan[1]) % 20) != partner[1] -> (chan[1] % 20) != partner[1].
        if(!(t_oalert_0_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[1] % 20) = partner[1].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[1], 20)) == c.partner[1]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        return (Math.floorMod(c.chan[1], 20)) == c.partner[1];
    }

    // SLCO expression wrapper | (chan[1] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[1] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_1_s_0_n_1() {
        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        if((c.chan[1] / 20) == 1) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[1] % 20) = partner[1] and (chan[1] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[1], 20)) == c.partner[1] && (c.chan[1] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_1_s_0_n_2() {
        if(t_oalert_1_s_0_n_0()) {
            if(t_oalert_1_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[1], 20)) == c.partner[1] && (c.chan[1] / 20) == 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[1] % 20) = partner[1] and (chan[1] / 20) = 1.
    private boolean execute_transition_oalert_1() {
        // SLCO expression | ((chan[1]) % 20) = partner[1] and ((chan[1]) / 20) = 1 -> (chan[1] % 20) = partner[1] and (chan[1] / 20) = 1.
        if(!(t_oalert_1_s_0_n_2())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[1] % 20) = partner[1].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[1], 20)) == c.partner[1]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [1: chan[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_2_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        if((Math.floorMod(c.chan[1], 20)) == c.partner[1]) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | (chan[1] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[1] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_2_s_0_n_1() {
        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        if((c.chan[1] / 20) == 0) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | (chan[1] % 20) = partner[1] and (chan[1] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[1], 20)) == c.partner[1] && (c.chan[1] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_2_s_0_n_2() {
        if(t_oalert_2_s_0_n_0()) {
            if(t_oalert_2_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[1], 20)) == c.partner[1] && (c.chan[1] / 20) == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[1] % 20) = partner[1] and (chan[1] / 20) = 0.
    private boolean execute_transition_oalert_2() {
        // SLCO expression | ((chan[1]) % 20) = partner[1] and ((chan[1]) / 20) = 0 -> (chan[1] % 20) = partner[1] and (chan[1] / 20) = 0.
        if(!(t_oalert_2_s_0_n_2())) {
            return false;
        }

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[1] := 255; chan[partner[1]] := 255].
    private boolean execute_transition_oconnected_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [dev := 1; chan[1] := 255; chan[partner[1]] := 255] -> [true; dev := 1; chan[1] := 255; chan[partner[1]] := 255].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        dev = (1) & 0xff;
        // SLCO assignment | chan[1] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[c.partner[1]]
        //@ assert lock_requests[2] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        range_check_assumption_t_0_s_4();
        c.chan[1] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | chan[partner[1]] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[2] == 1; // Check c.chan[c.partner[1]].
        range_check_assumption_t_0_s_5();
        c.chan[c.partner[1]] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[c.partner[1]]
        //@ assert lock_requests[2] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[1] := 255; partner[1] := ((partner[1] % 20) + 0 * 20)].
    private boolean execute_transition_dveoringout_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [dev := 1; chan[1] := 255; partner[1] := ((((partner[1]) % 20)) + (0) * 20)] -> [true; dev := 1; chan[1] := 255; partner[1] := ((partner[1] % 20) + 0 * 20)].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        dev = (1) & 0xff;
        // SLCO assignment | chan[1] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        range_check_assumption_t_0_s_4();
        c.chan[1] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | partner[1] := ((partner[1] % 20) + 0 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        range_check_assumption_t_0_s_5();
        c.partner[1] = (((Math.floorMod(c.partner[1], 20)) + 0 * 20)) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[1] := 255; partner[1] := 255; dev := 1].
    private boolean execute_transition_unobtainable_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [chan[1] := 255; partner[1] := 255; dev := 1] -> [true; chan[1] := 255; partner[1] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | chan[1] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        range_check_assumption_t_0_s_3();
        c.chan[1] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | partner[1] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        range_check_assumption_t_0_s_4();
        c.partner[1] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        dev = (1) & 0xff;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[1] := 255; partner[1] := 255; dev := 1].
    private boolean execute_transition_ringback_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [chan[1] := 255; partner[1] := 255; dev := 1] -> [true; chan[1] := 255; partner[1] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | chan[1] := 255.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[2] == 1; // Verify lock activity.

        //@ assert lock_requests[2] == 1; // Check c.chan[1].
        range_check_assumption_t_0_s_3();
        c.chan[1] = (255) & 0xff;
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        // SLCO assignment | partner[1] := 255.
        //@ assert lock_requests[1] == 1; // Check c.partner[1].
        range_check_assumption_t_0_s_4();
        c.partner[1] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        dev = (1) & 0xff;

        return true;
    }

    // SLCO expression wrapper | record[1] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.record[1] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: record[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_ringback_1_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.record[1]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.record[1].
        if(c.record[1] != 255) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.record[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.record[1] != 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | ringback -> calling | [record[1] != 255; partner[1] := record[1]].
    private boolean execute_transition_ringback_1() {
        // SLCO composite | [record[1] != 255; partner[1] := record[1]].
        // SLCO expression | record[1] != 255.
        if(!(t_ringback_1_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[1] := record[1].
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[0] == 1; // Check c.record[1].
        //@ assert lock_requests[1] == 1; // Check c.partner[1].
        range_check_assumption_t_1_s_2();
        c.partner[1] = (c.record[1]) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.record[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | dev != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_talert_0_s_0_n_0() {
        return dev != 1;
    }

    // SLCO expression wrapper | chan[1] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[1] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_talert_0_s_0_n_1() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[c.partner[1]]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[2] == 1; // Verify lock activity.
        //@ assert lock_requests[2] == 1; // Check c.chan[1].
        if(c.chan[1] == 255) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[1]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.chan[1]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | dev != 1 or chan[1] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1 || c.chan[1] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_talert_0_s_0_n_2() {
        if(t_talert_0_s_0_n_0()) {
            // Short-circuit fix trigger.
            return true;
        }
        if(t_talert_0_s_0_n_1()) {
            // Short-circuit fix trigger.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(dev != 1 || c.chan[1] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[1] = 255.
    private boolean execute_transition_talert_0() {
        // SLCO expression | dev != 1 or chan[1] = 255.
        if(!(t_talert_0_s_0_n_2())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[1]] % 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[1]], 20)) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[partner[1]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_talert_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[1]].
        if((Math.floorMod(c.chan[c.partner[1]], 20)) == 1) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[1]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[1]], 20)) == 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[partner[1]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[1]] % 20) = 1.
    private boolean execute_transition_talert_1() {
        // SLCO expression | ((chan[partner[1]]) % 20) = 1 -> (chan[partner[1]] % 20) = 1.
        if(!(t_talert_1_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[1]] % 20) != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[1]], 20)) != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[partner[1]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_talert_2_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[1]].
        if((Math.floorMod(c.chan[c.partner[1]], 20)) != 1) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[1]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[1]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[1]], 20)) != 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[partner[1]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[1]] % 20) != 1.
    private boolean execute_transition_talert_2() {
        // SLCO expression | ((chan[partner[1]]) % 20) != 1 -> (chan[partner[1]] % 20) != 1.
        if(!(t_talert_2_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[1]] % 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[1]], 20)) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]], 2: chan[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]], 2: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[c.partner[1]]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[2] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[1]].
        return (Math.floorMod(c.chan[c.partner[1]], 20)) == 1;
    }

    // SLCO expression wrapper | (chan[partner[1]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[c.partner[1]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[partner[1]], 2: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]], 2: chan[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]], 2: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_0_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[1]].
        return (c.chan[c.partner[1]] / 20) == 0;
    }

    // SLCO expression wrapper | (chan[partner[1]] % 20) = 1 and (chan[partner[1]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[1]], 20)) == 1 && (c.chan[c.partner[1]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]], 2: chan[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]], 2: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_0_s_0_n_2() {
        if(t_tpickup_0_s_0_n_0()) {
            if(t_tpickup_0_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[1]], 20)) == 1 && (c.chan[c.partner[1]] / 20) == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]], 2: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[1]] % 20) = 1 and (chan[partner[1]] / 20) = 0; dev := 0; chan[partner[1]] := (1 + 1 * 20); chan[1] := (partner[1] + 1 * 20)].
    private boolean execute_transition_tpickup_0() {
        // SLCO composite | [((chan[partner[1]]) % 20) = 1 and ((chan[partner[1]]) / 20) = 0; dev := 0; chan[partner[1]] := ((1) + (1) * 20); chan[1] := ((partner[1]) + (1) * 20)] -> [(chan[partner[1]] % 20) = 1 and (chan[partner[1]] / 20) = 0; dev := 0; chan[partner[1]] := (1 + 1 * 20); chan[1] := (partner[1] + 1 * 20)].
        // SLCO expression | (chan[partner[1]] % 20) = 1 and (chan[partner[1]] / 20) = 0.
        if(!(t_tpickup_0_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        dev = (0) & 0xff;
        // SLCO assignment | chan[partner[1]] := (1 + 1 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[1]].
        range_check_assumption_t_0_s_3();
        c.chan[c.partner[1]] = ((1 + 1 * 20)) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[1]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | chan[1] := (partner[1] + 1 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[2] == 1; // Check c.chan[1].
        range_check_assumption_t_0_s_4();
        c.chan[1] = ((c.partner[1] + 1 * 20)) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | chan[partner[1]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[1]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[partner[1]], 2: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 2: chan[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[partner[1]], 2: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[1]].
        if(c.chan[c.partner[1]] == 255) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[1]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[partner[1]] % 20) != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[1]], 20)) != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[partner[1]], 2: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 2: chan[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_1_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[1]].
        if((Math.floorMod(c.chan[c.partner[1]], 20)) != 1) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[1]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[1]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | chan[partner[1]] = 255 or (chan[partner[1]] % 20) != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[1]] == 255 || (Math.floorMod(c.chan[c.partner[1]], 20)) != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[partner[1]], 2: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 2: chan[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_1_s_0_n_2() {
        if(t_tpickup_1_s_0_n_0()) {
            // Short-circuit fix trigger.
            return true;
        }
        if(t_tpickup_1_s_0_n_1()) {
            // Short-circuit fix trigger.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[c.partner[1]] == 255 || (Math.floorMod(c.chan[c.partner[1]], 20)) != 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[partner[1]], 2: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[1]] = 255 or (chan[partner[1]] % 20) != 1; dev := 1; partner[1] := 255; chan[1] := 255].
    private boolean execute_transition_tpickup_1() {
        // SLCO composite | [chan[partner[1]] = 255 or ((chan[partner[1]]) % 20) != 1; dev := 1; partner[1] := 255; chan[1] := 255] -> [chan[partner[1]] = 255 or (chan[partner[1]] % 20) != 1; dev := 1; partner[1] := 255; chan[1] := 255].
        // SLCO expression | chan[partner[1]] = 255 or (chan[partner[1]] % 20) != 1.
        if(!(t_tpickup_1_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 1.
        range_check_assumption_t_1_s_2();
        dev = (1) & 0xff;
        // SLCO assignment | partner[1] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        range_check_assumption_t_1_s_3();
        c.partner[1] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | chan[1] := 255.
        //@ assert lock_requests[2] == 1; // Check c.chan[1].
        range_check_assumption_t_1_s_4();
        c.chan[1] = (255) & 0xff;
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | (chan[1] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[1] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[1]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        return (c.chan[1] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_0_s_0_n_1() {
        if(dev == 0) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[1] / 20) = 1 and dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[1] / 20) == 1 && dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_0_s_0_n_2() {
        if(t_tconnected_0_s_0_n_0()) {
            if(t_tconnected_0_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[1] / 20) == 1 && dev == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[1] / 20) = 1 and dev = 0; dev := 1].
    private boolean execute_transition_tconnected_0() {
        // SLCO composite | [((chan[1]) / 20) = 1 and dev = 0; dev := 1] -> [(chan[1] / 20) = 1 and dev = 0; dev := 1].
        // SLCO expression | (chan[1] / 20) = 1 and dev = 0.
        if(!(t_tconnected_0_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_2();
        dev = (1) & 0xff;

        return true;
    }

    // SLCO expression wrapper | (chan[1] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[1] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_1_s_0_n_0() {
        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        return (c.chan[1] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_1_s_0_n_1() {
        if(dev == 1) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[1] / 20) = 1 and dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[1] / 20) == 1 && dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_1_s_0_n_2() {
        if(t_tconnected_1_s_0_n_0()) {
            if(t_tconnected_1_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[1] / 20) == 1 && dev == 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[1] / 20) = 1 and dev = 1; dev := 0].
    private boolean execute_transition_tconnected_1() {
        // SLCO composite | [((chan[1]) / 20) = 1 and dev = 1; dev := 0] -> [(chan[1] / 20) = 1 and dev = 1; dev := 0].
        // SLCO expression | (chan[1] / 20) = 1 and dev = 1.
        if(!(t_tconnected_1_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 0.
        range_check_assumption_t_1_s_2();
        dev = (0) & 0xff;

        return true;
    }

    // SLCO expression wrapper | (chan[1] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[1] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: chan[1]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_2_s_0_n_0() {
        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        if((c.chan[1] / 20) == 0) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[1] / 20) == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: chan[1]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[1] / 20) = 0; partner[1] := 255; chan[1] := 255].
    private boolean execute_transition_tconnected_2() {
        // SLCO composite | [((chan[1]) / 20) = 0; partner[1] := 255; chan[1] := 255] -> [(chan[1] / 20) = 0; partner[1] := 255; chan[1] := 255].
        // SLCO expression | (chan[1] / 20) = 0.
        if(!(t_tconnected_2_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[1] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        range_check_assumption_t_2_s_2();
        c.partner[1] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[1]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | chan[1] := 255.
        //@ assert lock_requests[1] == 1; // Check c.chan[1].
        range_check_assumption_t_2_s_3();
        c.chan[1] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[1]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state idle.
    private void exec_idle() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | idle -> dialing | [chan[1] = 255; dev := 0; chan[1] := (1 + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | idle -> qi | [chan[1] != 255; partner[1] := (chan[1] % 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state dialing.
    private void exec_dialing() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[1] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[1] := 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[1] := 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_2()) {
            return;
        }
        // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[1] := 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[1] := 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[1] := 4.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_5()) {
            return;
        }
        // [SEQ.END]
    }

    // SLCO expression wrapper | partner[1] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[1], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean d_calling_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[1].
        return c.partner[1] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state calling.
    private void exec_calling() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | calling -> busy | partner[1] = 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_0()) {
            return;
        }
        // SLCO expression | partner[1] = 4.
        if(d_calling_0_n_0()) {
            // [SEQ.START]
            // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[1] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_1()) {
                return;
            }
            // SLCO transition (p:0, id:2) | calling -> ringback | partner[1] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_2()) {
                return;
            }
            // [SEQ.END]
        }
        // SLCO transition (p:0, id:3) | calling -> busy | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] = 255; record[partner[1]] := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | calling -> calling | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] != 255; record[partner[1]] := 1; partner[1] := callforwardbusy[partner[1]]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | calling -> oalert | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] = 255; record[partner[1]] := 1; chan[partner[1]] := (1 + 0 * 20); chan[1] := (partner[1] + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_5()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state busy.
    private void exec_busy() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[1] := 255; partner[1] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_busy_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state qi.
    private void exec_qi() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[1]] % 20) = 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[1]] % 20) != 1; partner[1] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state talert.
    private void exec_talert() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[1] = 255.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_0()) {
            return;
        }
        // [DET.START]
        // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[1]] % 20) = 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[1]] % 20) != 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state unobtainable.
    private void exec_unobtainable() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[1] := 255; partner[1] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_unobtainable_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state oalert.
    private void exec_oalert() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[1] % 20) != partner[1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[1] % 20) = partner[1] and (chan[1] / 20) = 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[1] % 20) = partner[1] and (chan[1] / 20) = 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state errorstate.
    private void exec_errorstate() {
        // There are no transitions starting in state errorstate.
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state oconnected.
    private void exec_oconnected() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[1] := 255; chan[partner[1]] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oconnected_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state dveoringout.
    private void exec_dveoringout() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[1] := 255; partner[1] := ((partner[1] % 20) + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dveoringout_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state tpickup.
    private void exec_tpickup() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[1]] % 20) = 1 and (chan[partner[1]] / 20) = 0; dev := 0; chan[partner[1]] := (1 + 1 * 20); chan[1] := (partner[1] + 1 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[1]] = 255 or (chan[partner[1]] % 20) != 1; dev := 1; partner[1] := 255; chan[1] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state tconnected.
    private void exec_tconnected() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[1] / 20) = 1 and dev = 0; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[1] / 20) = 1 and dev = 1; dev := 0].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[1] / 20) = 0; partner[1] := 255; chan[1] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state ringback.
    private void exec_ringback() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[1] := 255; partner[1] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | ringback -> calling | [record[1] != 255; partner[1] := record[1]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_1()) {
            return;
        }
        // [SEQ.END]
    }
}

// <<< STATE_MACHINE.END (User_1)

// >>> STATE_MACHINE.START (User_2)

// VerCors verification instructions for SLCO state machine User_2.
class GlobalClass_User_2Thread {
    // The class the state machine is a part of.
    private final GlobalClass c;

    // Thread local variables.
    private int dev;
    private int mbit;
    // A list of lock requests. A value of 1 denotes that the given target is locked, and 0 implies no lock.
    private final int[] lock_requests;

    /*@
    // Ensure full access to the class members.
    ensures Perm(this.c, 1);

    // Require that the input class is a valid object.
    requires c != null;

    // Ensure that the appropriate starter values are assigned.
    ensures this.c == c;
    @*/
    GlobalClass_User_2Thread(GlobalClass c) {
        // Reference to the parent SLCO class.
        this.c = c;

        // Variable instantiations.
        dev = (char) 1;
        mbit = (char) 0;
        // Instantiate the lock requests array.
        lock_requests = new int[14];
    }

    // SLCO expression wrapper | chan[2] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[2] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [1: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_idle_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        if(c.chan[2] == 255) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[2] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | idle -> dialing | [chan[2] = 255; dev := 0; chan[2] := (2 + 0 * 20)].
    private boolean execute_transition_idle_0() {
        // SLCO composite | [chan[2] = 255; dev := 0; chan[2] := ((2) + (0) * 20)] -> [chan[2] = 255; dev := 0; chan[2] := (2 + 0 * 20)].
        // SLCO expression | chan[2] = 255.
        if(!(t_idle_0_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        dev = (0) & 0xff;
        // SLCO assignment | chan[2] := (2 + 0 * 20).
        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        range_check_assumption_t_0_s_3();
        c.chan[2] = ((2 + 0 * 20)) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | chan[2] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[2] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_idle_1_s_0_n_0() {
        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        if(c.chan[2] != 255) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[2] != 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | idle -> qi | [chan[2] != 255; partner[2] := (chan[2] % 20)].
    private boolean execute_transition_idle_1() {
        // SLCO composite | [chan[2] != 255; partner[2] := ((chan[2]) % 20)] -> [chan[2] != 255; partner[2] := (chan[2] % 20)].
        // SLCO expression | chan[2] != 255.
        if(!(t_idle_1_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[2] := (chan[2] % 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        range_check_assumption_t_1_s_2();
        c.partner[2] = ((Math.floorMod(c.chan[2], 20))) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | (chan[partner[2]] % 20) = 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[2]], 20)) == 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_qi_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[c.partner[2]]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[2]].
        if((Math.floorMod(c.chan[c.partner[2]], 20)) == 2) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[2]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[2]], 20)) == 2);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[2]] % 20) = 2.
    private boolean execute_transition_qi_0() {
        // SLCO expression | ((chan[partner[2]]) % 20) = 2 -> (chan[partner[2]] % 20) = 2.
        if(!(t_qi_0_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[2]] % 20) != 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[2]], 20)) != 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[partner[2]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_qi_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[2]].
        if((Math.floorMod(c.chan[c.partner[2]], 20)) != 2) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[2]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[2]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[2]], 20)) != 2);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[partner[2]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[2]] % 20) != 2; partner[2] := 255].
    private boolean execute_transition_qi_1() {
        // SLCO composite | [((chan[partner[2]]) % 20) != 2; partner[2] := 255] -> [(chan[partner[2]] % 20) != 2; partner[2] := 255].
        // SLCO expression | (chan[partner[2]] % 20) != 2.
        if(!(t_qi_1_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[2] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        range_check_assumption_t_1_s_2();
        c.partner[2] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[2] := 255].
    private boolean execute_transition_dialing_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [dev := 1; chan[2] := 255] -> [true; dev := 1; chan[2] := 255].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        dev = (1) & 0xff;
        // SLCO assignment | chan[2] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[0] == 1; // Verify lock activity.

        //@ assert lock_requests[0] == 1; // Check c.chan[2].
        range_check_assumption_t_0_s_4();
        c.chan[2] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.chan[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[2] := 0.
    private boolean execute_transition_dialing_1() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[2] := 0] -> partner[2] := 0.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[2].
        range_check_assumption_t_1_s_2();
        c.partner[2] = (0) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[2] := 1.
    private boolean execute_transition_dialing_2() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[2] := 1] -> partner[2] := 1.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[2].
        range_check_assumption_t_2_s_2();
        c.partner[2] = (1) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[2] := 2.
    private boolean execute_transition_dialing_3() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[2] := 2] -> partner[2] := 2.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[2].
        range_check_assumption_t_3_s_2();
        c.partner[2] = (2) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[2] := 3.
    private boolean execute_transition_dialing_4() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[2] := 3] -> partner[2] := 3.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[2].
        range_check_assumption_t_4_s_2();
        c.partner[2] = (3) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[2] := 4.
    private boolean execute_transition_dialing_5() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[2] := 4] -> partner[2] := 4.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[2].
        range_check_assumption_t_5_s_2();
        c.partner[2] = (4) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | partner[2] = 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] == 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_0_s_0_n_0() {
        lock_requests[5] = lock_requests[5] + 1; // Acquire c.callforwardbusy[0]
        //@ assert lock_requests[5] == 1; // Verify lock activity.
        lock_requests[6] = lock_requests[6] + 1; // Acquire c.callforwardbusy[1]
        //@ assert lock_requests[6] == 1; // Verify lock activity.
        lock_requests[7] = lock_requests[7] + 1; // Acquire c.callforwardbusy[2]
        //@ assert lock_requests[7] == 1; // Verify lock activity.
        lock_requests[8] = lock_requests[8] + 1; // Acquire c.callforwardbusy[3]
        //@ assert lock_requests[8] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.record[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.record[1]
        //@ assert lock_requests[2] == 1; // Verify lock activity.
        lock_requests[3] = lock_requests[3] + 1; // Acquire c.record[2]
        //@ assert lock_requests[3] == 1; // Verify lock activity.
        lock_requests[4] = lock_requests[4] + 1; // Acquire c.record[3]
        //@ assert lock_requests[4] == 1; // Verify lock activity.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        if(c.partner[2] == 2) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
            //@ assert lock_requests[3] == 0; // Verify lock activity.
            lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
            //@ assert lock_requests[4] == 0; // Verify lock activity.
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[2] == 2);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | calling -> busy | partner[2] = 2.
    private boolean execute_transition_calling_0() {
        // SLCO expression | partner[2] = 2.
        if(!(t_calling_0_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | partner[2] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        if(c.partner[2] == 4) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
            //@ assert lock_requests[3] == 0; // Verify lock activity.
            lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
            //@ assert lock_requests[4] == 0; // Verify lock activity.
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[2] == 4);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[2] = 4.
    private boolean execute_transition_calling_1() {
        // SLCO expression | partner[2] = 4.
        if(!(t_calling_1_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | partner[2] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_2_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        if(c.partner[2] == 4) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
            //@ assert lock_requests[3] == 0; // Verify lock activity.
            lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
            //@ assert lock_requests[4] == 0; // Verify lock activity.
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[2] == 4);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | calling -> ringback | partner[2] = 4.
    private boolean execute_transition_calling_2() {
        // SLCO expression | partner[2] = 4.
        if(!(t_calling_2_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | partner[2] != 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        return c.partner[2] != 2;
    }

    // SLCO expression wrapper | partner[2] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        return c.partner[2] != 4;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_2() {
        if(t_calling_3_s_0_n_0()) {
            if(t_calling_3_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        lock_requests[9] = lock_requests[9] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[9] == 1; // Verify lock activity.
        lock_requests[10] = lock_requests[10] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[10] == 1; // Verify lock activity.
        lock_requests[11] = lock_requests[11] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[11] == 1; // Verify lock activity.
        lock_requests[12] = lock_requests[12] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[12] == 1; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | chan[partner[2]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[2]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_3() {
        lock_requests[9] = lock_requests[9] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[9] == 1; // Verify lock activity.
        lock_requests[10] = lock_requests[10] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[10] == 1; // Verify lock activity.
        lock_requests[11] = lock_requests[11] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[11] == 1; // Verify lock activity.
        lock_requests[12] = lock_requests[12] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[12] == 1; // Verify lock activity.
        lock_requests[13] = lock_requests[13] + 1; // Acquire c.chan[c.partner[2]]
        //@ assert lock_requests[13] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[13] == 1; // Check c.chan[c.partner[2]].
        if(c.chan[c.partner[2]] != 255) {
            lock_requests[13] = lock_requests[13] - 1; // Release c.chan[c.partner[2]]
            //@ assert lock_requests[13] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[13] = lock_requests[13] - 1; // Release c.chan[c.partner[2]]
        //@ assert lock_requests[13] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_4() {
        if(t_calling_3_s_0_n_2()) {
            if(t_calling_3_s_0_n_3()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | callforwardbusy[partner[2]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[2]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_5() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[5] == 1; // Check c.callforwardbusy[0].
        //@ assert lock_requests[6] == 1; // Check c.callforwardbusy[1].
        //@ assert lock_requests[7] == 1; // Check c.callforwardbusy[2].
        //@ assert lock_requests[8] == 1; // Check c.callforwardbusy[3].
        if(c.callforwardbusy[c.partner[2]] == 255) {
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            lock_requests[9] = lock_requests[9] - 1; // Release c.chan[2]
            //@ assert lock_requests[9] == 0; // Verify lock activity.
            lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
            //@ assert lock_requests[10] == 0; // Verify lock activity.
            lock_requests[11] = lock_requests[11] - 1; // Release c.chan[1]
            //@ assert lock_requests[11] == 0; // Verify lock activity.
            lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
            //@ assert lock_requests[12] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255 && c.callforwardbusy[c.partner[2]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_6() {
        if(t_calling_3_s_0_n_4()) {
            if(t_calling_3_s_0_n_5()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255 && c.callforwardbusy[c.partner[2]] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:3) | calling -> busy | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] = 255; record[partner[2]] := 2].
    private boolean execute_transition_calling_3() {
        // SLCO composite | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] = 255; record[partner[2]] := 2].
        // SLCO expression | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] = 255.
        if(!(t_calling_3_s_0_n_6())) {
            return false;
        }
        // SLCO assignment | record[partner[2]] := 2.
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.record[0].
        //@ assert lock_requests[2] == 1; // Check c.record[1].
        //@ assert lock_requests[3] == 1; // Check c.record[2].
        //@ assert lock_requests[4] == 1; // Check c.record[3].
        range_check_assumption_t_3_s_2();
        c.record[c.partner[2]] = (2) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | partner[2] != 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        if(c.partner[2] != 2) {
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[2] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        if(c.partner[2] != 4) {
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_2() {
        if(t_calling_4_s_0_n_0()) {
            if(t_calling_4_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | chan[partner[2]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[2]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_3() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[9] == 1; // Check c.chan[2].
        //@ assert lock_requests[10] == 1; // Check c.chan[0].
        //@ assert lock_requests[11] == 1; // Check c.chan[1].
        //@ assert lock_requests[12] == 1; // Check c.chan[3].
        if(c.chan[c.partner[2]] != 255) {
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_4() {
        if(t_calling_4_s_0_n_2()) {
            if(t_calling_4_s_0_n_3()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | callforwardbusy[partner[2]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[2]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_5() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[5] == 1; // Check c.callforwardbusy[0].
        //@ assert lock_requests[6] == 1; // Check c.callforwardbusy[1].
        //@ assert lock_requests[7] == 1; // Check c.callforwardbusy[2].
        //@ assert lock_requests[8] == 1; // Check c.callforwardbusy[3].
        if(c.callforwardbusy[c.partner[2]] != 255) {
            lock_requests[9] = lock_requests[9] - 1; // Release c.chan[2]
            //@ assert lock_requests[9] == 0; // Verify lock activity.
            lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
            //@ assert lock_requests[10] == 0; // Verify lock activity.
            lock_requests[11] = lock_requests[11] - 1; // Release c.chan[1]
            //@ assert lock_requests[11] == 0; // Verify lock activity.
            lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
            //@ assert lock_requests[12] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255 && c.callforwardbusy[c.partner[2]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_6() {
        if(t_calling_4_s_0_n_4()) {
            if(t_calling_4_s_0_n_5()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255 && c.callforwardbusy[c.partner[2]] != 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:4) | calling -> calling | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] != 255; record[partner[2]] := 2; partner[2] := callforwardbusy[partner[2]]].
    private boolean execute_transition_calling_4() {
        // SLCO composite | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] != 255; record[partner[2]] := 2; partner[2] := callforwardbusy[partner[2]]].
        // SLCO expression | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] != 255.
        if(!(t_calling_4_s_0_n_6())) {
            return false;
        }
        // SLCO assignment | record[partner[2]] := 2.
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.record[0].
        //@ assert lock_requests[2] == 1; // Check c.record[1].
        //@ assert lock_requests[3] == 1; // Check c.record[2].
        //@ assert lock_requests[4] == 1; // Check c.record[3].
        range_check_assumption_t_4_s_2();
        c.record[c.partner[2]] = (2) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        // SLCO assignment | partner[2] := callforwardbusy[partner[2]].
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[5] == 1; // Check c.callforwardbusy[0].
        //@ assert lock_requests[6] == 1; // Check c.callforwardbusy[1].
        //@ assert lock_requests[7] == 1; // Check c.callforwardbusy[2].
        //@ assert lock_requests[8] == 1; // Check c.callforwardbusy[3].
        range_check_assumption_t_4_s_3();
        c.partner[2] = (c.callforwardbusy[c.partner[2]]) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | partner[2] != 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        if(c.partner[2] != 2) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[2]
        //@ assert lock_requests[9] == 0; // Verify lock activity.
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[1]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[2] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        if(c.partner[2] != 4) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[2]
        //@ assert lock_requests[9] == 0; // Verify lock activity.
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[1]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_2() {
        if(t_calling_5_s_0_n_0()) {
            if(t_calling_5_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | chan[partner[2]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[2]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_3() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[9] == 1; // Check c.chan[2].
        //@ assert lock_requests[10] == 1; // Check c.chan[0].
        //@ assert lock_requests[11] == 1; // Check c.chan[1].
        //@ assert lock_requests[12] == 1; // Check c.chan[3].
        if(c.chan[c.partner[2]] == 255) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[2]
        //@ assert lock_requests[9] == 0; // Verify lock activity.
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[1]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_4() {
        if(t_calling_5_s_0_n_2()) {
            if(t_calling_5_s_0_n_3()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[2], 10: chan[0], 11: chan[1], 12: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:5) | calling -> oalert | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] = 255; record[partner[2]] := 2; chan[partner[2]] := (2 + 0 * 20); chan[2] := (partner[2] + 0 * 20)].
    private boolean execute_transition_calling_5() {
        // SLCO composite | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] = 255; record[partner[2]] := 2; chan[partner[2]] := ((2) + (0) * 20); chan[2] := ((partner[2]) + (0) * 20)] -> [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] = 255; record[partner[2]] := 2; chan[partner[2]] := (2 + 0 * 20); chan[2] := (partner[2] + 0 * 20)].
        // SLCO expression | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] = 255.
        if(!(t_calling_5_s_0_n_4())) {
            return false;
        }
        // SLCO assignment | record[partner[2]] := 2.
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.record[0].
        //@ assert lock_requests[2] == 1; // Check c.record[1].
        //@ assert lock_requests[3] == 1; // Check c.record[2].
        //@ assert lock_requests[4] == 1; // Check c.record[3].
        range_check_assumption_t_5_s_2();
        c.record[c.partner[2]] = (2) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        // SLCO assignment | chan[partner[2]] := (2 + 0 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[9] == 1; // Check c.chan[2].
        //@ assert lock_requests[10] == 1; // Check c.chan[0].
        //@ assert lock_requests[11] == 1; // Check c.chan[1].
        //@ assert lock_requests[12] == 1; // Check c.chan[3].
        range_check_assumption_t_5_s_3();
        c.chan[c.partner[2]] = ((2 + 0 * 20)) & 0xff;
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[1]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[3]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        // SLCO assignment | chan[2] := (partner[2] + 0 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[9] == 1; // Check c.chan[2].
        range_check_assumption_t_5_s_4();
        c.chan[2] = ((c.partner[2] + 0 * 20)) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[2]
        //@ assert lock_requests[9] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[2] := 255; partner[2] := 255; dev := 1].
    private boolean execute_transition_busy_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [chan[2] := 255; partner[2] := 255; dev := 1] -> [true; chan[2] := 255; partner[2] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | chan[2] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        range_check_assumption_t_0_s_3();
        c.chan[2] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | partner[2] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        range_check_assumption_t_0_s_4();
        c.partner[2] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        dev = (1) & 0xff;

        return true;
    }

    // SLCO expression wrapper | (chan[2] % 20) != partner[2].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[2], 20)) != c.partner[2]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        if((Math.floorMod(c.chan[2], 20)) != c.partner[2]) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[2], 20)) != c.partner[2]);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[2] % 20) != partner[2].
    private boolean execute_transition_oalert_0() {
        // SLCO expression | ((chan[2]) % 20) != partner[2] -> (chan[2] % 20) != partner[2].
        if(!(t_oalert_0_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[2] % 20) = partner[2].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[2], 20)) == c.partner[2]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        return (Math.floorMod(c.chan[2], 20)) == c.partner[2];
    }

    // SLCO expression wrapper | (chan[2] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[2] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_1_s_0_n_1() {
        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        if((c.chan[2] / 20) == 1) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[2] % 20) = partner[2] and (chan[2] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[2], 20)) == c.partner[2] && (c.chan[2] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_1_s_0_n_2() {
        if(t_oalert_1_s_0_n_0()) {
            if(t_oalert_1_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[2], 20)) == c.partner[2] && (c.chan[2] / 20) == 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[2] % 20) = partner[2] and (chan[2] / 20) = 1.
    private boolean execute_transition_oalert_1() {
        // SLCO expression | ((chan[2]) % 20) = partner[2] and ((chan[2]) / 20) = 1 -> (chan[2] % 20) = partner[2] and (chan[2] / 20) = 1.
        if(!(t_oalert_1_s_0_n_2())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[2] % 20) = partner[2].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[2], 20)) == c.partner[2]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [1: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_2_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        if((Math.floorMod(c.chan[2], 20)) == c.partner[2]) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | (chan[2] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[2] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_2_s_0_n_1() {
        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        if((c.chan[2] / 20) == 0) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | (chan[2] % 20) = partner[2] and (chan[2] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[2], 20)) == c.partner[2] && (c.chan[2] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_2_s_0_n_2() {
        if(t_oalert_2_s_0_n_0()) {
            if(t_oalert_2_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[2], 20)) == c.partner[2] && (c.chan[2] / 20) == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[2] % 20) = partner[2] and (chan[2] / 20) = 0.
    private boolean execute_transition_oalert_2() {
        // SLCO expression | ((chan[2]) % 20) = partner[2] and ((chan[2]) / 20) = 0 -> (chan[2] % 20) = partner[2] and (chan[2] / 20) = 0.
        if(!(t_oalert_2_s_0_n_2())) {
            return false;
        }

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[2] := 255; chan[partner[2]] := 255].
    private boolean execute_transition_oconnected_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [dev := 1; chan[2] := 255; chan[partner[2]] := 255] -> [true; dev := 1; chan[2] := 255; chan[partner[2]] := 255].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        dev = (1) & 0xff;
        // SLCO assignment | chan[2] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[c.partner[2]]
        //@ assert lock_requests[2] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        range_check_assumption_t_0_s_4();
        c.chan[2] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | chan[partner[2]] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[2] == 1; // Check c.chan[c.partner[2]].
        range_check_assumption_t_0_s_5();
        c.chan[c.partner[2]] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[c.partner[2]]
        //@ assert lock_requests[2] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[2] := 255; partner[2] := ((partner[2] % 20) + 0 * 20)].
    private boolean execute_transition_dveoringout_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [dev := 1; chan[2] := 255; partner[2] := ((((partner[2]) % 20)) + (0) * 20)] -> [true; dev := 1; chan[2] := 255; partner[2] := ((partner[2] % 20) + 0 * 20)].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        dev = (1) & 0xff;
        // SLCO assignment | chan[2] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        range_check_assumption_t_0_s_4();
        c.chan[2] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | partner[2] := ((partner[2] % 20) + 0 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        range_check_assumption_t_0_s_5();
        c.partner[2] = (((Math.floorMod(c.partner[2], 20)) + 0 * 20)) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[2] := 255; partner[2] := 255; dev := 1].
    private boolean execute_transition_unobtainable_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [chan[2] := 255; partner[2] := 255; dev := 1] -> [true; chan[2] := 255; partner[2] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | chan[2] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        range_check_assumption_t_0_s_3();
        c.chan[2] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | partner[2] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        range_check_assumption_t_0_s_4();
        c.partner[2] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        dev = (1) & 0xff;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[2] := 255; partner[2] := 255; dev := 1].
    private boolean execute_transition_ringback_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [chan[2] := 255; partner[2] := 255; dev := 1] -> [true; chan[2] := 255; partner[2] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | chan[2] := 255.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[2] == 1; // Verify lock activity.

        //@ assert lock_requests[2] == 1; // Check c.chan[2].
        range_check_assumption_t_0_s_3();
        c.chan[2] = (255) & 0xff;
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[2]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        // SLCO assignment | partner[2] := 255.
        //@ assert lock_requests[1] == 1; // Check c.partner[2].
        range_check_assumption_t_0_s_4();
        c.partner[2] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        dev = (1) & 0xff;

        return true;
    }

    // SLCO expression wrapper | record[2] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.record[2] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: record[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_ringback_1_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.record[2]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.record[2].
        if(c.record[2] != 255) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.record[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.record[2] != 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | ringback -> calling | [record[2] != 255; partner[2] := record[2]].
    private boolean execute_transition_ringback_1() {
        // SLCO composite | [record[2] != 255; partner[2] := record[2]].
        // SLCO expression | record[2] != 255.
        if(!(t_ringback_1_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[2] := record[2].
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[0] == 1; // Check c.record[2].
        //@ assert lock_requests[1] == 1; // Check c.partner[2].
        range_check_assumption_t_1_s_2();
        c.partner[2] = (c.record[2]) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.record[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | dev != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_talert_0_s_0_n_0() {
        return dev != 1;
    }

    // SLCO expression wrapper | chan[2] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[2] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_talert_0_s_0_n_1() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[c.partner[2]]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[2] == 1; // Verify lock activity.
        //@ assert lock_requests[2] == 1; // Check c.chan[2].
        if(c.chan[2] == 255) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[2]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.chan[2]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[2]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | dev != 1 or chan[2] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1 || c.chan[2] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_talert_0_s_0_n_2() {
        if(t_talert_0_s_0_n_0()) {
            // Short-circuit fix trigger.
            return true;
        }
        if(t_talert_0_s_0_n_1()) {
            // Short-circuit fix trigger.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(dev != 1 || c.chan[2] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[2] = 255.
    private boolean execute_transition_talert_0() {
        // SLCO expression | dev != 1 or chan[2] = 255.
        if(!(t_talert_0_s_0_n_2())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[2]] % 20) = 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[2]], 20)) == 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[partner[2]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_talert_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[2]].
        if((Math.floorMod(c.chan[c.partner[2]], 20)) == 2) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[2]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[2]], 20)) == 2);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[partner[2]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[2]] % 20) = 2.
    private boolean execute_transition_talert_1() {
        // SLCO expression | ((chan[partner[2]]) % 20) = 2 -> (chan[partner[2]] % 20) = 2.
        if(!(t_talert_1_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[2]] % 20) != 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[2]], 20)) != 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[partner[2]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_talert_2_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[2]].
        if((Math.floorMod(c.chan[c.partner[2]], 20)) != 2) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[2]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[2]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[2]], 20)) != 2);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[partner[2]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[2]] % 20) != 2.
    private boolean execute_transition_talert_2() {
        // SLCO expression | ((chan[partner[2]]) % 20) != 2 -> (chan[partner[2]] % 20) != 2.
        if(!(t_talert_2_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[2]] % 20) = 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[2]], 20)) == 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]], 2: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]], 2: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[c.partner[2]]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[2] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[2]].
        return (Math.floorMod(c.chan[c.partner[2]], 20)) == 2;
    }

    // SLCO expression wrapper | (chan[partner[2]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[c.partner[2]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[partner[2]], 2: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]], 2: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]], 2: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_0_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[2]].
        return (c.chan[c.partner[2]] / 20) == 0;
    }

    // SLCO expression wrapper | (chan[partner[2]] % 20) = 2 and (chan[partner[2]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[2]], 20)) == 2 && (c.chan[c.partner[2]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]], 2: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]], 2: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_0_s_0_n_2() {
        if(t_tpickup_0_s_0_n_0()) {
            if(t_tpickup_0_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[2]], 20)) == 2 && (c.chan[c.partner[2]] / 20) == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]], 2: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[2]] % 20) = 2 and (chan[partner[2]] / 20) = 0; dev := 0; chan[partner[2]] := (2 + 1 * 20); chan[2] := (partner[2] + 1 * 20)].
    private boolean execute_transition_tpickup_0() {
        // SLCO composite | [((chan[partner[2]]) % 20) = 2 and ((chan[partner[2]]) / 20) = 0; dev := 0; chan[partner[2]] := ((2) + (1) * 20); chan[2] := ((partner[2]) + (1) * 20)] -> [(chan[partner[2]] % 20) = 2 and (chan[partner[2]] / 20) = 0; dev := 0; chan[partner[2]] := (2 + 1 * 20); chan[2] := (partner[2] + 1 * 20)].
        // SLCO expression | (chan[partner[2]] % 20) = 2 and (chan[partner[2]] / 20) = 0.
        if(!(t_tpickup_0_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        dev = (0) & 0xff;
        // SLCO assignment | chan[partner[2]] := (2 + 1 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[2]].
        range_check_assumption_t_0_s_3();
        c.chan[c.partner[2]] = ((2 + 1 * 20)) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[2]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | chan[2] := (partner[2] + 1 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[2] == 1; // Check c.chan[2].
        range_check_assumption_t_0_s_4();
        c.chan[2] = ((c.partner[2] + 1 * 20)) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[2]
        //@ assert lock_requests[2] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | chan[partner[2]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[2]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[partner[2]], 2: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 2: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[partner[2]], 2: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[2]].
        if(c.chan[c.partner[2]] == 255) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[2]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[partner[2]] % 20) != 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[2]], 20)) != 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[partner[2]], 2: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 2: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_1_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[2]].
        if((Math.floorMod(c.chan[c.partner[2]], 20)) != 2) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[2]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[2]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[2]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | chan[partner[2]] = 255 or (chan[partner[2]] % 20) != 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[2]] == 255 || (Math.floorMod(c.chan[c.partner[2]], 20)) != 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[partner[2]], 2: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 2: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_1_s_0_n_2() {
        if(t_tpickup_1_s_0_n_0()) {
            // Short-circuit fix trigger.
            return true;
        }
        if(t_tpickup_1_s_0_n_1()) {
            // Short-circuit fix trigger.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[c.partner[2]] == 255 || (Math.floorMod(c.chan[c.partner[2]], 20)) != 2);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[partner[2]], 2: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[2]] = 255 or (chan[partner[2]] % 20) != 2; dev := 1; partner[2] := 255; chan[2] := 255].
    private boolean execute_transition_tpickup_1() {
        // SLCO composite | [chan[partner[2]] = 255 or ((chan[partner[2]]) % 20) != 2; dev := 1; partner[2] := 255; chan[2] := 255] -> [chan[partner[2]] = 255 or (chan[partner[2]] % 20) != 2; dev := 1; partner[2] := 255; chan[2] := 255].
        // SLCO expression | chan[partner[2]] = 255 or (chan[partner[2]] % 20) != 2.
        if(!(t_tpickup_1_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 1.
        range_check_assumption_t_1_s_2();
        dev = (1) & 0xff;
        // SLCO assignment | partner[2] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        range_check_assumption_t_1_s_3();
        c.partner[2] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | chan[2] := 255.
        //@ assert lock_requests[2] == 1; // Check c.chan[2].
        range_check_assumption_t_1_s_4();
        c.chan[2] = (255) & 0xff;
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[2]
        //@ assert lock_requests[2] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | (chan[2] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[2] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[2]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        return (c.chan[2] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_0_s_0_n_1() {
        if(dev == 0) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[2] / 20) = 1 and dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[2] / 20) == 1 && dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_0_s_0_n_2() {
        if(t_tconnected_0_s_0_n_0()) {
            if(t_tconnected_0_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[2] / 20) == 1 && dev == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[2] / 20) = 1 and dev = 0; dev := 1].
    private boolean execute_transition_tconnected_0() {
        // SLCO composite | [((chan[2]) / 20) = 1 and dev = 0; dev := 1] -> [(chan[2] / 20) = 1 and dev = 0; dev := 1].
        // SLCO expression | (chan[2] / 20) = 1 and dev = 0.
        if(!(t_tconnected_0_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_2();
        dev = (1) & 0xff;

        return true;
    }

    // SLCO expression wrapper | (chan[2] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[2] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_1_s_0_n_0() {
        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        return (c.chan[2] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_1_s_0_n_1() {
        if(dev == 1) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[2] / 20) = 1 and dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[2] / 20) == 1 && dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_1_s_0_n_2() {
        if(t_tconnected_1_s_0_n_0()) {
            if(t_tconnected_1_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[2] / 20) == 1 && dev == 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[2] / 20) = 1 and dev = 1; dev := 0].
    private boolean execute_transition_tconnected_1() {
        // SLCO composite | [((chan[2]) / 20) = 1 and dev = 1; dev := 0] -> [(chan[2] / 20) = 1 and dev = 1; dev := 0].
        // SLCO expression | (chan[2] / 20) = 1 and dev = 1.
        if(!(t_tconnected_1_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 0.
        range_check_assumption_t_1_s_2();
        dev = (0) & 0xff;

        return true;
    }

    // SLCO expression wrapper | (chan[2] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[2] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_2_s_0_n_0() {
        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        if((c.chan[2] / 20) == 0) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[2] / 20) == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[2] / 20) = 0; partner[2] := 255; chan[2] := 255].
    private boolean execute_transition_tconnected_2() {
        // SLCO composite | [((chan[2]) / 20) = 0; partner[2] := 255; chan[2] := 255] -> [(chan[2] / 20) = 0; partner[2] := 255; chan[2] := 255].
        // SLCO expression | (chan[2] / 20) = 0.
        if(!(t_tconnected_2_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[2] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        range_check_assumption_t_2_s_2();
        c.partner[2] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[2]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | chan[2] := 255.
        //@ assert lock_requests[1] == 1; // Check c.chan[2].
        range_check_assumption_t_2_s_3();
        c.chan[2] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[2]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state idle.
    private void exec_idle() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | idle -> dialing | [chan[2] = 255; dev := 0; chan[2] := (2 + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | idle -> qi | [chan[2] != 255; partner[2] := (chan[2] % 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state dialing.
    private void exec_dialing() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[2] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[2] := 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[2] := 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_2()) {
            return;
        }
        // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[2] := 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[2] := 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[2] := 4.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_5()) {
            return;
        }
        // [SEQ.END]
    }

    // SLCO expression wrapper | partner[2] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[2], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean d_calling_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[2].
        return c.partner[2] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state calling.
    private void exec_calling() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | calling -> busy | partner[2] = 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_0()) {
            return;
        }
        // SLCO expression | partner[2] = 4.
        if(d_calling_0_n_0()) {
            // [SEQ.START]
            // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[2] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_1()) {
                return;
            }
            // SLCO transition (p:0, id:2) | calling -> ringback | partner[2] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_2()) {
                return;
            }
            // [SEQ.END]
        }
        // SLCO transition (p:0, id:3) | calling -> busy | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] = 255; record[partner[2]] := 2].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | calling -> calling | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] != 255; record[partner[2]] := 2; partner[2] := callforwardbusy[partner[2]]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | calling -> oalert | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] = 255; record[partner[2]] := 2; chan[partner[2]] := (2 + 0 * 20); chan[2] := (partner[2] + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_5()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state busy.
    private void exec_busy() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[2] := 255; partner[2] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_busy_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state qi.
    private void exec_qi() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[2]] % 20) = 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[2]] % 20) != 2; partner[2] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state talert.
    private void exec_talert() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[2] = 255.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_0()) {
            return;
        }
        // [DET.START]
        // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[2]] % 20) = 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[2]] % 20) != 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state unobtainable.
    private void exec_unobtainable() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[2] := 255; partner[2] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_unobtainable_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state oalert.
    private void exec_oalert() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[2] % 20) != partner[2].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[2] % 20) = partner[2] and (chan[2] / 20) = 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[2] % 20) = partner[2] and (chan[2] / 20) = 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state errorstate.
    private void exec_errorstate() {
        // There are no transitions starting in state errorstate.
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state oconnected.
    private void exec_oconnected() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[2] := 255; chan[partner[2]] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oconnected_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state dveoringout.
    private void exec_dveoringout() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[2] := 255; partner[2] := ((partner[2] % 20) + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dveoringout_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state tpickup.
    private void exec_tpickup() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[2]] % 20) = 2 and (chan[partner[2]] / 20) = 0; dev := 0; chan[partner[2]] := (2 + 1 * 20); chan[2] := (partner[2] + 1 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[2]] = 255 or (chan[partner[2]] % 20) != 2; dev := 1; partner[2] := 255; chan[2] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state tconnected.
    private void exec_tconnected() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[2] / 20) = 1 and dev = 0; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[2] / 20) = 1 and dev = 1; dev := 0].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[2] / 20) = 0; partner[2] := 255; chan[2] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state ringback.
    private void exec_ringback() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[2] := 255; partner[2] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | ringback -> calling | [record[2] != 255; partner[2] := record[2]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_1()) {
            return;
        }
        // [SEQ.END]
    }
}

// <<< STATE_MACHINE.END (User_2)

// >>> STATE_MACHINE.START (User_3)

// VerCors verification instructions for SLCO state machine User_3.
class GlobalClass_User_3Thread {
    // The class the state machine is a part of.
    private final GlobalClass c;

    // Thread local variables.
    private int dev;
    private int mbit;
    // A list of lock requests. A value of 1 denotes that the given target is locked, and 0 implies no lock.
    private final int[] lock_requests;

    /*@
    // Ensure full access to the class members.
    ensures Perm(this.c, 1);

    // Require that the input class is a valid object.
    requires c != null;

    // Ensure that the appropriate starter values are assigned.
    ensures this.c == c;
    @*/
    GlobalClass_User_3Thread(GlobalClass c) {
        // Reference to the parent SLCO class.
        this.c = c;

        // Variable instantiations.
        dev = (char) 1;
        mbit = (char) 0;
        // Instantiate the lock requests array.
        lock_requests = new int[14];
    }

    // SLCO expression wrapper | chan[3] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[3] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [1: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_idle_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        if(c.chan[3] == 255) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[3] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | idle -> dialing | [chan[3] = 255; dev := 0; chan[3] := (3 + 0 * 20)].
    private boolean execute_transition_idle_0() {
        // SLCO composite | [chan[3] = 255; dev := 0; chan[3] := ((3) + (0) * 20)] -> [chan[3] = 255; dev := 0; chan[3] := (3 + 0 * 20)].
        // SLCO expression | chan[3] = 255.
        if(!(t_idle_0_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        dev = (0) & 0xff;
        // SLCO assignment | chan[3] := (3 + 0 * 20).
        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        range_check_assumption_t_0_s_3();
        c.chan[3] = ((3 + 0 * 20)) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | chan[3] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[3] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_idle_1_s_0_n_0() {
        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        if(c.chan[3] != 255) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[3] != 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | idle -> qi | [chan[3] != 255; partner[3] := (chan[3] % 20)].
    private boolean execute_transition_idle_1() {
        // SLCO composite | [chan[3] != 255; partner[3] := ((chan[3]) % 20)] -> [chan[3] != 255; partner[3] := (chan[3] % 20)].
        // SLCO expression | chan[3] != 255.
        if(!(t_idle_1_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[3] := (chan[3] % 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        range_check_assumption_t_1_s_2();
        c.partner[3] = ((Math.floorMod(c.chan[3], 20))) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | (chan[partner[3]] % 20) = 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[3]], 20)) == 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_qi_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[c.partner[3]]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[3]].
        if((Math.floorMod(c.chan[c.partner[3]], 20)) == 3) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[3]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[3]], 20)) == 3);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[3]] % 20) = 3.
    private boolean execute_transition_qi_0() {
        // SLCO expression | ((chan[partner[3]]) % 20) = 3 -> (chan[partner[3]] % 20) = 3.
        if(!(t_qi_0_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[3]] % 20) != 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[3]], 20)) != 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[partner[3]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_qi_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[3]].
        if((Math.floorMod(c.chan[c.partner[3]], 20)) != 3) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[3]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[3]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[3]], 20)) != 3);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[partner[3]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[3]] % 20) != 3; partner[3] := 255].
    private boolean execute_transition_qi_1() {
        // SLCO composite | [((chan[partner[3]]) % 20) != 3; partner[3] := 255] -> [(chan[partner[3]] % 20) != 3; partner[3] := 255].
        // SLCO expression | (chan[partner[3]] % 20) != 3.
        if(!(t_qi_1_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[3] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        range_check_assumption_t_1_s_2();
        c.partner[3] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[3] := 255].
    private boolean execute_transition_dialing_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [dev := 1; chan[3] := 255] -> [true; dev := 1; chan[3] := 255].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        dev = (1) & 0xff;
        // SLCO assignment | chan[3] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[0] == 1; // Verify lock activity.

        //@ assert lock_requests[0] == 1; // Check c.chan[3].
        range_check_assumption_t_0_s_4();
        c.chan[3] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.chan[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[3] := 0.
    private boolean execute_transition_dialing_1() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[3] := 0] -> partner[3] := 0.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[3].
        range_check_assumption_t_1_s_2();
        c.partner[3] = (0) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[3] := 1.
    private boolean execute_transition_dialing_2() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[3] := 1] -> partner[3] := 1.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[3].
        range_check_assumption_t_2_s_2();
        c.partner[3] = (1) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[3] := 2.
    private boolean execute_transition_dialing_3() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[3] := 2] -> partner[3] := 2.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[3].
        range_check_assumption_t_3_s_2();
        c.partner[3] = (2) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[3] := 3.
    private boolean execute_transition_dialing_4() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[3] := 3] -> partner[3] := 3.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[3].
        range_check_assumption_t_4_s_2();
        c.partner[3] = (3) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[3] := 4.
    private boolean execute_transition_dialing_5() {
        // (Superfluous) SLCO expression | true.

        // SLCO assignment | [partner[3] := 4] -> partner[3] := 4.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.partner[3].
        range_check_assumption_t_5_s_2();
        c.partner[3] = (4) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | partner[3] = 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] == 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_0_s_0_n_0() {
        lock_requests[5] = lock_requests[5] + 1; // Acquire c.callforwardbusy[0]
        //@ assert lock_requests[5] == 1; // Verify lock activity.
        lock_requests[6] = lock_requests[6] + 1; // Acquire c.callforwardbusy[1]
        //@ assert lock_requests[6] == 1; // Verify lock activity.
        lock_requests[7] = lock_requests[7] + 1; // Acquire c.callforwardbusy[2]
        //@ assert lock_requests[7] == 1; // Verify lock activity.
        lock_requests[8] = lock_requests[8] + 1; // Acquire c.callforwardbusy[3]
        //@ assert lock_requests[8] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.record[0]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.record[1]
        //@ assert lock_requests[2] == 1; // Verify lock activity.
        lock_requests[3] = lock_requests[3] + 1; // Acquire c.record[2]
        //@ assert lock_requests[3] == 1; // Verify lock activity.
        lock_requests[4] = lock_requests[4] + 1; // Acquire c.record[3]
        //@ assert lock_requests[4] == 1; // Verify lock activity.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        if(c.partner[3] == 3) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
            //@ assert lock_requests[3] == 0; // Verify lock activity.
            lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
            //@ assert lock_requests[4] == 0; // Verify lock activity.
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[3] == 3);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | calling -> busy | partner[3] = 3.
    private boolean execute_transition_calling_0() {
        // SLCO expression | partner[3] = 3.
        if(!(t_calling_0_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | partner[3] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        if(c.partner[3] == 4) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
            //@ assert lock_requests[3] == 0; // Verify lock activity.
            lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
            //@ assert lock_requests[4] == 0; // Verify lock activity.
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[3] == 4);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[3] = 4.
    private boolean execute_transition_calling_1() {
        // SLCO expression | partner[3] = 4.
        if(!(t_calling_1_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | partner[3] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_2_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        if(c.partner[3] == 4) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
            //@ assert lock_requests[3] == 0; // Verify lock activity.
            lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
            //@ assert lock_requests[4] == 0; // Verify lock activity.
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[3] == 4);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | calling -> ringback | partner[3] = 4.
    private boolean execute_transition_calling_2() {
        // SLCO expression | partner[3] = 4.
        if(!(t_calling_2_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | partner[3] != 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        return c.partner[3] != 3;
    }

    // SLCO expression wrapper | partner[3] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        return c.partner[3] != 4;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_2() {
        if(t_calling_3_s_0_n_0()) {
            if(t_calling_3_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        lock_requests[9] = lock_requests[9] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[9] == 1; // Verify lock activity.
        lock_requests[10] = lock_requests[10] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[10] == 1; // Verify lock activity.
        lock_requests[11] = lock_requests[11] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[11] == 1; // Verify lock activity.
        lock_requests[12] = lock_requests[12] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[12] == 1; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | chan[partner[3]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[3]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_3() {
        lock_requests[9] = lock_requests[9] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[9] == 1; // Verify lock activity.
        lock_requests[10] = lock_requests[10] + 1; // Acquire c.chan[0]
        //@ assert lock_requests[10] == 1; // Verify lock activity.
        lock_requests[11] = lock_requests[11] + 1; // Acquire c.chan[1]
        //@ assert lock_requests[11] == 1; // Verify lock activity.
        lock_requests[12] = lock_requests[12] + 1; // Acquire c.chan[2]
        //@ assert lock_requests[12] == 1; // Verify lock activity.
        lock_requests[13] = lock_requests[13] + 1; // Acquire c.chan[c.partner[3]]
        //@ assert lock_requests[13] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[13] == 1; // Check c.chan[c.partner[3]].
        if(c.chan[c.partner[3]] != 255) {
            lock_requests[13] = lock_requests[13] - 1; // Release c.chan[c.partner[3]]
            //@ assert lock_requests[13] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[13] = lock_requests[13] - 1; // Release c.chan[c.partner[3]]
        //@ assert lock_requests[13] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_4() {
        if(t_calling_3_s_0_n_2()) {
            if(t_calling_3_s_0_n_3()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | callforwardbusy[partner[3]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[3]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_5() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[5] == 1; // Check c.callforwardbusy[0].
        //@ assert lock_requests[6] == 1; // Check c.callforwardbusy[1].
        //@ assert lock_requests[7] == 1; // Check c.callforwardbusy[2].
        //@ assert lock_requests[8] == 1; // Check c.callforwardbusy[3].
        if(c.callforwardbusy[c.partner[3]] == 255) {
            lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
            //@ assert lock_requests[5] == 0; // Verify lock activity.
            lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
            //@ assert lock_requests[6] == 0; // Verify lock activity.
            lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
            //@ assert lock_requests[7] == 0; // Verify lock activity.
            lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
            //@ assert lock_requests[8] == 0; // Verify lock activity.
            lock_requests[9] = lock_requests[9] - 1; // Release c.chan[3]
            //@ assert lock_requests[9] == 0; // Verify lock activity.
            lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
            //@ assert lock_requests[10] == 0; // Verify lock activity.
            lock_requests[11] = lock_requests[11] - 1; // Release c.chan[1]
            //@ assert lock_requests[11] == 0; // Verify lock activity.
            lock_requests[12] = lock_requests[12] - 1; // Release c.chan[2]
            //@ assert lock_requests[12] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255 && c.callforwardbusy[c.partner[3]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_3_s_0_n_6() {
        if(t_calling_3_s_0_n_4()) {
            if(t_calling_3_s_0_n_5()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255 && c.callforwardbusy[c.partner[3]] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:3) | calling -> busy | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] = 255; record[partner[3]] := 3].
    private boolean execute_transition_calling_3() {
        // SLCO composite | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] = 255; record[partner[3]] := 3].
        // SLCO expression | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] = 255.
        if(!(t_calling_3_s_0_n_6())) {
            return false;
        }
        // SLCO assignment | record[partner[3]] := 3.
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.record[0].
        //@ assert lock_requests[2] == 1; // Check c.record[1].
        //@ assert lock_requests[3] == 1; // Check c.record[2].
        //@ assert lock_requests[4] == 1; // Check c.record[3].
        range_check_assumption_t_3_s_2();
        c.record[c.partner[3]] = (3) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | partner[3] != 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        if(c.partner[3] != 3) {
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[3] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        if(c.partner[3] != 4) {
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_2() {
        if(t_calling_4_s_0_n_0()) {
            if(t_calling_4_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | chan[partner[3]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[3]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_3() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[9] == 1; // Check c.chan[3].
        //@ assert lock_requests[10] == 1; // Check c.chan[0].
        //@ assert lock_requests[11] == 1; // Check c.chan[1].
        //@ assert lock_requests[12] == 1; // Check c.chan[2].
        if(c.chan[c.partner[3]] != 255) {
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_4() {
        if(t_calling_4_s_0_n_2()) {
            if(t_calling_4_s_0_n_3()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | callforwardbusy[partner[3]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[3]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_5() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[5] == 1; // Check c.callforwardbusy[0].
        //@ assert lock_requests[6] == 1; // Check c.callforwardbusy[1].
        //@ assert lock_requests[7] == 1; // Check c.callforwardbusy[2].
        //@ assert lock_requests[8] == 1; // Check c.callforwardbusy[3].
        if(c.callforwardbusy[c.partner[3]] != 255) {
            lock_requests[9] = lock_requests[9] - 1; // Release c.chan[3]
            //@ assert lock_requests[9] == 0; // Verify lock activity.
            lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
            //@ assert lock_requests[10] == 0; // Verify lock activity.
            lock_requests[11] = lock_requests[11] - 1; // Release c.chan[1]
            //@ assert lock_requests[11] == 0; // Verify lock activity.
            lock_requests[12] = lock_requests[12] - 1; // Release c.chan[2]
            //@ assert lock_requests[12] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255 && c.callforwardbusy[c.partner[3]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_calling_4_s_0_n_6() {
        if(t_calling_4_s_0_n_4()) {
            if(t_calling_4_s_0_n_5()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255 && c.callforwardbusy[c.partner[3]] != 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:4) | calling -> calling | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] != 255; record[partner[3]] := 3; partner[3] := callforwardbusy[partner[3]]].
    private boolean execute_transition_calling_4() {
        // SLCO composite | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] != 255; record[partner[3]] := 3; partner[3] := callforwardbusy[partner[3]]].
        // SLCO expression | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] != 255.
        if(!(t_calling_4_s_0_n_6())) {
            return false;
        }
        // SLCO assignment | record[partner[3]] := 3.
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.record[0].
        //@ assert lock_requests[2] == 1; // Check c.record[1].
        //@ assert lock_requests[3] == 1; // Check c.record[2].
        //@ assert lock_requests[4] == 1; // Check c.record[3].
        range_check_assumption_t_4_s_2();
        c.record[c.partner[3]] = (3) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        // SLCO assignment | partner[3] := callforwardbusy[partner[3]].
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[5] == 1; // Check c.callforwardbusy[0].
        //@ assert lock_requests[6] == 1; // Check c.callforwardbusy[1].
        //@ assert lock_requests[7] == 1; // Check c.callforwardbusy[2].
        //@ assert lock_requests[8] == 1; // Check c.callforwardbusy[3].
        range_check_assumption_t_4_s_3();
        c.partner[3] = (c.callforwardbusy[c.partner[3]]) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[5] = lock_requests[5] - 1; // Release c.callforwardbusy[0]
        //@ assert lock_requests[5] == 0; // Verify lock activity.
        lock_requests[6] = lock_requests[6] - 1; // Release c.callforwardbusy[1]
        //@ assert lock_requests[6] == 0; // Verify lock activity.
        lock_requests[7] = lock_requests[7] - 1; // Release c.callforwardbusy[2]
        //@ assert lock_requests[7] == 0; // Verify lock activity.
        lock_requests[8] = lock_requests[8] - 1; // Release c.callforwardbusy[3]
        //@ assert lock_requests[8] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | partner[3] != 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        if(c.partner[3] != 3) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[3]
        //@ assert lock_requests[9] == 0; // Verify lock activity.
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[1]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[2]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[3] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        if(c.partner[3] != 4) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[3]
        //@ assert lock_requests[9] == 0; // Verify lock activity.
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[1]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[2]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_2() {
        if(t_calling_5_s_0_n_0()) {
            if(t_calling_5_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    // SLCO expression wrapper | chan[partner[3]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[3]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_3() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[9] == 1; // Check c.chan[3].
        //@ assert lock_requests[10] == 1; // Check c.chan[0].
        //@ assert lock_requests[11] == 1; // Check c.chan[1].
        //@ assert lock_requests[12] == 1; // Check c.chan[2].
        if(c.chan[c.partner[3]] == 255) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[3]
        //@ assert lock_requests[9] == 0; // Verify lock activity.
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[1]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[2]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_calling_5_s_0_n_4() {
        if(t_calling_5_s_0_n_2()) {
            if(t_calling_5_s_0_n_3()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 9: chan[3], 10: chan[0], 11: chan[1], 12: chan[2]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 9 || _i == 10 || _i == 11 || _i == 12) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:5) | calling -> oalert | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] = 255; record[partner[3]] := 3; chan[partner[3]] := (3 + 0 * 20); chan[3] := (partner[3] + 0 * 20)].
    private boolean execute_transition_calling_5() {
        // SLCO composite | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] = 255; record[partner[3]] := 3; chan[partner[3]] := ((3) + (0) * 20); chan[3] := ((partner[3]) + (0) * 20)] -> [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] = 255; record[partner[3]] := 3; chan[partner[3]] := (3 + 0 * 20); chan[3] := (partner[3] + 0 * 20)].
        // SLCO expression | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] = 255.
        if(!(t_calling_5_s_0_n_4())) {
            return false;
        }
        // SLCO assignment | record[partner[3]] := 3.
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.record[0].
        //@ assert lock_requests[2] == 1; // Check c.record[1].
        //@ assert lock_requests[3] == 1; // Check c.record[2].
        //@ assert lock_requests[4] == 1; // Check c.record[3].
        range_check_assumption_t_5_s_2();
        c.record[c.partner[3]] = (3) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.record[0]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.record[1]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        lock_requests[3] = lock_requests[3] - 1; // Release c.record[2]
        //@ assert lock_requests[3] == 0; // Verify lock activity.
        lock_requests[4] = lock_requests[4] - 1; // Release c.record[3]
        //@ assert lock_requests[4] == 0; // Verify lock activity.
        // SLCO assignment | chan[partner[3]] := (3 + 0 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[9] == 1; // Check c.chan[3].
        //@ assert lock_requests[10] == 1; // Check c.chan[0].
        //@ assert lock_requests[11] == 1; // Check c.chan[1].
        //@ assert lock_requests[12] == 1; // Check c.chan[2].
        range_check_assumption_t_5_s_3();
        c.chan[c.partner[3]] = ((3 + 0 * 20)) & 0xff;
        lock_requests[10] = lock_requests[10] - 1; // Release c.chan[0]
        //@ assert lock_requests[10] == 0; // Verify lock activity.
        lock_requests[11] = lock_requests[11] - 1; // Release c.chan[1]
        //@ assert lock_requests[11] == 0; // Verify lock activity.
        lock_requests[12] = lock_requests[12] - 1; // Release c.chan[2]
        //@ assert lock_requests[12] == 0; // Verify lock activity.
        // SLCO assignment | chan[3] := (partner[3] + 0 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[9] == 1; // Check c.chan[3].
        range_check_assumption_t_5_s_4();
        c.chan[3] = ((c.partner[3] + 0 * 20)) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[9] = lock_requests[9] - 1; // Release c.chan[3]
        //@ assert lock_requests[9] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[3] := 255; partner[3] := 255; dev := 1].
    private boolean execute_transition_busy_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [chan[3] := 255; partner[3] := 255; dev := 1] -> [true; chan[3] := 255; partner[3] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | chan[3] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        range_check_assumption_t_0_s_3();
        c.chan[3] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | partner[3] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        range_check_assumption_t_0_s_4();
        c.partner[3] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        dev = (1) & 0xff;

        return true;
    }

    // SLCO expression wrapper | (chan[3] % 20) != partner[3].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[3], 20)) != c.partner[3]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        if((Math.floorMod(c.chan[3], 20)) != c.partner[3]) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[3], 20)) != c.partner[3]);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[3] % 20) != partner[3].
    private boolean execute_transition_oalert_0() {
        // SLCO expression | ((chan[3]) % 20) != partner[3] -> (chan[3] % 20) != partner[3].
        if(!(t_oalert_0_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[3] % 20) = partner[3].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[3], 20)) == c.partner[3]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        return (Math.floorMod(c.chan[3], 20)) == c.partner[3];
    }

    // SLCO expression wrapper | (chan[3] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[3] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_1_s_0_n_1() {
        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        if((c.chan[3] / 20) == 1) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[3] % 20) = partner[3] and (chan[3] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[3], 20)) == c.partner[3] && (c.chan[3] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_1_s_0_n_2() {
        if(t_oalert_1_s_0_n_0()) {
            if(t_oalert_1_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[3], 20)) == c.partner[3] && (c.chan[3] / 20) == 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[3] % 20) = partner[3] and (chan[3] / 20) = 1.
    private boolean execute_transition_oalert_1() {
        // SLCO expression | ((chan[3]) % 20) = partner[3] and ((chan[3]) / 20) = 1 -> (chan[3] % 20) = partner[3] and (chan[3] / 20) = 1.
        if(!(t_oalert_1_s_0_n_2())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[3] % 20) = partner[3].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[3], 20)) == c.partner[3]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [1: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_2_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        if((Math.floorMod(c.chan[3], 20)) == c.partner[3]) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | (chan[3] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[3] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_2_s_0_n_1() {
        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        if((c.chan[3] / 20) == 0) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | (chan[3] % 20) = partner[3] and (chan[3] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[3], 20)) == c.partner[3] && (c.chan[3] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_oalert_2_s_0_n_2() {
        if(t_oalert_2_s_0_n_0()) {
            if(t_oalert_2_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[3], 20)) == c.partner[3] && (c.chan[3] / 20) == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[3] % 20) = partner[3] and (chan[3] / 20) = 0.
    private boolean execute_transition_oalert_2() {
        // SLCO expression | ((chan[3]) % 20) = partner[3] and ((chan[3]) / 20) = 0 -> (chan[3] % 20) = partner[3] and (chan[3] / 20) = 0.
        if(!(t_oalert_2_s_0_n_2())) {
            return false;
        }

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[3] := 255; chan[partner[3]] := 255].
    private boolean execute_transition_oconnected_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [dev := 1; chan[3] := 255; chan[partner[3]] := 255] -> [true; dev := 1; chan[3] := 255; chan[partner[3]] := 255].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        dev = (1) & 0xff;
        // SLCO assignment | chan[3] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[c.partner[3]]
        //@ assert lock_requests[2] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        range_check_assumption_t_0_s_4();
        c.chan[3] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | chan[partner[3]] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[2] == 1; // Check c.chan[c.partner[3]].
        range_check_assumption_t_0_s_5();
        c.chan[c.partner[3]] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[c.partner[3]]
        //@ assert lock_requests[2] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[3] := 255; partner[3] := ((partner[3] % 20) + 0 * 20)].
    private boolean execute_transition_dveoringout_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [dev := 1; chan[3] := 255; partner[3] := ((((partner[3]) % 20)) + (0) * 20)] -> [true; dev := 1; chan[3] := 255; partner[3] := ((partner[3] % 20) + 0 * 20)].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        dev = (1) & 0xff;
        // SLCO assignment | chan[3] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        range_check_assumption_t_0_s_4();
        c.chan[3] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | partner[3] := ((partner[3] % 20) + 0 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        range_check_assumption_t_0_s_5();
        c.partner[3] = (((Math.floorMod(c.partner[3], 20)) + 0 * 20)) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[3] := 255; partner[3] := 255; dev := 1].
    private boolean execute_transition_unobtainable_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [chan[3] := 255; partner[3] := 255; dev := 1] -> [true; chan[3] := 255; partner[3] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | chan[3] := 255.
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        range_check_assumption_t_0_s_3();
        c.chan[3] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | partner[3] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        range_check_assumption_t_0_s_4();
        c.partner[3] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        dev = (1) & 0xff;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[3] := 255; partner[3] := 255; dev := 1].
    private boolean execute_transition_ringback_0() {
        // (Superfluous) SLCO expression | true.

        // SLCO composite | [chan[3] := 255; partner[3] := 255; dev := 1] -> [true; chan[3] := 255; partner[3] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        // SLCO assignment | chan[3] := 255.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[2] == 1; // Verify lock activity.

        //@ assert lock_requests[2] == 1; // Check c.chan[3].
        range_check_assumption_t_0_s_3();
        c.chan[3] = (255) & 0xff;
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[3]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        // SLCO assignment | partner[3] := 255.
        //@ assert lock_requests[1] == 1; // Check c.partner[3].
        range_check_assumption_t_0_s_4();
        c.partner[3] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        dev = (1) & 0xff;

        return true;
    }

    // SLCO expression wrapper | record[3] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.record[3] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: record[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_ringback_1_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.record[3]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.record[3].
        if(c.record[3] != 255) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.record[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.record[3] != 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | ringback -> calling | [record[3] != 255; partner[3] := record[3]].
    private boolean execute_transition_ringback_1() {
        // SLCO composite | [record[3] != 255; partner[3] := record[3]].
        // SLCO expression | record[3] != 255.
        if(!(t_ringback_1_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[3] := record[3].
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[1] == 1; // Verify lock activity.

        //@ assert lock_requests[0] == 1; // Check c.record[3].
        //@ assert lock_requests[1] == 1; // Check c.partner[3].
        range_check_assumption_t_1_s_2();
        c.partner[3] = (c.record[3]) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.record[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.partner[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | dev != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_talert_0_s_0_n_0() {
        return dev != 1;
    }

    // SLCO expression wrapper | chan[3] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[3] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_talert_0_s_0_n_1() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[c.partner[3]]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[2] == 1; // Verify lock activity.
        //@ assert lock_requests[2] == 1; // Check c.chan[3].
        if(c.chan[3] == 255) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[3]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            lock_requests[2] = lock_requests[2] - 1; // Release c.chan[3]
            //@ assert lock_requests[2] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[3]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | dev != 1 or chan[3] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1 || c.chan[3] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_talert_0_s_0_n_2() {
        if(t_talert_0_s_0_n_0()) {
            // Short-circuit fix trigger.
            return true;
        }
        if(t_talert_0_s_0_n_1()) {
            // Short-circuit fix trigger.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(dev != 1 || c.chan[3] == 255);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[3] = 255.
    private boolean execute_transition_talert_0() {
        // SLCO expression | dev != 1 or chan[3] = 255.
        if(!(t_talert_0_s_0_n_2())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[3]] % 20) = 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[3]], 20)) == 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[partner[3]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_talert_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[3]].
        if((Math.floorMod(c.chan[c.partner[3]], 20)) == 3) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[3]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[3]], 20)) == 3);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[partner[3]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[3]] % 20) = 3.
    private boolean execute_transition_talert_1() {
        // SLCO expression | ((chan[partner[3]]) % 20) = 3 -> (chan[partner[3]] % 20) = 3.
        if(!(t_talert_1_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[3]] % 20) != 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[3]], 20)) != 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[partner[3]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_talert_2_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[3]].
        if((Math.floorMod(c.chan[c.partner[3]], 20)) != 3) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[3]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[3]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[3]], 20)) != 3);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[partner[3]]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[3]] % 20) != 3.
    private boolean execute_transition_talert_2() {
        // SLCO expression | ((chan[partner[3]]) % 20) != 3 -> (chan[partner[3]] % 20) != 3.
        if(!(t_talert_2_s_0_n_0())) {
            return false;
        }

        return true;
    }

    // SLCO expression wrapper | (chan[partner[3]] % 20) = 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[3]], 20)) == 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]], 2: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]], 2: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[c.partner[3]]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        lock_requests[2] = lock_requests[2] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[2] == 1; // Verify lock activity.
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[3]].
        return (Math.floorMod(c.chan[c.partner[3]], 20)) == 3;
    }

    // SLCO expression wrapper | (chan[partner[3]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[c.partner[3]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[partner[3]], 2: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]], 2: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]], 2: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_0_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[3]].
        return (c.chan[c.partner[3]] / 20) == 0;
    }

    // SLCO expression wrapper | (chan[partner[3]] % 20) = 3 and (chan[partner[3]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[3]], 20)) == 3 && (c.chan[c.partner[3]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]], 2: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]], 2: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_0_s_0_n_2() {
        if(t_tpickup_0_s_0_n_0()) {
            if(t_tpickup_0_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[3]], 20)) == 3 && (c.chan[c.partner[3]] / 20) == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]], 2: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[3]] % 20) = 3 and (chan[partner[3]] / 20) = 0; dev := 0; chan[partner[3]] := (3 + 1 * 20); chan[3] := (partner[3] + 1 * 20)].
    private boolean execute_transition_tpickup_0() {
        // SLCO composite | [((chan[partner[3]]) % 20) = 3 and ((chan[partner[3]]) / 20) = 0; dev := 0; chan[partner[3]] := ((3) + (1) * 20); chan[3] := ((partner[3]) + (1) * 20)] -> [(chan[partner[3]] % 20) = 3 and (chan[partner[3]] / 20) = 0; dev := 0; chan[partner[3]] := (3 + 1 * 20); chan[3] := (partner[3] + 1 * 20)].
        // SLCO expression | (chan[partner[3]] % 20) = 3 and (chan[partner[3]] / 20) = 0.
        if(!(t_tpickup_0_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        dev = (0) & 0xff;
        // SLCO assignment | chan[partner[3]] := (3 + 1 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[3]].
        range_check_assumption_t_0_s_3();
        c.chan[c.partner[3]] = ((3 + 1 * 20)) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[3]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        // SLCO assignment | chan[3] := (partner[3] + 1 * 20).
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[2] == 1; // Check c.chan[3].
        range_check_assumption_t_0_s_4();
        c.chan[3] = ((c.partner[3] + 1 * 20)) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[3]
        //@ assert lock_requests[2] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | chan[partner[3]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[3]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[partner[3]], 2: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 2: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[partner[3]], 2: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_1_s_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[3]].
        if(c.chan[c.partner[3]] == 255) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[3]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[partner[3]] % 20) != 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[3]], 20)) != 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[partner[3]], 2: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 2: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_1_s_0_n_1() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        //@ assert lock_requests[1] == 1; // Check c.chan[c.partner[3]].
        if((Math.floorMod(c.chan[c.partner[3]], 20)) != 3) {
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[3]]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[c.partner[3]]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[3]
        //@ assert lock_requests[2] == 0; // Verify lock activity.
        return false;
    }

    // SLCO expression wrapper | chan[partner[3]] = 255 or (chan[partner[3]] % 20) != 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[3]] == 255 || (Math.floorMod(c.chan[c.partner[3]], 20)) != 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[partner[3]], 2: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 2: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_tpickup_1_s_0_n_2() {
        if(t_tpickup_1_s_0_n_0()) {
            // Short-circuit fix trigger.
            return true;
        }
        if(t_tpickup_1_s_0_n_1()) {
            // Short-circuit fix trigger.
            return true;
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[c.partner[3]] == 255 || (Math.floorMod(c.chan[c.partner[3]], 20)) != 3);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[partner[3]], 2: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[3]] = 255 or (chan[partner[3]] % 20) != 3; dev := 1; partner[3] := 255; chan[3] := 255].
    private boolean execute_transition_tpickup_1() {
        // SLCO composite | [chan[partner[3]] = 255 or ((chan[partner[3]]) % 20) != 3; dev := 1; partner[3] := 255; chan[3] := 255] -> [chan[partner[3]] = 255 or (chan[partner[3]] % 20) != 3; dev := 1; partner[3] := 255; chan[3] := 255].
        // SLCO expression | chan[partner[3]] = 255 or (chan[partner[3]] % 20) != 3.
        if(!(t_tpickup_1_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 1.
        range_check_assumption_t_1_s_2();
        dev = (1) & 0xff;
        // SLCO assignment | partner[3] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        range_check_assumption_t_1_s_3();
        c.partner[3] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | chan[3] := 255.
        //@ assert lock_requests[2] == 1; // Check c.chan[3].
        range_check_assumption_t_1_s_4();
        c.chan[3] = (255) & 0xff;
        lock_requests[2] = lock_requests[2] - 1; // Release c.chan[3]
        //@ assert lock_requests[2] == 0; // Verify lock activity.

        return true;
    }

    // SLCO expression wrapper | (chan[3] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[3] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_0_s_0_n_0() {
        lock_requests[0] = lock_requests[0] + 1; // Acquire c.partner[3]
        //@ assert lock_requests[0] == 1; // Verify lock activity.
        lock_requests[1] = lock_requests[1] + 1; // Acquire c.chan[3]
        //@ assert lock_requests[1] == 1; // Verify lock activity.
        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        return (c.chan[3] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_0_s_0_n_1() {
        if(dev == 0) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[3] / 20) = 1 and dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[3] / 20) == 1 && dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_0_s_0_n_2() {
        if(t_tconnected_0_s_0_n_0()) {
            if(t_tconnected_0_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[3] / 20) == 1 && dev == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[3] / 20) = 1 and dev = 0; dev := 1].
    private boolean execute_transition_tconnected_0() {
        // SLCO composite | [((chan[3]) / 20) = 1 and dev = 0; dev := 1] -> [(chan[3] / 20) = 1 and dev = 0; dev := 1].
        // SLCO expression | (chan[3] / 20) = 1 and dev = 0.
        if(!(t_tconnected_0_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_2();
        dev = (1) & 0xff;

        return true;
    }

    // SLCO expression wrapper | (chan[3] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[3] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_1_s_0_n_0() {
        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        return (c.chan[3] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_1_s_0_n_1() {
        if(dev == 1) {
            lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
            //@ assert lock_requests[0] == 0; // Verify lock activity.
            lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
            //@ assert lock_requests[1] == 0; // Verify lock activity.
            return true;
        }
        return false;
    }

    // SLCO expression wrapper | (chan[3] / 20) = 1 and dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[3] / 20) == 1 && dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_1_s_0_n_2() {
        if(t_tconnected_1_s_0_n_0()) {
            if(t_tconnected_1_s_0_n_1()) {
                // Short-circuit fix trigger.
                return true;
            }
        }
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[3] / 20) == 1 && dev == 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[3] / 20) = 1 and dev = 1; dev := 0].
    private boolean execute_transition_tconnected_1() {
        // SLCO composite | [((chan[3]) / 20) = 1 and dev = 1; dev := 0] -> [(chan[3] / 20) = 1 and dev = 1; dev := 0].
        // SLCO expression | (chan[3] / 20) = 1 and dev = 1.
        if(!(t_tconnected_1_s_0_n_2())) {
            return false;
        }
        // SLCO assignment | dev := 0.
        range_check_assumption_t_1_s_2();
        dev = (0) & 0xff;

        return true;
    }

    // SLCO expression wrapper | (chan[3] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[3] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: chan[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    private boolean t_tconnected_2_s_0_n_0() {
        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        if((c.chan[3] / 20) == 0) {
            return true;
        }
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.
        return false;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[3] / 20) == 0);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: chan[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the success exit of the function.
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active in the failure exit of the function.
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[3] / 20) = 0; partner[3] := 255; chan[3] := 255].
    private boolean execute_transition_tconnected_2() {
        // SLCO composite | [((chan[3]) / 20) = 0; partner[3] := 255; chan[3] := 255] -> [(chan[3] / 20) = 0; partner[3] := 255; chan[3] := 255].
        // SLCO expression | (chan[3] / 20) = 0.
        if(!(t_tconnected_2_s_0_n_0())) {
            return false;
        }
        // SLCO assignment | partner[3] := 255.
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        range_check_assumption_t_2_s_2();
        c.partner[3] = (255) & 0xff;
        lock_requests[0] = lock_requests[0] - 1; // Release c.partner[3]
        //@ assert lock_requests[0] == 0; // Verify lock activity.
        // SLCO assignment | chan[3] := 255.
        //@ assert lock_requests[1] == 1; // Check c.chan[3].
        range_check_assumption_t_2_s_3();
        c.chan[3] = (255) & 0xff;
        lock_requests[1] = lock_requests[1] - 1; // Release c.chan[3]
        //@ assert lock_requests[1] == 0; // Verify lock activity.

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state idle.
    private void exec_idle() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | idle -> dialing | [chan[3] = 255; dev := 0; chan[3] := (3 + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | idle -> qi | [chan[3] != 255; partner[3] := (chan[3] % 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state dialing.
    private void exec_dialing() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[3] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[3] := 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[3] := 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_2()) {
            return;
        }
        // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[3] := 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[3] := 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[3] := 4.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_5()) {
            return;
        }
        // [SEQ.END]
    }

    // SLCO expression wrapper | partner[3] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that the following locks are active prior to calling the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the success exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures \result ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);

    // Ensure that that the following locks are active in the failure exit of the the function:
    // - [0: partner[3], 1: record[0], 2: record[1], 3: record[2], 4: record[3], 5: callforwardbusy[0], 6: callforwardbusy[1], 7: callforwardbusy[2], 8: callforwardbusy[3]]
    ensures !(\result) ==> (\forall* int _i; 0 <= _i && _i < lock_requests.length; (_i == 0 || _i == 1 || _i == 2 || _i == 3 || _i == 4 || _i == 5 || _i == 6 || _i == 7 || _i == 8) ? lock_requests[_i] == 1 : lock_requests[_i] == 0);
    @*/
    private boolean d_calling_0_n_0() {
        //@ assert lock_requests[0] == 1; // Check c.partner[3].
        return c.partner[3] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state calling.
    private void exec_calling() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | calling -> busy | partner[3] = 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_0()) {
            return;
        }
        // SLCO expression | partner[3] = 4.
        if(d_calling_0_n_0()) {
            // [SEQ.START]
            // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[3] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_1()) {
                return;
            }
            // SLCO transition (p:0, id:2) | calling -> ringback | partner[3] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_2()) {
                return;
            }
            // [SEQ.END]
        }
        // SLCO transition (p:0, id:3) | calling -> busy | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] = 255; record[partner[3]] := 3].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | calling -> calling | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] != 255; record[partner[3]] := 3; partner[3] := callforwardbusy[partner[3]]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | calling -> oalert | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] = 255; record[partner[3]] := 3; chan[partner[3]] := (3 + 0 * 20); chan[3] := (partner[3] + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_5()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state busy.
    private void exec_busy() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[3] := 255; partner[3] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_busy_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state qi.
    private void exec_qi() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[3]] % 20) = 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[3]] % 20) != 3; partner[3] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state talert.
    private void exec_talert() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[3] = 255.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_0()) {
            return;
        }
        // [DET.START]
        // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[3]] % 20) = 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[3]] % 20) != 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state unobtainable.
    private void exec_unobtainable() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[3] := 255; partner[3] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_unobtainable_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state oalert.
    private void exec_oalert() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[3] % 20) != partner[3].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[3] % 20) = partner[3] and (chan[3] / 20) = 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[3] % 20) = partner[3] and (chan[3] / 20) = 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state errorstate.
    private void exec_errorstate() {
        // There are no transitions starting in state errorstate.
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state oconnected.
    private void exec_oconnected() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[3] := 255; chan[partner[3]] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oconnected_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state dveoringout.
    private void exec_dveoringout() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[3] := 255; partner[3] := ((partner[3] % 20) + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dveoringout_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state tpickup.
    private void exec_tpickup() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[3]] % 20) = 3 and (chan[partner[3]] / 20) = 0; dev := 0; chan[partner[3]] := (3 + 1 * 20); chan[3] := (partner[3] + 1 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[3]] = 255 or (chan[partner[3]] % 20) != 3; dev := 1; partner[3] := 255; chan[3] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state tconnected.
    private void exec_tconnected() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[3] / 20) = 1 and dev = 0; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[3] / 20) = 1 and dev = 1; dev := 0].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[3] / 20) = 0; partner[3] := 255; chan[3] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure full permission over the lock request variable.
    context Perm(lock_requests, 1);

    // Require and ensure that the lock request array is of the correct length.
    context lock_requests != null && lock_requests.length == 14;

    // Require and ensure full permission over all lock request variable indices.
    context Perm(lock_requests[*], 1);

    // Require that that no lock requests are active prior to calling the function.
    requires (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);

    // Ensure that that no lock requests are active when the function terminates.
    ensures (\forall* int _i; 0 <= _i && _i < lock_requests.length; lock_requests[_i] == 0);
    @*/
    // Attempt to fire a transition starting in state ringback.
    private void exec_ringback() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[3] := 255; partner[3] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | ringback -> calling | [record[3] != 255; partner[3] := record[3]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_1()) {
            return;
        }
        // [SEQ.END]
    }
}

// <<< STATE_MACHINE.END (User_3)

// << CLASS.END (GlobalClass)

// < MODEL.END (Telephony)