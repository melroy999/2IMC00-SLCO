// > MODEL.START (Telephony)

// >> CLASS.START (GlobalClass)

// VerCors verification instructions for SLCO class GlobalClass.
class GlobalClass {
    // Class variables.
    private final int[] chan;
    private final int[] partner;
    private final int[] callforwardbusy;
    private final int[] record;

    /*@
    // Ensure full access to the class members.
    ensures Perm(this.chan, 1);
    ensures Perm(this.partner, 1);
    ensures Perm(this.callforwardbusy, 1);
    ensures Perm(this.record, 1);

    // Require that the given values are not null.
    requires chan != null;
    requires partner != null;
    requires callforwardbusy != null;
    requires record != null;

    // Ensure that the right values are assigned.
    ensures this.chan == chan;
    ensures this.partner == partner;
    ensures this.callforwardbusy == callforwardbusy;
    ensures this.record == record;
    @*/
    GlobalClass(int[] chan, int[] partner, int[] callforwardbusy, int[] record) {
        // Instantiate the class variables.
        this.chan = chan;
        this.partner = partner;
        this.callforwardbusy = callforwardbusy;
        this.record = record;
    }
}

// >>> STATE_MACHINE.START (User_0)

// VerCors verification instructions for SLCO state machine User_0.
class GlobalClass_User_0Thread {
    // The class the state machine is a part of.
    private final GlobalClass c;

    // Thread local variables.
    private int dev;
    private int mbit;

    /*@
    // Ensure full access to the class members.
    ensures Perm(this.c, 1);

    // Require that the input class is a valid object.
    requires c != null;

    // Ensure that the appropriate starter values are assigned.
    ensures this.c == c;
    @*/
    GlobalClass_User_0Thread(GlobalClass c) {
        // Reference to the parent SLCO class.
        this.c = c;

        // Variable instantiations.
        dev = (char) 1;
        mbit = (char) 0;
    }

    // SLCO expression wrapper | chan[0] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[0] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_idle_0_s_0_n_0() {
        return c.chan[0] == 255;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    pure int value_idle_0_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[0] == 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_idle_0_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | idle -> dialing | [chan[0] = 255; dev := 0; chan[0] := (0 + 0 * 20)].
    private boolean execute_transition_idle_0() {
        // SLCO composite | [chan[0] = 255; dev := 0; chan[0] := ((0) + (0) * 20)] -> [chan[0] = 255; dev := 0; chan[0] := (0 + 0 * 20)].
        // SLCO expression | chan[0] = 255.
        //@ ghost _guard = c.chan[0] == 255;
        if(!(t_idle_0_s_0_n_0())) {
            //@ assert !(c.chan[0] == 255);
            return false;
        }
        //@ assert c.chan[0] == 255;
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        //@ ghost _rhs_0 = 0;
        dev = (0) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[0] := (0 + 0 * 20).
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_1 = (0 + 0 * 20);
        //@ ghost _index_1 = 0;
        c.chan[0] = ((0 + 0 * 20)) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;

        return true;
    }

    // SLCO expression wrapper | chan[0] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[0] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_idle_1_s_0_n_0() {
        return c.chan[0] != 255;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    pure int value_idle_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[0] != 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_idle_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | idle -> qi | [chan[0] != 255; partner[0] := (chan[0] % 20)].
    private boolean execute_transition_idle_1() {
        // SLCO composite | [chan[0] != 255; partner[0] := ((chan[0]) % 20)] -> [chan[0] != 255; partner[0] := (chan[0] % 20)].
        // SLCO expression | chan[0] != 255.
        //@ ghost _guard = c.chan[0] != 255;
        if(!(t_idle_1_s_0_n_0())) {
            //@ assert !(c.chan[0] != 255);
            return false;
        }
        //@ assert c.chan[0] != 255;
        // SLCO assignment | partner[0] := (chan[0] % 20).
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = (Math.floorMod(c.chan[0], 20));
        //@ ghost _index_0 = 0;
        c.partner[0] = ((Math.floorMod(c.chan[0], 20))) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[0]] % 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[0]], 20)) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_qi_0_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[0]], 20)) == 0;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[0]], 20)) == 0);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[0]] % 20) = 0.
    private boolean execute_transition_qi_0() {
        // SLCO expression | ((chan[partner[0]]) % 20) = 0 -> (chan[partner[0]] % 20) = 0.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[0]], 20)) == 0;
        if(!(t_qi_0_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[0]], 20)) == 0);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[0]], 20)) == 0;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[0]] % 20) != 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[0]], 20)) != 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_qi_1_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[0]], 20)) != 0;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    pure int value_qi_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[0]], 20)) != 0);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_qi_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[0]] % 20) != 0; partner[0] := 255].
    private boolean execute_transition_qi_1() {
        // SLCO composite | [((chan[partner[0]]) % 20) != 0; partner[0] := 255] -> [(chan[partner[0]] % 20) != 0; partner[0] := 255].
        // SLCO expression | (chan[partner[0]] % 20) != 0.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[0]], 20)) != 0;
        if(!(t_qi_1_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[0]], 20)) != 0);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[0]], 20)) != 0;
        // SLCO assignment | partner[0] := 255.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 0;
        c.partner[0] = (255) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_dialing_0_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_dialing_0_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[0] := 255].
    private boolean execute_transition_dialing_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [dev := 1; chan[0] := 255] -> [true; dev := 1; chan[0] := 255].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[0] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 0;
        c.chan[0] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        
    }

    /*@
    pure int value_dialing_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[0] := 0.
    private boolean execute_transition_dialing_1() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[0] := 0] -> partner[0] := 0.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 0;
        //@ ghost _index_0 = 0;
        c.partner[0] = (0) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        
    }

    /*@
    pure int value_dialing_2_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_2_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[0] := 1.
    private boolean execute_transition_dialing_2() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[0] := 1] -> partner[0] := 1.
        range_check_assumption_t_2_s_2();
        //@ ghost _rhs_0 = 1;
        //@ ghost _index_0 = 0;
        c.partner[0] = (1) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        
    }

    /*@
    pure int value_dialing_3_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_3_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[0] := 2.
    private boolean execute_transition_dialing_3() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[0] := 2] -> partner[0] := 2.
        range_check_assumption_t_3_s_2();
        //@ ghost _rhs_0 = 2;
        //@ ghost _index_0 = 0;
        c.partner[0] = (2) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        
    }

    /*@
    pure int value_dialing_4_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_4_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[0] := 3.
    private boolean execute_transition_dialing_4() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[0] := 3] -> partner[0] := 3.
        range_check_assumption_t_4_s_2();
        //@ ghost _rhs_0 = 3;
        //@ ghost _index_0 = 0;
        c.partner[0] = (3) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        
    }

    /*@
    pure int value_dialing_5_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_5_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[0] := 4.
    private boolean execute_transition_dialing_5() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[0] := 4] -> partner[0] := 4.
        range_check_assumption_t_5_s_2();
        //@ ghost _rhs_0 = 4;
        //@ ghost _index_0 = 0;
        c.partner[0] = (4) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | partner[0] = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_0_s_0_n_0() {
        return c.partner[0] == 0;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[0] == 0);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | calling -> busy | partner[0] = 0.
    private boolean execute_transition_calling_0() {
        // SLCO expression | partner[0] = 0.
        //@ ghost _guard = c.partner[0] == 0;
        if(!(t_calling_0_s_0_n_0())) {
            //@ assert !(c.partner[0] == 0);
            return false;
        }
        //@ assert c.partner[0] == 0;

        return true;
    }

    // SLCO expression wrapper | partner[0] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_1_s_0_n_0() {
        return c.partner[0] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[0] == 4);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[0] = 4.
    private boolean execute_transition_calling_1() {
        // SLCO expression | partner[0] = 4.
        //@ ghost _guard = c.partner[0] == 4;
        if(!(t_calling_1_s_0_n_0())) {
            //@ assert !(c.partner[0] == 4);
            return false;
        }
        //@ assert c.partner[0] == 4;

        return true;
    }

    // SLCO expression wrapper | partner[0] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_2_s_0_n_0() {
        return c.partner[0] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[0] == 4);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | calling -> ringback | partner[0] = 4.
    private boolean execute_transition_calling_2() {
        // SLCO expression | partner[0] = 4.
        //@ ghost _guard = c.partner[0] == 4;
        if(!(t_calling_2_s_0_n_0())) {
            //@ assert !(c.partner[0] == 4);
            return false;
        }
        //@ assert c.partner[0] == 4;

        return true;
    }

    // SLCO expression wrapper | partner[0] != 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_0() {
        return c.partner[0] != 0;
    }

    // SLCO expression wrapper | partner[0] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_1() {
        return c.partner[0] != 4;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_2() {
        return t_calling_3_s_0_n_0() && t_calling_3_s_0_n_1();
    }

    // SLCO expression wrapper | chan[partner[0]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[0]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_3() {
        return c.chan[c.partner[0]] != 255;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_4() {
        return t_calling_3_s_0_n_2() && t_calling_3_s_0_n_3();
    }

    // SLCO expression wrapper | callforwardbusy[partner[0]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[0]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_5() {
        return c.callforwardbusy[c.partner[0]] == 255;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255 && c.callforwardbusy[c.partner[0]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_6() {
        return t_calling_3_s_0_n_4() && t_calling_3_s_0_n_5();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    pure int value_calling_3_record(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255 && c.callforwardbusy[c.partner[0]] == 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == value_calling_3_record(_i, _index_0, _rhs_0, \old(c.record[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:3) | calling -> busy | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] = 255; record[partner[0]] := 0].
    private boolean execute_transition_calling_3() {
        // SLCO composite | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] = 255; record[partner[0]] := 0].
        // SLCO expression | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] = 255.
        //@ ghost _guard = c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255 && c.callforwardbusy[c.partner[0]] == 255;
        if(!(t_calling_3_s_0_n_6())) {
            //@ assert !(c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255 && c.callforwardbusy[c.partner[0]] == 255);
            return false;
        }
        //@ assert c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255 && c.callforwardbusy[c.partner[0]] == 255;
        // SLCO assignment | record[partner[0]] := 0.
        range_check_assumption_t_3_s_2();
        //@ ghost _rhs_0 = 0;
        //@ ghost _index_0 = c.partner[0];
        c.record[c.partner[0]] = (0) & 0xff;
        //@ assert c.record[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | partner[0] != 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_0() {
        return c.partner[0] != 0;
    }

    // SLCO expression wrapper | partner[0] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_1() {
        return c.partner[0] != 4;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_2() {
        return t_calling_4_s_0_n_0() && t_calling_4_s_0_n_1();
    }

    // SLCO expression wrapper | chan[partner[0]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[0]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_3() {
        return c.chan[c.partner[0]] != 255;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_4() {
        return t_calling_4_s_0_n_2() && t_calling_4_s_0_n_3();
    }

    // SLCO expression wrapper | callforwardbusy[partner[0]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[0]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_5() {
        return c.callforwardbusy[c.partner[0]] != 255;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255 && c.callforwardbusy[c.partner[0]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_6() {
        return t_calling_4_s_0_n_4() && t_calling_4_s_0_n_5();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    pure int value_calling_4_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    pure int value_calling_4_record(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255 && c.callforwardbusy[c.partner[0]] != 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_calling_4_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == value_calling_4_record(_i, _index_0, _rhs_0, \old(c.record[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:4) | calling -> calling | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] != 255; record[partner[0]] := 0; partner[0] := callforwardbusy[partner[0]]].
    private boolean execute_transition_calling_4() {
        // SLCO composite | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] != 255; record[partner[0]] := 0; partner[0] := callforwardbusy[partner[0]]].
        // SLCO expression | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] != 255.
        //@ ghost _guard = c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255 && c.callforwardbusy[c.partner[0]] != 255;
        if(!(t_calling_4_s_0_n_6())) {
            //@ assert !(c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255 && c.callforwardbusy[c.partner[0]] != 255);
            return false;
        }
        //@ assert c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] != 255 && c.callforwardbusy[c.partner[0]] != 255;
        // SLCO assignment | record[partner[0]] := 0.
        range_check_assumption_t_4_s_2();
        //@ ghost _rhs_0 = 0;
        //@ ghost _index_0 = c.partner[0];
        c.record[c.partner[0]] = (0) & 0xff;
        //@ assert c.record[_index_0] == _rhs_0;
        // SLCO assignment | partner[0] := callforwardbusy[partner[0]].
        range_check_assumption_t_4_s_3();
        //@ ghost _rhs_1 = c.callforwardbusy[c.partner[0]];
        //@ ghost _index_1 = 0;
        c.partner[0] = (c.callforwardbusy[c.partner[0]]) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;

        return true;
    }

    // SLCO expression wrapper | partner[0] != 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_0() {
        return c.partner[0] != 0;
    }

    // SLCO expression wrapper | partner[0] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_1() {
        return c.partner[0] != 4;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_2() {
        return t_calling_5_s_0_n_0() && t_calling_5_s_0_n_1();
    }

    // SLCO expression wrapper | chan[partner[0]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[0]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_3() {
        return c.chan[c.partner[0]] == 255;
    }

    // SLCO expression wrapper | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_4() {
        return t_calling_5_s_0_n_2() && t_calling_5_s_0_n_3();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    pure int value_calling_5_chan(int _i, int _index_1, int _rhs_1, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : ((_i == _index_1) ? _rhs_1 : v_old);
    pure int value_calling_5_record(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] == 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_calling_5_chan(_i, _index_1, _rhs_1, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == value_calling_5_record(_i, _index_0, _rhs_0, \old(c.record[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:5) | calling -> oalert | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] = 255; record[partner[0]] := 0; chan[partner[0]] := (0 + 0 * 20); chan[0] := (partner[0] + 0 * 20)].
    private boolean execute_transition_calling_5() {
        // SLCO composite | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] = 255; record[partner[0]] := 0; chan[partner[0]] := ((0) + (0) * 20); chan[0] := ((partner[0]) + (0) * 20)] -> [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] = 255; record[partner[0]] := 0; chan[partner[0]] := (0 + 0 * 20); chan[0] := (partner[0] + 0 * 20)].
        // SLCO expression | partner[0] != 0 and partner[0] != 4 and chan[partner[0]] = 255.
        //@ ghost _guard = c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] == 255;
        if(!(t_calling_5_s_0_n_4())) {
            //@ assert !(c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] == 255);
            return false;
        }
        //@ assert c.partner[0] != 0 && c.partner[0] != 4 && c.chan[c.partner[0]] == 255;
        // SLCO assignment | record[partner[0]] := 0.
        range_check_assumption_t_5_s_2();
        //@ ghost _rhs_0 = 0;
        //@ ghost _index_0 = c.partner[0];
        c.record[c.partner[0]] = (0) & 0xff;
        //@ assert c.record[_index_0] == _rhs_0;
        // SLCO assignment | chan[partner[0]] := (0 + 0 * 20).
        range_check_assumption_t_5_s_3();
        //@ ghost _rhs_1 = (0 + 0 * 20);
        //@ ghost _index_1 = c.partner[0];
        c.chan[c.partner[0]] = ((0 + 0 * 20)) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | chan[0] := (partner[0] + 0 * 20).
        range_check_assumption_t_5_s_4();
        //@ ghost _rhs_2 = (c.partner[0] + 0 * 20);
        //@ ghost _index_2 = 0;
        c.chan[0] = ((c.partner[0] + 0 * 20)) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_busy_0_chan(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    pure int value_busy_0_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_busy_0_chan(_i, _index_0, _rhs_0, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_busy_0_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_2);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[0] := 255; partner[0] := 255; dev := 1].
    private boolean execute_transition_busy_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [chan[0] := 255; partner[0] := 255; dev := 1] -> [true; chan[0] := 255; partner[0] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | chan[0] := 255.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 0;
        c.chan[0] = (255) & 0xff;
        //@ assert c.chan[_index_0] == _rhs_0;
        // SLCO assignment | partner[0] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 0;
        c.partner[0] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | (chan[0] % 20) != partner[0].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[0], 20)) != c.partner[0]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_0_s_0_n_0() {
        return (Math.floorMod(c.chan[0], 20)) != c.partner[0];
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[0], 20)) != c.partner[0]);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[0] % 20) != partner[0].
    private boolean execute_transition_oalert_0() {
        // SLCO expression | ((chan[0]) % 20) != partner[0] -> (chan[0] % 20) != partner[0].
        //@ ghost _guard = (Math.floorMod(c.chan[0], 20)) != c.partner[0];
        if(!(t_oalert_0_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[0], 20)) != c.partner[0]);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[0], 20)) != c.partner[0];

        return true;
    }

    // SLCO expression wrapper | (chan[0] % 20) = partner[0].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[0], 20)) == c.partner[0]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_1_s_0_n_0() {
        return (Math.floorMod(c.chan[0], 20)) == c.partner[0];
    }

    // SLCO expression wrapper | (chan[0] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[0] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_1_s_0_n_1() {
        return (c.chan[0] / 20) == 1;
    }

    // SLCO expression wrapper | (chan[0] % 20) = partner[0] and (chan[0] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[0], 20)) == c.partner[0] && (c.chan[0] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_1_s_0_n_2() {
        return t_oalert_1_s_0_n_0() && t_oalert_1_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[0], 20)) == c.partner[0] && (c.chan[0] / 20) == 1);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[0] % 20) = partner[0] and (chan[0] / 20) = 1.
    private boolean execute_transition_oalert_1() {
        // SLCO expression | ((chan[0]) % 20) = partner[0] and ((chan[0]) / 20) = 1 -> (chan[0] % 20) = partner[0] and (chan[0] / 20) = 1.
        //@ ghost _guard = (Math.floorMod(c.chan[0], 20)) == c.partner[0] && (c.chan[0] / 20) == 1;
        if(!(t_oalert_1_s_0_n_2())) {
            //@ assert !((Math.floorMod(c.chan[0], 20)) == c.partner[0] && (c.chan[0] / 20) == 1);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[0], 20)) == c.partner[0] && (c.chan[0] / 20) == 1;

        return true;
    }

    // SLCO expression wrapper | (chan[0] % 20) = partner[0].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[0], 20)) == c.partner[0]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_2_s_0_n_0() {
        return (Math.floorMod(c.chan[0], 20)) == c.partner[0];
    }

    // SLCO expression wrapper | (chan[0] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[0] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_2_s_0_n_1() {
        return (c.chan[0] / 20) == 0;
    }

    // SLCO expression wrapper | (chan[0] % 20) = partner[0] and (chan[0] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[0], 20)) == c.partner[0] && (c.chan[0] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_2_s_0_n_2() {
        return t_oalert_2_s_0_n_0() && t_oalert_2_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[0], 20)) == c.partner[0] && (c.chan[0] / 20) == 0);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[0] % 20) = partner[0] and (chan[0] / 20) = 0.
    private boolean execute_transition_oalert_2() {
        // SLCO expression | ((chan[0]) % 20) = partner[0] and ((chan[0]) / 20) = 0 -> (chan[0] % 20) = partner[0] and (chan[0] / 20) = 0.
        //@ ghost _guard = (Math.floorMod(c.chan[0], 20)) == c.partner[0] && (c.chan[0] / 20) == 0;
        if(!(t_oalert_2_s_0_n_2())) {
            //@ assert !((Math.floorMod(c.chan[0], 20)) == c.partner[0] && (c.chan[0] / 20) == 0);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[0], 20)) == c.partner[0] && (c.chan[0] / 20) == 0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_oconnected_0_chan(int _i, int _index_1, int _rhs_1, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : ((_i == _index_1) ? _rhs_1 : v_old);
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_oconnected_0_chan(_i, _index_1, _rhs_1, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[0] := 255; chan[partner[0]] := 255].
    private boolean execute_transition_oconnected_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [dev := 1; chan[0] := 255; chan[partner[0]] := 255] -> [true; dev := 1; chan[0] := 255; chan[partner[0]] := 255].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[0] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 0;
        c.chan[0] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | chan[partner[0]] := 255.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 255;
        //@ ghost _index_2 = c.partner[0];
        c.chan[c.partner[0]] = (255) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_dveoringout_0_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    pure int value_dveoringout_0_partner(int _i, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_dveoringout_0_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dveoringout_0_partner(_i, _index_2, _rhs_2, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[0] := 255; partner[0] := ((partner[0] % 20) + 0 * 20)].
    private boolean execute_transition_dveoringout_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [dev := 1; chan[0] := 255; partner[0] := ((((partner[0]) % 20)) + (0) * 20)] -> [true; dev := 1; chan[0] := 255; partner[0] := ((partner[0] % 20) + 0 * 20)].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[0] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 0;
        c.chan[0] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | partner[0] := ((partner[0] % 20) + 0 * 20).
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = ((Math.floorMod(c.partner[0], 20)) + 0 * 20);
        //@ ghost _index_2 = 0;
        c.partner[0] = (((Math.floorMod(c.partner[0], 20)) + 0 * 20)) & 0xff;
        //@ assert c.partner[_index_2] == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_unobtainable_0_chan(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    pure int value_unobtainable_0_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_unobtainable_0_chan(_i, _index_0, _rhs_0, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_unobtainable_0_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_2);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[0] := 255; partner[0] := 255; dev := 1].
    private boolean execute_transition_unobtainable_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [chan[0] := 255; partner[0] := 255; dev := 1] -> [true; chan[0] := 255; partner[0] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | chan[0] := 255.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 0;
        c.chan[0] = (255) & 0xff;
        //@ assert c.chan[_index_0] == _rhs_0;
        // SLCO assignment | partner[0] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 0;
        c.partner[0] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_ringback_0_chan(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    pure int value_ringback_0_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_ringback_0_chan(_i, _index_0, _rhs_0, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_ringback_0_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_2);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[0] := 255; partner[0] := 255; dev := 1].
    private boolean execute_transition_ringback_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [chan[0] := 255; partner[0] := 255; dev := 1] -> [true; chan[0] := 255; partner[0] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | chan[0] := 255.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 0;
        c.chan[0] = (255) & 0xff;
        //@ assert c.chan[_index_0] == _rhs_0;
        // SLCO assignment | partner[0] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 0;
        c.partner[0] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | record[0] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.record[0] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_ringback_1_s_0_n_0() {
        return c.record[0] != 255;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    pure int value_ringback_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.record[0] != 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_ringback_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | ringback -> calling | [record[0] != 255; partner[0] := record[0]].
    private boolean execute_transition_ringback_1() {
        // SLCO composite | [record[0] != 255; partner[0] := record[0]].
        // SLCO expression | record[0] != 255.
        //@ ghost _guard = c.record[0] != 255;
        if(!(t_ringback_1_s_0_n_0())) {
            //@ assert !(c.record[0] != 255);
            return false;
        }
        //@ assert c.record[0] != 255;
        // SLCO assignment | partner[0] := record[0].
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = c.record[0];
        //@ ghost _index_0 = 0;
        c.partner[0] = (c.record[0]) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | dev != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_0_s_0_n_0() {
        return dev != 1;
    }

    // SLCO expression wrapper | chan[0] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[0] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_0_s_0_n_1() {
        return c.chan[0] == 255;
    }

    // SLCO expression wrapper | dev != 1 or chan[0] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1 || c.chan[0] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_0_s_0_n_2() {
        return t_talert_0_s_0_n_0() || t_talert_0_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(dev != 1 || c.chan[0] == 255);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[0] = 255.
    private boolean execute_transition_talert_0() {
        // SLCO expression | dev != 1 or chan[0] = 255.
        //@ ghost _guard = dev != 1 || c.chan[0] == 255;
        if(!(t_talert_0_s_0_n_2())) {
            //@ assert !(dev != 1 || c.chan[0] == 255);
            return false;
        }
        //@ assert dev != 1 || c.chan[0] == 255;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[0]] % 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[0]], 20)) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_1_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[0]], 20)) == 0;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[0]], 20)) == 0);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[0]] % 20) = 0.
    private boolean execute_transition_talert_1() {
        // SLCO expression | ((chan[partner[0]]) % 20) = 0 -> (chan[partner[0]] % 20) = 0.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[0]], 20)) == 0;
        if(!(t_talert_1_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[0]], 20)) == 0);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[0]], 20)) == 0;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[0]] % 20) != 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[0]], 20)) != 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_2_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[0]], 20)) != 0;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[0]], 20)) != 0);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[0]] % 20) != 0.
    private boolean execute_transition_talert_2() {
        // SLCO expression | ((chan[partner[0]]) % 20) != 0 -> (chan[partner[0]] % 20) != 0.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[0]], 20)) != 0;
        if(!(t_talert_2_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[0]], 20)) != 0);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[0]], 20)) != 0;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[0]] % 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[0]], 20)) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_0_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[0]], 20)) == 0;
    }

    // SLCO expression wrapper | (chan[partner[0]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[c.partner[0]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_0_s_0_n_1() {
        return (c.chan[c.partner[0]] / 20) == 0;
    }

    // SLCO expression wrapper | (chan[partner[0]] % 20) = 0 and (chan[partner[0]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[0]], 20)) == 0 && (c.chan[c.partner[0]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_0_s_0_n_2() {
        return t_tpickup_0_s_0_n_0() && t_tpickup_0_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    pure int value_tpickup_0_chan(int _i, int _index_1, int _rhs_1, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : ((_i == _index_1) ? _rhs_1 : v_old);
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[0]], 20)) == 0 && (c.chan[c.partner[0]] / 20) == 0);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_tpickup_0_chan(_i, _index_1, _rhs_1, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[0]] % 20) = 0 and (chan[partner[0]] / 20) = 0; dev := 0; chan[partner[0]] := (0 + 1 * 20); chan[0] := (partner[0] + 1 * 20)].
    private boolean execute_transition_tpickup_0() {
        // SLCO composite | [((chan[partner[0]]) % 20) = 0 and ((chan[partner[0]]) / 20) = 0; dev := 0; chan[partner[0]] := ((0) + (1) * 20); chan[0] := ((partner[0]) + (1) * 20)] -> [(chan[partner[0]] % 20) = 0 and (chan[partner[0]] / 20) = 0; dev := 0; chan[partner[0]] := (0 + 1 * 20); chan[0] := (partner[0] + 1 * 20)].
        // SLCO expression | (chan[partner[0]] % 20) = 0 and (chan[partner[0]] / 20) = 0.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[0]], 20)) == 0 && (c.chan[c.partner[0]] / 20) == 0;
        if(!(t_tpickup_0_s_0_n_2())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[0]], 20)) == 0 && (c.chan[c.partner[0]] / 20) == 0);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[0]], 20)) == 0 && (c.chan[c.partner[0]] / 20) == 0;
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        //@ ghost _rhs_0 = 0;
        dev = (0) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[partner[0]] := (0 + 1 * 20).
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_1 = (0 + 1 * 20);
        //@ ghost _index_1 = c.partner[0];
        c.chan[c.partner[0]] = ((0 + 1 * 20)) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | chan[0] := (partner[0] + 1 * 20).
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_2 = (c.partner[0] + 1 * 20);
        //@ ghost _index_2 = 0;
        c.chan[0] = ((c.partner[0] + 1 * 20)) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | chan[partner[0]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[0]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_1_s_0_n_0() {
        return c.chan[c.partner[0]] == 255;
    }

    // SLCO expression wrapper | (chan[partner[0]] % 20) != 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[0]], 20)) != 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_1_s_0_n_1() {
        return (Math.floorMod(c.chan[c.partner[0]], 20)) != 0;
    }

    // SLCO expression wrapper | chan[partner[0]] = 255 or (chan[partner[0]] % 20) != 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;
    context 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[0]] == 255 || (Math.floorMod(c.chan[c.partner[0]], 20)) != 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_1_s_0_n_2() {
        return t_tpickup_1_s_0_n_0() || t_tpickup_1_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;
    ensures 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
        //@ assume 0 <= c.partner[0] && c.partner[0] < 4;
    }

    /*@
    pure int value_tpickup_1_chan(int _i, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : v_old;
    pure int value_tpickup_1_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;
    requires 0 <= c.partner[0] && c.partner[0] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[c.partner[0]] == 255 || (Math.floorMod(c.chan[c.partner[0]], 20)) != 0);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_tpickup_1_chan(_i, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_tpickup_1_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[0]] = 255 or (chan[partner[0]] % 20) != 0; dev := 1; partner[0] := 255; chan[0] := 255].
    private boolean execute_transition_tpickup_1() {
        // SLCO composite | [chan[partner[0]] = 255 or ((chan[partner[0]]) % 20) != 0; dev := 1; partner[0] := 255; chan[0] := 255] -> [chan[partner[0]] = 255 or (chan[partner[0]] % 20) != 0; dev := 1; partner[0] := 255; chan[0] := 255].
        // SLCO expression | chan[partner[0]] = 255 or (chan[partner[0]] % 20) != 0.
        //@ ghost _guard = c.chan[c.partner[0]] == 255 || (Math.floorMod(c.chan[c.partner[0]], 20)) != 0;
        if(!(t_tpickup_1_s_0_n_2())) {
            //@ assert !(c.chan[c.partner[0]] == 255 || (Math.floorMod(c.chan[c.partner[0]], 20)) != 0);
            return false;
        }
        //@ assert c.chan[c.partner[0]] == 255 || (Math.floorMod(c.chan[c.partner[0]], 20)) != 0;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | partner[0] := 255.
        range_check_assumption_t_1_s_3();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 0;
        c.partner[0] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | chan[0] := 255.
        range_check_assumption_t_1_s_4();
        //@ ghost _rhs_2 = 255;
        //@ ghost _index_2 = 0;
        c.chan[0] = (255) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | (chan[0] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[0] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_0_s_0_n_0() {
        return (c.chan[0] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_0_s_0_n_1() {
        return dev == 0;
    }

    // SLCO expression wrapper | (chan[0] / 20) = 1 and dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[0] / 20) == 1 && dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_0_s_0_n_2() {
        return t_tconnected_0_s_0_n_0() && t_tconnected_0_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[0] / 20) == 1 && dev == 0);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[0] / 20) = 1 and dev = 0; dev := 1].
    private boolean execute_transition_tconnected_0() {
        // SLCO composite | [((chan[0]) / 20) = 1 and dev = 0; dev := 1] -> [(chan[0] / 20) = 1 and dev = 0; dev := 1].
        // SLCO expression | (chan[0] / 20) = 1 and dev = 0.
        //@ ghost _guard = (c.chan[0] / 20) == 1 && dev == 0;
        if(!(t_tconnected_0_s_0_n_2())) {
            //@ assert !((c.chan[0] / 20) == 1 && dev == 0);
            return false;
        }
        //@ assert (c.chan[0] / 20) == 1 && dev == 0;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_2();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | (chan[0] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[0] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_1_s_0_n_0() {
        return (c.chan[0] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_1_s_0_n_1() {
        return dev == 1;
    }

    // SLCO expression wrapper | (chan[0] / 20) = 1 and dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[0] / 20) == 1 && dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_1_s_0_n_2() {
        return t_tconnected_1_s_0_n_0() && t_tconnected_1_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[0] / 20) == 1 && dev == 1);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[0] / 20) = 1 and dev = 1; dev := 0].
    private boolean execute_transition_tconnected_1() {
        // SLCO composite | [((chan[0]) / 20) = 1 and dev = 1; dev := 0] -> [(chan[0] / 20) = 1 and dev = 1; dev := 0].
        // SLCO expression | (chan[0] / 20) = 1 and dev = 1.
        //@ ghost _guard = (c.chan[0] / 20) == 1 && dev == 1;
        if(!(t_tconnected_1_s_0_n_2())) {
            //@ assert !((c.chan[0] / 20) == 1 && dev == 1);
            return false;
        }
        //@ assert (c.chan[0] / 20) == 1 && dev == 1;
        // SLCO assignment | dev := 0.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 0;
        dev = (0) & 0xff;
        //@ assert dev == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | (chan[0] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[0] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_2_s_0_n_0() {
        return (c.chan[0] / 20) == 0;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 0 && 0 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 0 && 0 < 4;
    }

    /*@
    pure int value_tconnected_2_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    pure int value_tconnected_2_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[0] / 20) == 0);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_tconnected_2_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_tconnected_2_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[0] / 20) = 0; partner[0] := 255; chan[0] := 255].
    private boolean execute_transition_tconnected_2() {
        // SLCO composite | [((chan[0]) / 20) = 0; partner[0] := 255; chan[0] := 255] -> [(chan[0] / 20) = 0; partner[0] := 255; chan[0] := 255].
        // SLCO expression | (chan[0] / 20) = 0.
        //@ ghost _guard = (c.chan[0] / 20) == 0;
        if(!(t_tconnected_2_s_0_n_0())) {
            //@ assert !((c.chan[0] / 20) == 0);
            return false;
        }
        //@ assert (c.chan[0] / 20) == 0;
        // SLCO assignment | partner[0] := 255.
        range_check_assumption_t_2_s_2();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 0;
        c.partner[0] = (255) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;
        // SLCO assignment | chan[0] := 255.
        range_check_assumption_t_2_s_3();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 0;
        c.chan[0] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state idle.
    private void exec_idle() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | idle -> dialing | [chan[0] = 255; dev := 0; chan[0] := (0 + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | idle -> qi | [chan[0] != 255; partner[0] := (chan[0] % 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state dialing.
    private void exec_dialing() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[0] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[0] := 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[0] := 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_2()) {
            return;
        }
        // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[0] := 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[0] := 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[0] := 4.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_5()) {
            return;
        }
        // [SEQ.END]
    }

    // SLCO expression wrapper | partner[0] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 0 && 0 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[0] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean d_calling_0_n_0() {
        return c.partner[0] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state calling.
    private void exec_calling() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | calling -> busy | partner[0] = 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_0()) {
            return;
        }
        // SLCO expression | partner[0] = 4.
        if(d_calling_0_n_0()) {
            // [SEQ.START]
            // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[0] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_1()) {
                return;
            }
            // SLCO transition (p:0, id:2) | calling -> ringback | partner[0] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_2()) {
                return;
            }
            // [SEQ.END]
        }
        // SLCO transition (p:0, id:3) | calling -> busy | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] = 255; record[partner[0]] := 0].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | calling -> calling | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] != 255 and callforwardbusy[partner[0]] != 255; record[partner[0]] := 0; partner[0] := callforwardbusy[partner[0]]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | calling -> oalert | [partner[0] != 0 and partner[0] != 4 and chan[partner[0]] = 255; record[partner[0]] := 0; chan[partner[0]] := (0 + 0 * 20); chan[0] := (partner[0] + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_5()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state busy.
    private void exec_busy() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[0] := 255; partner[0] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_busy_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state qi.
    private void exec_qi() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[0]] % 20) = 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[0]] % 20) != 0; partner[0] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state talert.
    private void exec_talert() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[0] = 255.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_0()) {
            return;
        }
        // [DET.START]
        // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[0]] % 20) = 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[0]] % 20) != 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state unobtainable.
    private void exec_unobtainable() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[0] := 255; partner[0] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_unobtainable_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state oalert.
    private void exec_oalert() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[0] % 20) != partner[0].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[0] % 20) = partner[0] and (chan[0] / 20) = 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[0] % 20) = partner[0] and (chan[0] / 20) = 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state errorstate.
    private void exec_errorstate() {
        // There are no transitions starting in state errorstate.
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state oconnected.
    private void exec_oconnected() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[0] := 255; chan[partner[0]] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oconnected_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state dveoringout.
    private void exec_dveoringout() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[0] := 255; partner[0] := ((partner[0] % 20) + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dveoringout_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state tpickup.
    private void exec_tpickup() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[0]] % 20) = 0 and (chan[partner[0]] / 20) = 0; dev := 0; chan[partner[0]] := (0 + 1 * 20); chan[0] := (partner[0] + 1 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[0]] = 255 or (chan[partner[0]] % 20) != 0; dev := 1; partner[0] := 255; chan[0] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state tconnected.
    private void exec_tconnected() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[0] / 20) = 1 and dev = 0; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[0] / 20) = 1 and dev = 1; dev := 0].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[0] / 20) = 0; partner[0] := 255; chan[0] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state ringback.
    private void exec_ringback() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[0] := 255; partner[0] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | ringback -> calling | [record[0] != 255; partner[0] := record[0]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_1()) {
            return;
        }
        // [SEQ.END]
    }
}

// <<< STATE_MACHINE.END (User_0)

// >>> STATE_MACHINE.START (User_1)

// VerCors verification instructions for SLCO state machine User_1.
class GlobalClass_User_1Thread {
    // The class the state machine is a part of.
    private final GlobalClass c;

    // Thread local variables.
    private int dev;
    private int mbit;

    /*@
    // Ensure full access to the class members.
    ensures Perm(this.c, 1);

    // Require that the input class is a valid object.
    requires c != null;

    // Ensure that the appropriate starter values are assigned.
    ensures this.c == c;
    @*/
    GlobalClass_User_1Thread(GlobalClass c) {
        // Reference to the parent SLCO class.
        this.c = c;

        // Variable instantiations.
        dev = (char) 1;
        mbit = (char) 0;
    }

    // SLCO expression wrapper | chan[1] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[1] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_idle_0_s_0_n_0() {
        return c.chan[1] == 255;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    pure int value_idle_0_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[1] == 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_idle_0_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | idle -> dialing | [chan[1] = 255; dev := 0; chan[1] := (1 + 0 * 20)].
    private boolean execute_transition_idle_0() {
        // SLCO composite | [chan[1] = 255; dev := 0; chan[1] := ((1) + (0) * 20)] -> [chan[1] = 255; dev := 0; chan[1] := (1 + 0 * 20)].
        // SLCO expression | chan[1] = 255.
        //@ ghost _guard = c.chan[1] == 255;
        if(!(t_idle_0_s_0_n_0())) {
            //@ assert !(c.chan[1] == 255);
            return false;
        }
        //@ assert c.chan[1] == 255;
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        //@ ghost _rhs_0 = 0;
        dev = (0) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[1] := (1 + 0 * 20).
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_1 = (1 + 0 * 20);
        //@ ghost _index_1 = 1;
        c.chan[1] = ((1 + 0 * 20)) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;

        return true;
    }

    // SLCO expression wrapper | chan[1] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[1] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_idle_1_s_0_n_0() {
        return c.chan[1] != 255;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    pure int value_idle_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[1] != 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_idle_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | idle -> qi | [chan[1] != 255; partner[1] := (chan[1] % 20)].
    private boolean execute_transition_idle_1() {
        // SLCO composite | [chan[1] != 255; partner[1] := ((chan[1]) % 20)] -> [chan[1] != 255; partner[1] := (chan[1] % 20)].
        // SLCO expression | chan[1] != 255.
        //@ ghost _guard = c.chan[1] != 255;
        if(!(t_idle_1_s_0_n_0())) {
            //@ assert !(c.chan[1] != 255);
            return false;
        }
        //@ assert c.chan[1] != 255;
        // SLCO assignment | partner[1] := (chan[1] % 20).
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = (Math.floorMod(c.chan[1], 20));
        //@ ghost _index_0 = 1;
        c.partner[1] = ((Math.floorMod(c.chan[1], 20))) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[1]] % 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[1]], 20)) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_qi_0_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[1]], 20)) == 1;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[1]], 20)) == 1);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[1]] % 20) = 1.
    private boolean execute_transition_qi_0() {
        // SLCO expression | ((chan[partner[1]]) % 20) = 1 -> (chan[partner[1]] % 20) = 1.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[1]], 20)) == 1;
        if(!(t_qi_0_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[1]], 20)) == 1);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[1]], 20)) == 1;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[1]] % 20) != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[1]], 20)) != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_qi_1_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[1]], 20)) != 1;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    pure int value_qi_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[1]], 20)) != 1);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_qi_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[1]] % 20) != 1; partner[1] := 255].
    private boolean execute_transition_qi_1() {
        // SLCO composite | [((chan[partner[1]]) % 20) != 1; partner[1] := 255] -> [(chan[partner[1]] % 20) != 1; partner[1] := 255].
        // SLCO expression | (chan[partner[1]] % 20) != 1.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[1]], 20)) != 1;
        if(!(t_qi_1_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[1]], 20)) != 1);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[1]], 20)) != 1;
        // SLCO assignment | partner[1] := 255.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 1;
        c.partner[1] = (255) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_dialing_0_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_dialing_0_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[1] := 255].
    private boolean execute_transition_dialing_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [dev := 1; chan[1] := 255] -> [true; dev := 1; chan[1] := 255].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[1] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 1;
        c.chan[1] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        
    }

    /*@
    pure int value_dialing_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[1] := 0.
    private boolean execute_transition_dialing_1() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[1] := 0] -> partner[1] := 0.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 0;
        //@ ghost _index_0 = 1;
        c.partner[1] = (0) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        
    }

    /*@
    pure int value_dialing_2_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_2_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[1] := 1.
    private boolean execute_transition_dialing_2() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[1] := 1] -> partner[1] := 1.
        range_check_assumption_t_2_s_2();
        //@ ghost _rhs_0 = 1;
        //@ ghost _index_0 = 1;
        c.partner[1] = (1) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        
    }

    /*@
    pure int value_dialing_3_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_3_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[1] := 2.
    private boolean execute_transition_dialing_3() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[1] := 2] -> partner[1] := 2.
        range_check_assumption_t_3_s_2();
        //@ ghost _rhs_0 = 2;
        //@ ghost _index_0 = 1;
        c.partner[1] = (2) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        
    }

    /*@
    pure int value_dialing_4_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_4_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[1] := 3.
    private boolean execute_transition_dialing_4() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[1] := 3] -> partner[1] := 3.
        range_check_assumption_t_4_s_2();
        //@ ghost _rhs_0 = 3;
        //@ ghost _index_0 = 1;
        c.partner[1] = (3) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        
    }

    /*@
    pure int value_dialing_5_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_5_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[1] := 4.
    private boolean execute_transition_dialing_5() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[1] := 4] -> partner[1] := 4.
        range_check_assumption_t_5_s_2();
        //@ ghost _rhs_0 = 4;
        //@ ghost _index_0 = 1;
        c.partner[1] = (4) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | partner[1] = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_0_s_0_n_0() {
        return c.partner[1] == 1;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[1] == 1);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | calling -> busy | partner[1] = 1.
    private boolean execute_transition_calling_0() {
        // SLCO expression | partner[1] = 1.
        //@ ghost _guard = c.partner[1] == 1;
        if(!(t_calling_0_s_0_n_0())) {
            //@ assert !(c.partner[1] == 1);
            return false;
        }
        //@ assert c.partner[1] == 1;

        return true;
    }

    // SLCO expression wrapper | partner[1] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_1_s_0_n_0() {
        return c.partner[1] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[1] == 4);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[1] = 4.
    private boolean execute_transition_calling_1() {
        // SLCO expression | partner[1] = 4.
        //@ ghost _guard = c.partner[1] == 4;
        if(!(t_calling_1_s_0_n_0())) {
            //@ assert !(c.partner[1] == 4);
            return false;
        }
        //@ assert c.partner[1] == 4;

        return true;
    }

    // SLCO expression wrapper | partner[1] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_2_s_0_n_0() {
        return c.partner[1] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[1] == 4);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | calling -> ringback | partner[1] = 4.
    private boolean execute_transition_calling_2() {
        // SLCO expression | partner[1] = 4.
        //@ ghost _guard = c.partner[1] == 4;
        if(!(t_calling_2_s_0_n_0())) {
            //@ assert !(c.partner[1] == 4);
            return false;
        }
        //@ assert c.partner[1] == 4;

        return true;
    }

    // SLCO expression wrapper | partner[1] != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_0() {
        return c.partner[1] != 1;
    }

    // SLCO expression wrapper | partner[1] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_1() {
        return c.partner[1] != 4;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_2() {
        return t_calling_3_s_0_n_0() && t_calling_3_s_0_n_1();
    }

    // SLCO expression wrapper | chan[partner[1]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[1]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_3() {
        return c.chan[c.partner[1]] != 255;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_4() {
        return t_calling_3_s_0_n_2() && t_calling_3_s_0_n_3();
    }

    // SLCO expression wrapper | callforwardbusy[partner[1]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[1]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_5() {
        return c.callforwardbusy[c.partner[1]] == 255;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255 && c.callforwardbusy[c.partner[1]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_6() {
        return t_calling_3_s_0_n_4() && t_calling_3_s_0_n_5();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    pure int value_calling_3_record(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255 && c.callforwardbusy[c.partner[1]] == 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == value_calling_3_record(_i, _index_0, _rhs_0, \old(c.record[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:3) | calling -> busy | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] = 255; record[partner[1]] := 1].
    private boolean execute_transition_calling_3() {
        // SLCO composite | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] = 255; record[partner[1]] := 1].
        // SLCO expression | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] = 255.
        //@ ghost _guard = c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255 && c.callforwardbusy[c.partner[1]] == 255;
        if(!(t_calling_3_s_0_n_6())) {
            //@ assert !(c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255 && c.callforwardbusy[c.partner[1]] == 255);
            return false;
        }
        //@ assert c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255 && c.callforwardbusy[c.partner[1]] == 255;
        // SLCO assignment | record[partner[1]] := 1.
        range_check_assumption_t_3_s_2();
        //@ ghost _rhs_0 = 1;
        //@ ghost _index_0 = c.partner[1];
        c.record[c.partner[1]] = (1) & 0xff;
        //@ assert c.record[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | partner[1] != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_0() {
        return c.partner[1] != 1;
    }

    // SLCO expression wrapper | partner[1] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_1() {
        return c.partner[1] != 4;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_2() {
        return t_calling_4_s_0_n_0() && t_calling_4_s_0_n_1();
    }

    // SLCO expression wrapper | chan[partner[1]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[1]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_3() {
        return c.chan[c.partner[1]] != 255;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_4() {
        return t_calling_4_s_0_n_2() && t_calling_4_s_0_n_3();
    }

    // SLCO expression wrapper | callforwardbusy[partner[1]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[1]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_5() {
        return c.callforwardbusy[c.partner[1]] != 255;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255 && c.callforwardbusy[c.partner[1]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_6() {
        return t_calling_4_s_0_n_4() && t_calling_4_s_0_n_5();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    pure int value_calling_4_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    pure int value_calling_4_record(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255 && c.callforwardbusy[c.partner[1]] != 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_calling_4_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == value_calling_4_record(_i, _index_0, _rhs_0, \old(c.record[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:4) | calling -> calling | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] != 255; record[partner[1]] := 1; partner[1] := callforwardbusy[partner[1]]].
    private boolean execute_transition_calling_4() {
        // SLCO composite | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] != 255; record[partner[1]] := 1; partner[1] := callforwardbusy[partner[1]]].
        // SLCO expression | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] != 255.
        //@ ghost _guard = c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255 && c.callforwardbusy[c.partner[1]] != 255;
        if(!(t_calling_4_s_0_n_6())) {
            //@ assert !(c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255 && c.callforwardbusy[c.partner[1]] != 255);
            return false;
        }
        //@ assert c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] != 255 && c.callforwardbusy[c.partner[1]] != 255;
        // SLCO assignment | record[partner[1]] := 1.
        range_check_assumption_t_4_s_2();
        //@ ghost _rhs_0 = 1;
        //@ ghost _index_0 = c.partner[1];
        c.record[c.partner[1]] = (1) & 0xff;
        //@ assert c.record[_index_0] == _rhs_0;
        // SLCO assignment | partner[1] := callforwardbusy[partner[1]].
        range_check_assumption_t_4_s_3();
        //@ ghost _rhs_1 = c.callforwardbusy[c.partner[1]];
        //@ ghost _index_1 = 1;
        c.partner[1] = (c.callforwardbusy[c.partner[1]]) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;

        return true;
    }

    // SLCO expression wrapper | partner[1] != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_0() {
        return c.partner[1] != 1;
    }

    // SLCO expression wrapper | partner[1] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_1() {
        return c.partner[1] != 4;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_2() {
        return t_calling_5_s_0_n_0() && t_calling_5_s_0_n_1();
    }

    // SLCO expression wrapper | chan[partner[1]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[1]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_3() {
        return c.chan[c.partner[1]] == 255;
    }

    // SLCO expression wrapper | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_4() {
        return t_calling_5_s_0_n_2() && t_calling_5_s_0_n_3();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    pure int value_calling_5_chan(int _i, int _index_1, int _rhs_1, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : ((_i == _index_1) ? _rhs_1 : v_old);
    pure int value_calling_5_record(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] == 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_calling_5_chan(_i, _index_1, _rhs_1, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == value_calling_5_record(_i, _index_0, _rhs_0, \old(c.record[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:5) | calling -> oalert | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] = 255; record[partner[1]] := 1; chan[partner[1]] := (1 + 0 * 20); chan[1] := (partner[1] + 0 * 20)].
    private boolean execute_transition_calling_5() {
        // SLCO composite | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] = 255; record[partner[1]] := 1; chan[partner[1]] := ((1) + (0) * 20); chan[1] := ((partner[1]) + (0) * 20)] -> [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] = 255; record[partner[1]] := 1; chan[partner[1]] := (1 + 0 * 20); chan[1] := (partner[1] + 0 * 20)].
        // SLCO expression | partner[1] != 1 and partner[1] != 4 and chan[partner[1]] = 255.
        //@ ghost _guard = c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] == 255;
        if(!(t_calling_5_s_0_n_4())) {
            //@ assert !(c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] == 255);
            return false;
        }
        //@ assert c.partner[1] != 1 && c.partner[1] != 4 && c.chan[c.partner[1]] == 255;
        // SLCO assignment | record[partner[1]] := 1.
        range_check_assumption_t_5_s_2();
        //@ ghost _rhs_0 = 1;
        //@ ghost _index_0 = c.partner[1];
        c.record[c.partner[1]] = (1) & 0xff;
        //@ assert c.record[_index_0] == _rhs_0;
        // SLCO assignment | chan[partner[1]] := (1 + 0 * 20).
        range_check_assumption_t_5_s_3();
        //@ ghost _rhs_1 = (1 + 0 * 20);
        //@ ghost _index_1 = c.partner[1];
        c.chan[c.partner[1]] = ((1 + 0 * 20)) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | chan[1] := (partner[1] + 0 * 20).
        range_check_assumption_t_5_s_4();
        //@ ghost _rhs_2 = (c.partner[1] + 0 * 20);
        //@ ghost _index_2 = 1;
        c.chan[1] = ((c.partner[1] + 0 * 20)) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_busy_0_chan(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    pure int value_busy_0_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_busy_0_chan(_i, _index_0, _rhs_0, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_busy_0_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_2);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[1] := 255; partner[1] := 255; dev := 1].
    private boolean execute_transition_busy_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [chan[1] := 255; partner[1] := 255; dev := 1] -> [true; chan[1] := 255; partner[1] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | chan[1] := 255.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 1;
        c.chan[1] = (255) & 0xff;
        //@ assert c.chan[_index_0] == _rhs_0;
        // SLCO assignment | partner[1] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 1;
        c.partner[1] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | (chan[1] % 20) != partner[1].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[1], 20)) != c.partner[1]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_0_s_0_n_0() {
        return (Math.floorMod(c.chan[1], 20)) != c.partner[1];
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[1], 20)) != c.partner[1]);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[1] % 20) != partner[1].
    private boolean execute_transition_oalert_0() {
        // SLCO expression | ((chan[1]) % 20) != partner[1] -> (chan[1] % 20) != partner[1].
        //@ ghost _guard = (Math.floorMod(c.chan[1], 20)) != c.partner[1];
        if(!(t_oalert_0_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[1], 20)) != c.partner[1]);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[1], 20)) != c.partner[1];

        return true;
    }

    // SLCO expression wrapper | (chan[1] % 20) = partner[1].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[1], 20)) == c.partner[1]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_1_s_0_n_0() {
        return (Math.floorMod(c.chan[1], 20)) == c.partner[1];
    }

    // SLCO expression wrapper | (chan[1] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[1] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_1_s_0_n_1() {
        return (c.chan[1] / 20) == 1;
    }

    // SLCO expression wrapper | (chan[1] % 20) = partner[1] and (chan[1] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[1], 20)) == c.partner[1] && (c.chan[1] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_1_s_0_n_2() {
        return t_oalert_1_s_0_n_0() && t_oalert_1_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[1], 20)) == c.partner[1] && (c.chan[1] / 20) == 1);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[1] % 20) = partner[1] and (chan[1] / 20) = 1.
    private boolean execute_transition_oalert_1() {
        // SLCO expression | ((chan[1]) % 20) = partner[1] and ((chan[1]) / 20) = 1 -> (chan[1] % 20) = partner[1] and (chan[1] / 20) = 1.
        //@ ghost _guard = (Math.floorMod(c.chan[1], 20)) == c.partner[1] && (c.chan[1] / 20) == 1;
        if(!(t_oalert_1_s_0_n_2())) {
            //@ assert !((Math.floorMod(c.chan[1], 20)) == c.partner[1] && (c.chan[1] / 20) == 1);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[1], 20)) == c.partner[1] && (c.chan[1] / 20) == 1;

        return true;
    }

    // SLCO expression wrapper | (chan[1] % 20) = partner[1].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[1], 20)) == c.partner[1]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_2_s_0_n_0() {
        return (Math.floorMod(c.chan[1], 20)) == c.partner[1];
    }

    // SLCO expression wrapper | (chan[1] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[1] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_2_s_0_n_1() {
        return (c.chan[1] / 20) == 0;
    }

    // SLCO expression wrapper | (chan[1] % 20) = partner[1] and (chan[1] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[1], 20)) == c.partner[1] && (c.chan[1] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_2_s_0_n_2() {
        return t_oalert_2_s_0_n_0() && t_oalert_2_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[1], 20)) == c.partner[1] && (c.chan[1] / 20) == 0);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[1] % 20) = partner[1] and (chan[1] / 20) = 0.
    private boolean execute_transition_oalert_2() {
        // SLCO expression | ((chan[1]) % 20) = partner[1] and ((chan[1]) / 20) = 0 -> (chan[1] % 20) = partner[1] and (chan[1] / 20) = 0.
        //@ ghost _guard = (Math.floorMod(c.chan[1], 20)) == c.partner[1] && (c.chan[1] / 20) == 0;
        if(!(t_oalert_2_s_0_n_2())) {
            //@ assert !((Math.floorMod(c.chan[1], 20)) == c.partner[1] && (c.chan[1] / 20) == 0);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[1], 20)) == c.partner[1] && (c.chan[1] / 20) == 0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_oconnected_0_chan(int _i, int _index_1, int _rhs_1, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : ((_i == _index_1) ? _rhs_1 : v_old);
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_oconnected_0_chan(_i, _index_1, _rhs_1, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[1] := 255; chan[partner[1]] := 255].
    private boolean execute_transition_oconnected_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [dev := 1; chan[1] := 255; chan[partner[1]] := 255] -> [true; dev := 1; chan[1] := 255; chan[partner[1]] := 255].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[1] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 1;
        c.chan[1] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | chan[partner[1]] := 255.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 255;
        //@ ghost _index_2 = c.partner[1];
        c.chan[c.partner[1]] = (255) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_dveoringout_0_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    pure int value_dveoringout_0_partner(int _i, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_dveoringout_0_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dveoringout_0_partner(_i, _index_2, _rhs_2, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[1] := 255; partner[1] := ((partner[1] % 20) + 0 * 20)].
    private boolean execute_transition_dveoringout_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [dev := 1; chan[1] := 255; partner[1] := ((((partner[1]) % 20)) + (0) * 20)] -> [true; dev := 1; chan[1] := 255; partner[1] := ((partner[1] % 20) + 0 * 20)].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[1] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 1;
        c.chan[1] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | partner[1] := ((partner[1] % 20) + 0 * 20).
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = ((Math.floorMod(c.partner[1], 20)) + 0 * 20);
        //@ ghost _index_2 = 1;
        c.partner[1] = (((Math.floorMod(c.partner[1], 20)) + 0 * 20)) & 0xff;
        //@ assert c.partner[_index_2] == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_unobtainable_0_chan(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    pure int value_unobtainable_0_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_unobtainable_0_chan(_i, _index_0, _rhs_0, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_unobtainable_0_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_2);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[1] := 255; partner[1] := 255; dev := 1].
    private boolean execute_transition_unobtainable_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [chan[1] := 255; partner[1] := 255; dev := 1] -> [true; chan[1] := 255; partner[1] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | chan[1] := 255.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 1;
        c.chan[1] = (255) & 0xff;
        //@ assert c.chan[_index_0] == _rhs_0;
        // SLCO assignment | partner[1] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 1;
        c.partner[1] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_ringback_0_chan(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    pure int value_ringback_0_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_ringback_0_chan(_i, _index_0, _rhs_0, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_ringback_0_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_2);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[1] := 255; partner[1] := 255; dev := 1].
    private boolean execute_transition_ringback_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [chan[1] := 255; partner[1] := 255; dev := 1] -> [true; chan[1] := 255; partner[1] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | chan[1] := 255.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 1;
        c.chan[1] = (255) & 0xff;
        //@ assert c.chan[_index_0] == _rhs_0;
        // SLCO assignment | partner[1] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 1;
        c.partner[1] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | record[1] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.record[1] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_ringback_1_s_0_n_0() {
        return c.record[1] != 255;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    pure int value_ringback_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.record[1] != 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_ringback_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | ringback -> calling | [record[1] != 255; partner[1] := record[1]].
    private boolean execute_transition_ringback_1() {
        // SLCO composite | [record[1] != 255; partner[1] := record[1]].
        // SLCO expression | record[1] != 255.
        //@ ghost _guard = c.record[1] != 255;
        if(!(t_ringback_1_s_0_n_0())) {
            //@ assert !(c.record[1] != 255);
            return false;
        }
        //@ assert c.record[1] != 255;
        // SLCO assignment | partner[1] := record[1].
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = c.record[1];
        //@ ghost _index_0 = 1;
        c.partner[1] = (c.record[1]) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | dev != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_0_s_0_n_0() {
        return dev != 1;
    }

    // SLCO expression wrapper | chan[1] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[1] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_0_s_0_n_1() {
        return c.chan[1] == 255;
    }

    // SLCO expression wrapper | dev != 1 or chan[1] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1 || c.chan[1] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_0_s_0_n_2() {
        return t_talert_0_s_0_n_0() || t_talert_0_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(dev != 1 || c.chan[1] == 255);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[1] = 255.
    private boolean execute_transition_talert_0() {
        // SLCO expression | dev != 1 or chan[1] = 255.
        //@ ghost _guard = dev != 1 || c.chan[1] == 255;
        if(!(t_talert_0_s_0_n_2())) {
            //@ assert !(dev != 1 || c.chan[1] == 255);
            return false;
        }
        //@ assert dev != 1 || c.chan[1] == 255;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[1]] % 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[1]], 20)) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_1_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[1]], 20)) == 1;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[1]], 20)) == 1);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[1]] % 20) = 1.
    private boolean execute_transition_talert_1() {
        // SLCO expression | ((chan[partner[1]]) % 20) = 1 -> (chan[partner[1]] % 20) = 1.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[1]], 20)) == 1;
        if(!(t_talert_1_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[1]], 20)) == 1);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[1]], 20)) == 1;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[1]] % 20) != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[1]], 20)) != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_2_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[1]], 20)) != 1;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[1]], 20)) != 1);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[1]] % 20) != 1.
    private boolean execute_transition_talert_2() {
        // SLCO expression | ((chan[partner[1]]) % 20) != 1 -> (chan[partner[1]] % 20) != 1.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[1]], 20)) != 1;
        if(!(t_talert_2_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[1]], 20)) != 1);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[1]], 20)) != 1;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[1]] % 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[1]], 20)) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_0_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[1]], 20)) == 1;
    }

    // SLCO expression wrapper | (chan[partner[1]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[c.partner[1]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_0_s_0_n_1() {
        return (c.chan[c.partner[1]] / 20) == 0;
    }

    // SLCO expression wrapper | (chan[partner[1]] % 20) = 1 and (chan[partner[1]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[1]], 20)) == 1 && (c.chan[c.partner[1]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_0_s_0_n_2() {
        return t_tpickup_0_s_0_n_0() && t_tpickup_0_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    pure int value_tpickup_0_chan(int _i, int _index_1, int _rhs_1, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : ((_i == _index_1) ? _rhs_1 : v_old);
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[1]], 20)) == 1 && (c.chan[c.partner[1]] / 20) == 0);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_tpickup_0_chan(_i, _index_1, _rhs_1, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[1]] % 20) = 1 and (chan[partner[1]] / 20) = 0; dev := 0; chan[partner[1]] := (1 + 1 * 20); chan[1] := (partner[1] + 1 * 20)].
    private boolean execute_transition_tpickup_0() {
        // SLCO composite | [((chan[partner[1]]) % 20) = 1 and ((chan[partner[1]]) / 20) = 0; dev := 0; chan[partner[1]] := ((1) + (1) * 20); chan[1] := ((partner[1]) + (1) * 20)] -> [(chan[partner[1]] % 20) = 1 and (chan[partner[1]] / 20) = 0; dev := 0; chan[partner[1]] := (1 + 1 * 20); chan[1] := (partner[1] + 1 * 20)].
        // SLCO expression | (chan[partner[1]] % 20) = 1 and (chan[partner[1]] / 20) = 0.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[1]], 20)) == 1 && (c.chan[c.partner[1]] / 20) == 0;
        if(!(t_tpickup_0_s_0_n_2())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[1]], 20)) == 1 && (c.chan[c.partner[1]] / 20) == 0);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[1]], 20)) == 1 && (c.chan[c.partner[1]] / 20) == 0;
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        //@ ghost _rhs_0 = 0;
        dev = (0) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[partner[1]] := (1 + 1 * 20).
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_1 = (1 + 1 * 20);
        //@ ghost _index_1 = c.partner[1];
        c.chan[c.partner[1]] = ((1 + 1 * 20)) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | chan[1] := (partner[1] + 1 * 20).
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_2 = (c.partner[1] + 1 * 20);
        //@ ghost _index_2 = 1;
        c.chan[1] = ((c.partner[1] + 1 * 20)) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | chan[partner[1]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[1]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_1_s_0_n_0() {
        return c.chan[c.partner[1]] == 255;
    }

    // SLCO expression wrapper | (chan[partner[1]] % 20) != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[1]], 20)) != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_1_s_0_n_1() {
        return (Math.floorMod(c.chan[c.partner[1]], 20)) != 1;
    }

    // SLCO expression wrapper | chan[partner[1]] = 255 or (chan[partner[1]] % 20) != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;
    context 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[1]] == 255 || (Math.floorMod(c.chan[c.partner[1]], 20)) != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_1_s_0_n_2() {
        return t_tpickup_1_s_0_n_0() || t_tpickup_1_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;
    ensures 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
        //@ assume 0 <= c.partner[1] && c.partner[1] < 4;
    }

    /*@
    pure int value_tpickup_1_chan(int _i, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : v_old;
    pure int value_tpickup_1_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;
    requires 0 <= c.partner[1] && c.partner[1] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[c.partner[1]] == 255 || (Math.floorMod(c.chan[c.partner[1]], 20)) != 1);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_tpickup_1_chan(_i, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_tpickup_1_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[1]] = 255 or (chan[partner[1]] % 20) != 1; dev := 1; partner[1] := 255; chan[1] := 255].
    private boolean execute_transition_tpickup_1() {
        // SLCO composite | [chan[partner[1]] = 255 or ((chan[partner[1]]) % 20) != 1; dev := 1; partner[1] := 255; chan[1] := 255] -> [chan[partner[1]] = 255 or (chan[partner[1]] % 20) != 1; dev := 1; partner[1] := 255; chan[1] := 255].
        // SLCO expression | chan[partner[1]] = 255 or (chan[partner[1]] % 20) != 1.
        //@ ghost _guard = c.chan[c.partner[1]] == 255 || (Math.floorMod(c.chan[c.partner[1]], 20)) != 1;
        if(!(t_tpickup_1_s_0_n_2())) {
            //@ assert !(c.chan[c.partner[1]] == 255 || (Math.floorMod(c.chan[c.partner[1]], 20)) != 1);
            return false;
        }
        //@ assert c.chan[c.partner[1]] == 255 || (Math.floorMod(c.chan[c.partner[1]], 20)) != 1;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | partner[1] := 255.
        range_check_assumption_t_1_s_3();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 1;
        c.partner[1] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | chan[1] := 255.
        range_check_assumption_t_1_s_4();
        //@ ghost _rhs_2 = 255;
        //@ ghost _index_2 = 1;
        c.chan[1] = (255) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | (chan[1] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[1] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_0_s_0_n_0() {
        return (c.chan[1] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_0_s_0_n_1() {
        return dev == 0;
    }

    // SLCO expression wrapper | (chan[1] / 20) = 1 and dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[1] / 20) == 1 && dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_0_s_0_n_2() {
        return t_tconnected_0_s_0_n_0() && t_tconnected_0_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[1] / 20) == 1 && dev == 0);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[1] / 20) = 1 and dev = 0; dev := 1].
    private boolean execute_transition_tconnected_0() {
        // SLCO composite | [((chan[1]) / 20) = 1 and dev = 0; dev := 1] -> [(chan[1] / 20) = 1 and dev = 0; dev := 1].
        // SLCO expression | (chan[1] / 20) = 1 and dev = 0.
        //@ ghost _guard = (c.chan[1] / 20) == 1 && dev == 0;
        if(!(t_tconnected_0_s_0_n_2())) {
            //@ assert !((c.chan[1] / 20) == 1 && dev == 0);
            return false;
        }
        //@ assert (c.chan[1] / 20) == 1 && dev == 0;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_2();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | (chan[1] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[1] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_1_s_0_n_0() {
        return (c.chan[1] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_1_s_0_n_1() {
        return dev == 1;
    }

    // SLCO expression wrapper | (chan[1] / 20) = 1 and dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[1] / 20) == 1 && dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_1_s_0_n_2() {
        return t_tconnected_1_s_0_n_0() && t_tconnected_1_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[1] / 20) == 1 && dev == 1);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[1] / 20) = 1 and dev = 1; dev := 0].
    private boolean execute_transition_tconnected_1() {
        // SLCO composite | [((chan[1]) / 20) = 1 and dev = 1; dev := 0] -> [(chan[1] / 20) = 1 and dev = 1; dev := 0].
        // SLCO expression | (chan[1] / 20) = 1 and dev = 1.
        //@ ghost _guard = (c.chan[1] / 20) == 1 && dev == 1;
        if(!(t_tconnected_1_s_0_n_2())) {
            //@ assert !((c.chan[1] / 20) == 1 && dev == 1);
            return false;
        }
        //@ assert (c.chan[1] / 20) == 1 && dev == 1;
        // SLCO assignment | dev := 0.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 0;
        dev = (0) & 0xff;
        //@ assert dev == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | (chan[1] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[1] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_2_s_0_n_0() {
        return (c.chan[1] / 20) == 0;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 1 && 1 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 1 && 1 < 4;
    }

    /*@
    pure int value_tconnected_2_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    pure int value_tconnected_2_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[1] / 20) == 0);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_tconnected_2_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_tconnected_2_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[1] / 20) = 0; partner[1] := 255; chan[1] := 255].
    private boolean execute_transition_tconnected_2() {
        // SLCO composite | [((chan[1]) / 20) = 0; partner[1] := 255; chan[1] := 255] -> [(chan[1] / 20) = 0; partner[1] := 255; chan[1] := 255].
        // SLCO expression | (chan[1] / 20) = 0.
        //@ ghost _guard = (c.chan[1] / 20) == 0;
        if(!(t_tconnected_2_s_0_n_0())) {
            //@ assert !((c.chan[1] / 20) == 0);
            return false;
        }
        //@ assert (c.chan[1] / 20) == 0;
        // SLCO assignment | partner[1] := 255.
        range_check_assumption_t_2_s_2();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 1;
        c.partner[1] = (255) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;
        // SLCO assignment | chan[1] := 255.
        range_check_assumption_t_2_s_3();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 1;
        c.chan[1] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state idle.
    private void exec_idle() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | idle -> dialing | [chan[1] = 255; dev := 0; chan[1] := (1 + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | idle -> qi | [chan[1] != 255; partner[1] := (chan[1] % 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state dialing.
    private void exec_dialing() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[1] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[1] := 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[1] := 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_2()) {
            return;
        }
        // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[1] := 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[1] := 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[1] := 4.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_5()) {
            return;
        }
        // [SEQ.END]
    }

    // SLCO expression wrapper | partner[1] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 1 && 1 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[1] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean d_calling_0_n_0() {
        return c.partner[1] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state calling.
    private void exec_calling() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | calling -> busy | partner[1] = 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_0()) {
            return;
        }
        // SLCO expression | partner[1] = 4.
        if(d_calling_0_n_0()) {
            // [SEQ.START]
            // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[1] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_1()) {
                return;
            }
            // SLCO transition (p:0, id:2) | calling -> ringback | partner[1] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_2()) {
                return;
            }
            // [SEQ.END]
        }
        // SLCO transition (p:0, id:3) | calling -> busy | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] = 255; record[partner[1]] := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | calling -> calling | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] != 255 and callforwardbusy[partner[1]] != 255; record[partner[1]] := 1; partner[1] := callforwardbusy[partner[1]]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | calling -> oalert | [partner[1] != 1 and partner[1] != 4 and chan[partner[1]] = 255; record[partner[1]] := 1; chan[partner[1]] := (1 + 0 * 20); chan[1] := (partner[1] + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_5()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state busy.
    private void exec_busy() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[1] := 255; partner[1] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_busy_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state qi.
    private void exec_qi() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[1]] % 20) = 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[1]] % 20) != 1; partner[1] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state talert.
    private void exec_talert() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[1] = 255.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_0()) {
            return;
        }
        // [DET.START]
        // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[1]] % 20) = 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[1]] % 20) != 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state unobtainable.
    private void exec_unobtainable() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[1] := 255; partner[1] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_unobtainable_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state oalert.
    private void exec_oalert() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[1] % 20) != partner[1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[1] % 20) = partner[1] and (chan[1] / 20) = 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[1] % 20) = partner[1] and (chan[1] / 20) = 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state errorstate.
    private void exec_errorstate() {
        // There are no transitions starting in state errorstate.
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state oconnected.
    private void exec_oconnected() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[1] := 255; chan[partner[1]] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oconnected_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state dveoringout.
    private void exec_dveoringout() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[1] := 255; partner[1] := ((partner[1] % 20) + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dveoringout_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state tpickup.
    private void exec_tpickup() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[1]] % 20) = 1 and (chan[partner[1]] / 20) = 0; dev := 0; chan[partner[1]] := (1 + 1 * 20); chan[1] := (partner[1] + 1 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[1]] = 255 or (chan[partner[1]] % 20) != 1; dev := 1; partner[1] := 255; chan[1] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state tconnected.
    private void exec_tconnected() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[1] / 20) = 1 and dev = 0; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[1] / 20) = 1 and dev = 1; dev := 0].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[1] / 20) = 0; partner[1] := 255; chan[1] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state ringback.
    private void exec_ringback() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[1] := 255; partner[1] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | ringback -> calling | [record[1] != 255; partner[1] := record[1]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_1()) {
            return;
        }
        // [SEQ.END]
    }
}

// <<< STATE_MACHINE.END (User_1)

// >>> STATE_MACHINE.START (User_2)

// VerCors verification instructions for SLCO state machine User_2.
class GlobalClass_User_2Thread {
    // The class the state machine is a part of.
    private final GlobalClass c;

    // Thread local variables.
    private int dev;
    private int mbit;

    /*@
    // Ensure full access to the class members.
    ensures Perm(this.c, 1);

    // Require that the input class is a valid object.
    requires c != null;

    // Ensure that the appropriate starter values are assigned.
    ensures this.c == c;
    @*/
    GlobalClass_User_2Thread(GlobalClass c) {
        // Reference to the parent SLCO class.
        this.c = c;

        // Variable instantiations.
        dev = (char) 1;
        mbit = (char) 0;
    }

    // SLCO expression wrapper | chan[2] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[2] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_idle_0_s_0_n_0() {
        return c.chan[2] == 255;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    pure int value_idle_0_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[2] == 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_idle_0_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | idle -> dialing | [chan[2] = 255; dev := 0; chan[2] := (2 + 0 * 20)].
    private boolean execute_transition_idle_0() {
        // SLCO composite | [chan[2] = 255; dev := 0; chan[2] := ((2) + (0) * 20)] -> [chan[2] = 255; dev := 0; chan[2] := (2 + 0 * 20)].
        // SLCO expression | chan[2] = 255.
        //@ ghost _guard = c.chan[2] == 255;
        if(!(t_idle_0_s_0_n_0())) {
            //@ assert !(c.chan[2] == 255);
            return false;
        }
        //@ assert c.chan[2] == 255;
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        //@ ghost _rhs_0 = 0;
        dev = (0) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[2] := (2 + 0 * 20).
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_1 = (2 + 0 * 20);
        //@ ghost _index_1 = 2;
        c.chan[2] = ((2 + 0 * 20)) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;

        return true;
    }

    // SLCO expression wrapper | chan[2] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[2] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_idle_1_s_0_n_0() {
        return c.chan[2] != 255;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    pure int value_idle_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[2] != 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_idle_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | idle -> qi | [chan[2] != 255; partner[2] := (chan[2] % 20)].
    private boolean execute_transition_idle_1() {
        // SLCO composite | [chan[2] != 255; partner[2] := ((chan[2]) % 20)] -> [chan[2] != 255; partner[2] := (chan[2] % 20)].
        // SLCO expression | chan[2] != 255.
        //@ ghost _guard = c.chan[2] != 255;
        if(!(t_idle_1_s_0_n_0())) {
            //@ assert !(c.chan[2] != 255);
            return false;
        }
        //@ assert c.chan[2] != 255;
        // SLCO assignment | partner[2] := (chan[2] % 20).
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = (Math.floorMod(c.chan[2], 20));
        //@ ghost _index_0 = 2;
        c.partner[2] = ((Math.floorMod(c.chan[2], 20))) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[2]] % 20) = 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[2]], 20)) == 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_qi_0_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[2]], 20)) == 2;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[2]], 20)) == 2);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[2]] % 20) = 2.
    private boolean execute_transition_qi_0() {
        // SLCO expression | ((chan[partner[2]]) % 20) = 2 -> (chan[partner[2]] % 20) = 2.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[2]], 20)) == 2;
        if(!(t_qi_0_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[2]], 20)) == 2);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[2]], 20)) == 2;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[2]] % 20) != 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[2]], 20)) != 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_qi_1_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[2]], 20)) != 2;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    pure int value_qi_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[2]], 20)) != 2);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_qi_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[2]] % 20) != 2; partner[2] := 255].
    private boolean execute_transition_qi_1() {
        // SLCO composite | [((chan[partner[2]]) % 20) != 2; partner[2] := 255] -> [(chan[partner[2]] % 20) != 2; partner[2] := 255].
        // SLCO expression | (chan[partner[2]] % 20) != 2.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[2]], 20)) != 2;
        if(!(t_qi_1_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[2]], 20)) != 2);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[2]], 20)) != 2;
        // SLCO assignment | partner[2] := 255.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 2;
        c.partner[2] = (255) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_dialing_0_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_dialing_0_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[2] := 255].
    private boolean execute_transition_dialing_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [dev := 1; chan[2] := 255] -> [true; dev := 1; chan[2] := 255].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[2] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 2;
        c.chan[2] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        
    }

    /*@
    pure int value_dialing_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[2] := 0.
    private boolean execute_transition_dialing_1() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[2] := 0] -> partner[2] := 0.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 0;
        //@ ghost _index_0 = 2;
        c.partner[2] = (0) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        
    }

    /*@
    pure int value_dialing_2_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_2_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[2] := 1.
    private boolean execute_transition_dialing_2() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[2] := 1] -> partner[2] := 1.
        range_check_assumption_t_2_s_2();
        //@ ghost _rhs_0 = 1;
        //@ ghost _index_0 = 2;
        c.partner[2] = (1) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        
    }

    /*@
    pure int value_dialing_3_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_3_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[2] := 2.
    private boolean execute_transition_dialing_3() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[2] := 2] -> partner[2] := 2.
        range_check_assumption_t_3_s_2();
        //@ ghost _rhs_0 = 2;
        //@ ghost _index_0 = 2;
        c.partner[2] = (2) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        
    }

    /*@
    pure int value_dialing_4_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_4_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[2] := 3.
    private boolean execute_transition_dialing_4() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[2] := 3] -> partner[2] := 3.
        range_check_assumption_t_4_s_2();
        //@ ghost _rhs_0 = 3;
        //@ ghost _index_0 = 2;
        c.partner[2] = (3) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        
    }

    /*@
    pure int value_dialing_5_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_5_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[2] := 4.
    private boolean execute_transition_dialing_5() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[2] := 4] -> partner[2] := 4.
        range_check_assumption_t_5_s_2();
        //@ ghost _rhs_0 = 4;
        //@ ghost _index_0 = 2;
        c.partner[2] = (4) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | partner[2] = 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] == 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_0_s_0_n_0() {
        return c.partner[2] == 2;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[2] == 2);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | calling -> busy | partner[2] = 2.
    private boolean execute_transition_calling_0() {
        // SLCO expression | partner[2] = 2.
        //@ ghost _guard = c.partner[2] == 2;
        if(!(t_calling_0_s_0_n_0())) {
            //@ assert !(c.partner[2] == 2);
            return false;
        }
        //@ assert c.partner[2] == 2;

        return true;
    }

    // SLCO expression wrapper | partner[2] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_1_s_0_n_0() {
        return c.partner[2] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[2] == 4);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[2] = 4.
    private boolean execute_transition_calling_1() {
        // SLCO expression | partner[2] = 4.
        //@ ghost _guard = c.partner[2] == 4;
        if(!(t_calling_1_s_0_n_0())) {
            //@ assert !(c.partner[2] == 4);
            return false;
        }
        //@ assert c.partner[2] == 4;

        return true;
    }

    // SLCO expression wrapper | partner[2] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_2_s_0_n_0() {
        return c.partner[2] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[2] == 4);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | calling -> ringback | partner[2] = 4.
    private boolean execute_transition_calling_2() {
        // SLCO expression | partner[2] = 4.
        //@ ghost _guard = c.partner[2] == 4;
        if(!(t_calling_2_s_0_n_0())) {
            //@ assert !(c.partner[2] == 4);
            return false;
        }
        //@ assert c.partner[2] == 4;

        return true;
    }

    // SLCO expression wrapper | partner[2] != 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_0() {
        return c.partner[2] != 2;
    }

    // SLCO expression wrapper | partner[2] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_1() {
        return c.partner[2] != 4;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_2() {
        return t_calling_3_s_0_n_0() && t_calling_3_s_0_n_1();
    }

    // SLCO expression wrapper | chan[partner[2]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[2]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_3() {
        return c.chan[c.partner[2]] != 255;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_4() {
        return t_calling_3_s_0_n_2() && t_calling_3_s_0_n_3();
    }

    // SLCO expression wrapper | callforwardbusy[partner[2]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[2]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_5() {
        return c.callforwardbusy[c.partner[2]] == 255;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255 && c.callforwardbusy[c.partner[2]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_6() {
        return t_calling_3_s_0_n_4() && t_calling_3_s_0_n_5();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    pure int value_calling_3_record(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255 && c.callforwardbusy[c.partner[2]] == 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == value_calling_3_record(_i, _index_0, _rhs_0, \old(c.record[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:3) | calling -> busy | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] = 255; record[partner[2]] := 2].
    private boolean execute_transition_calling_3() {
        // SLCO composite | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] = 255; record[partner[2]] := 2].
        // SLCO expression | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] = 255.
        //@ ghost _guard = c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255 && c.callforwardbusy[c.partner[2]] == 255;
        if(!(t_calling_3_s_0_n_6())) {
            //@ assert !(c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255 && c.callforwardbusy[c.partner[2]] == 255);
            return false;
        }
        //@ assert c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255 && c.callforwardbusy[c.partner[2]] == 255;
        // SLCO assignment | record[partner[2]] := 2.
        range_check_assumption_t_3_s_2();
        //@ ghost _rhs_0 = 2;
        //@ ghost _index_0 = c.partner[2];
        c.record[c.partner[2]] = (2) & 0xff;
        //@ assert c.record[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | partner[2] != 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_0() {
        return c.partner[2] != 2;
    }

    // SLCO expression wrapper | partner[2] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_1() {
        return c.partner[2] != 4;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_2() {
        return t_calling_4_s_0_n_0() && t_calling_4_s_0_n_1();
    }

    // SLCO expression wrapper | chan[partner[2]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[2]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_3() {
        return c.chan[c.partner[2]] != 255;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_4() {
        return t_calling_4_s_0_n_2() && t_calling_4_s_0_n_3();
    }

    // SLCO expression wrapper | callforwardbusy[partner[2]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[2]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_5() {
        return c.callforwardbusy[c.partner[2]] != 255;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255 && c.callforwardbusy[c.partner[2]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_6() {
        return t_calling_4_s_0_n_4() && t_calling_4_s_0_n_5();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    pure int value_calling_4_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    pure int value_calling_4_record(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255 && c.callforwardbusy[c.partner[2]] != 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_calling_4_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == value_calling_4_record(_i, _index_0, _rhs_0, \old(c.record[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:4) | calling -> calling | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] != 255; record[partner[2]] := 2; partner[2] := callforwardbusy[partner[2]]].
    private boolean execute_transition_calling_4() {
        // SLCO composite | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] != 255; record[partner[2]] := 2; partner[2] := callforwardbusy[partner[2]]].
        // SLCO expression | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] != 255.
        //@ ghost _guard = c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255 && c.callforwardbusy[c.partner[2]] != 255;
        if(!(t_calling_4_s_0_n_6())) {
            //@ assert !(c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255 && c.callforwardbusy[c.partner[2]] != 255);
            return false;
        }
        //@ assert c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] != 255 && c.callforwardbusy[c.partner[2]] != 255;
        // SLCO assignment | record[partner[2]] := 2.
        range_check_assumption_t_4_s_2();
        //@ ghost _rhs_0 = 2;
        //@ ghost _index_0 = c.partner[2];
        c.record[c.partner[2]] = (2) & 0xff;
        //@ assert c.record[_index_0] == _rhs_0;
        // SLCO assignment | partner[2] := callforwardbusy[partner[2]].
        range_check_assumption_t_4_s_3();
        //@ ghost _rhs_1 = c.callforwardbusy[c.partner[2]];
        //@ ghost _index_1 = 2;
        c.partner[2] = (c.callforwardbusy[c.partner[2]]) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;

        return true;
    }

    // SLCO expression wrapper | partner[2] != 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_0() {
        return c.partner[2] != 2;
    }

    // SLCO expression wrapper | partner[2] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_1() {
        return c.partner[2] != 4;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_2() {
        return t_calling_5_s_0_n_0() && t_calling_5_s_0_n_1();
    }

    // SLCO expression wrapper | chan[partner[2]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[2]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_3() {
        return c.chan[c.partner[2]] == 255;
    }

    // SLCO expression wrapper | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_4() {
        return t_calling_5_s_0_n_2() && t_calling_5_s_0_n_3();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    pure int value_calling_5_chan(int _i, int _index_1, int _rhs_1, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : ((_i == _index_1) ? _rhs_1 : v_old);
    pure int value_calling_5_record(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] == 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_calling_5_chan(_i, _index_1, _rhs_1, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == value_calling_5_record(_i, _index_0, _rhs_0, \old(c.record[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:5) | calling -> oalert | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] = 255; record[partner[2]] := 2; chan[partner[2]] := (2 + 0 * 20); chan[2] := (partner[2] + 0 * 20)].
    private boolean execute_transition_calling_5() {
        // SLCO composite | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] = 255; record[partner[2]] := 2; chan[partner[2]] := ((2) + (0) * 20); chan[2] := ((partner[2]) + (0) * 20)] -> [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] = 255; record[partner[2]] := 2; chan[partner[2]] := (2 + 0 * 20); chan[2] := (partner[2] + 0 * 20)].
        // SLCO expression | partner[2] != 2 and partner[2] != 4 and chan[partner[2]] = 255.
        //@ ghost _guard = c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] == 255;
        if(!(t_calling_5_s_0_n_4())) {
            //@ assert !(c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] == 255);
            return false;
        }
        //@ assert c.partner[2] != 2 && c.partner[2] != 4 && c.chan[c.partner[2]] == 255;
        // SLCO assignment | record[partner[2]] := 2.
        range_check_assumption_t_5_s_2();
        //@ ghost _rhs_0 = 2;
        //@ ghost _index_0 = c.partner[2];
        c.record[c.partner[2]] = (2) & 0xff;
        //@ assert c.record[_index_0] == _rhs_0;
        // SLCO assignment | chan[partner[2]] := (2 + 0 * 20).
        range_check_assumption_t_5_s_3();
        //@ ghost _rhs_1 = (2 + 0 * 20);
        //@ ghost _index_1 = c.partner[2];
        c.chan[c.partner[2]] = ((2 + 0 * 20)) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | chan[2] := (partner[2] + 0 * 20).
        range_check_assumption_t_5_s_4();
        //@ ghost _rhs_2 = (c.partner[2] + 0 * 20);
        //@ ghost _index_2 = 2;
        c.chan[2] = ((c.partner[2] + 0 * 20)) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_busy_0_chan(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    pure int value_busy_0_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_busy_0_chan(_i, _index_0, _rhs_0, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_busy_0_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_2);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[2] := 255; partner[2] := 255; dev := 1].
    private boolean execute_transition_busy_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [chan[2] := 255; partner[2] := 255; dev := 1] -> [true; chan[2] := 255; partner[2] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | chan[2] := 255.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 2;
        c.chan[2] = (255) & 0xff;
        //@ assert c.chan[_index_0] == _rhs_0;
        // SLCO assignment | partner[2] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 2;
        c.partner[2] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | (chan[2] % 20) != partner[2].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[2], 20)) != c.partner[2]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_0_s_0_n_0() {
        return (Math.floorMod(c.chan[2], 20)) != c.partner[2];
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[2], 20)) != c.partner[2]);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[2] % 20) != partner[2].
    private boolean execute_transition_oalert_0() {
        // SLCO expression | ((chan[2]) % 20) != partner[2] -> (chan[2] % 20) != partner[2].
        //@ ghost _guard = (Math.floorMod(c.chan[2], 20)) != c.partner[2];
        if(!(t_oalert_0_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[2], 20)) != c.partner[2]);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[2], 20)) != c.partner[2];

        return true;
    }

    // SLCO expression wrapper | (chan[2] % 20) = partner[2].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[2], 20)) == c.partner[2]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_1_s_0_n_0() {
        return (Math.floorMod(c.chan[2], 20)) == c.partner[2];
    }

    // SLCO expression wrapper | (chan[2] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[2] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_1_s_0_n_1() {
        return (c.chan[2] / 20) == 1;
    }

    // SLCO expression wrapper | (chan[2] % 20) = partner[2] and (chan[2] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[2], 20)) == c.partner[2] && (c.chan[2] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_1_s_0_n_2() {
        return t_oalert_1_s_0_n_0() && t_oalert_1_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[2], 20)) == c.partner[2] && (c.chan[2] / 20) == 1);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[2] % 20) = partner[2] and (chan[2] / 20) = 1.
    private boolean execute_transition_oalert_1() {
        // SLCO expression | ((chan[2]) % 20) = partner[2] and ((chan[2]) / 20) = 1 -> (chan[2] % 20) = partner[2] and (chan[2] / 20) = 1.
        //@ ghost _guard = (Math.floorMod(c.chan[2], 20)) == c.partner[2] && (c.chan[2] / 20) == 1;
        if(!(t_oalert_1_s_0_n_2())) {
            //@ assert !((Math.floorMod(c.chan[2], 20)) == c.partner[2] && (c.chan[2] / 20) == 1);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[2], 20)) == c.partner[2] && (c.chan[2] / 20) == 1;

        return true;
    }

    // SLCO expression wrapper | (chan[2] % 20) = partner[2].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[2], 20)) == c.partner[2]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_2_s_0_n_0() {
        return (Math.floorMod(c.chan[2], 20)) == c.partner[2];
    }

    // SLCO expression wrapper | (chan[2] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[2] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_2_s_0_n_1() {
        return (c.chan[2] / 20) == 0;
    }

    // SLCO expression wrapper | (chan[2] % 20) = partner[2] and (chan[2] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[2], 20)) == c.partner[2] && (c.chan[2] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_2_s_0_n_2() {
        return t_oalert_2_s_0_n_0() && t_oalert_2_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[2], 20)) == c.partner[2] && (c.chan[2] / 20) == 0);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[2] % 20) = partner[2] and (chan[2] / 20) = 0.
    private boolean execute_transition_oalert_2() {
        // SLCO expression | ((chan[2]) % 20) = partner[2] and ((chan[2]) / 20) = 0 -> (chan[2] % 20) = partner[2] and (chan[2] / 20) = 0.
        //@ ghost _guard = (Math.floorMod(c.chan[2], 20)) == c.partner[2] && (c.chan[2] / 20) == 0;
        if(!(t_oalert_2_s_0_n_2())) {
            //@ assert !((Math.floorMod(c.chan[2], 20)) == c.partner[2] && (c.chan[2] / 20) == 0);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[2], 20)) == c.partner[2] && (c.chan[2] / 20) == 0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_oconnected_0_chan(int _i, int _index_1, int _rhs_1, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : ((_i == _index_1) ? _rhs_1 : v_old);
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_oconnected_0_chan(_i, _index_1, _rhs_1, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[2] := 255; chan[partner[2]] := 255].
    private boolean execute_transition_oconnected_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [dev := 1; chan[2] := 255; chan[partner[2]] := 255] -> [true; dev := 1; chan[2] := 255; chan[partner[2]] := 255].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[2] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 2;
        c.chan[2] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | chan[partner[2]] := 255.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 255;
        //@ ghost _index_2 = c.partner[2];
        c.chan[c.partner[2]] = (255) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_dveoringout_0_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    pure int value_dveoringout_0_partner(int _i, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_dveoringout_0_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dveoringout_0_partner(_i, _index_2, _rhs_2, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[2] := 255; partner[2] := ((partner[2] % 20) + 0 * 20)].
    private boolean execute_transition_dveoringout_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [dev := 1; chan[2] := 255; partner[2] := ((((partner[2]) % 20)) + (0) * 20)] -> [true; dev := 1; chan[2] := 255; partner[2] := ((partner[2] % 20) + 0 * 20)].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[2] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 2;
        c.chan[2] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | partner[2] := ((partner[2] % 20) + 0 * 20).
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = ((Math.floorMod(c.partner[2], 20)) + 0 * 20);
        //@ ghost _index_2 = 2;
        c.partner[2] = (((Math.floorMod(c.partner[2], 20)) + 0 * 20)) & 0xff;
        //@ assert c.partner[_index_2] == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_unobtainable_0_chan(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    pure int value_unobtainable_0_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_unobtainable_0_chan(_i, _index_0, _rhs_0, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_unobtainable_0_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_2);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[2] := 255; partner[2] := 255; dev := 1].
    private boolean execute_transition_unobtainable_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [chan[2] := 255; partner[2] := 255; dev := 1] -> [true; chan[2] := 255; partner[2] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | chan[2] := 255.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 2;
        c.chan[2] = (255) & 0xff;
        //@ assert c.chan[_index_0] == _rhs_0;
        // SLCO assignment | partner[2] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 2;
        c.partner[2] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_ringback_0_chan(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    pure int value_ringback_0_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_ringback_0_chan(_i, _index_0, _rhs_0, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_ringback_0_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_2);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[2] := 255; partner[2] := 255; dev := 1].
    private boolean execute_transition_ringback_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [chan[2] := 255; partner[2] := 255; dev := 1] -> [true; chan[2] := 255; partner[2] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | chan[2] := 255.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 2;
        c.chan[2] = (255) & 0xff;
        //@ assert c.chan[_index_0] == _rhs_0;
        // SLCO assignment | partner[2] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 2;
        c.partner[2] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | record[2] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.record[2] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_ringback_1_s_0_n_0() {
        return c.record[2] != 255;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    pure int value_ringback_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.record[2] != 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_ringback_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | ringback -> calling | [record[2] != 255; partner[2] := record[2]].
    private boolean execute_transition_ringback_1() {
        // SLCO composite | [record[2] != 255; partner[2] := record[2]].
        // SLCO expression | record[2] != 255.
        //@ ghost _guard = c.record[2] != 255;
        if(!(t_ringback_1_s_0_n_0())) {
            //@ assert !(c.record[2] != 255);
            return false;
        }
        //@ assert c.record[2] != 255;
        // SLCO assignment | partner[2] := record[2].
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = c.record[2];
        //@ ghost _index_0 = 2;
        c.partner[2] = (c.record[2]) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | dev != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_0_s_0_n_0() {
        return dev != 1;
    }

    // SLCO expression wrapper | chan[2] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[2] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_0_s_0_n_1() {
        return c.chan[2] == 255;
    }

    // SLCO expression wrapper | dev != 1 or chan[2] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1 || c.chan[2] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_0_s_0_n_2() {
        return t_talert_0_s_0_n_0() || t_talert_0_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(dev != 1 || c.chan[2] == 255);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[2] = 255.
    private boolean execute_transition_talert_0() {
        // SLCO expression | dev != 1 or chan[2] = 255.
        //@ ghost _guard = dev != 1 || c.chan[2] == 255;
        if(!(t_talert_0_s_0_n_2())) {
            //@ assert !(dev != 1 || c.chan[2] == 255);
            return false;
        }
        //@ assert dev != 1 || c.chan[2] == 255;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[2]] % 20) = 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[2]], 20)) == 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_1_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[2]], 20)) == 2;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[2]], 20)) == 2);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[2]] % 20) = 2.
    private boolean execute_transition_talert_1() {
        // SLCO expression | ((chan[partner[2]]) % 20) = 2 -> (chan[partner[2]] % 20) = 2.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[2]], 20)) == 2;
        if(!(t_talert_1_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[2]], 20)) == 2);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[2]], 20)) == 2;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[2]] % 20) != 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[2]], 20)) != 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_2_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[2]], 20)) != 2;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[2]], 20)) != 2);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[2]] % 20) != 2.
    private boolean execute_transition_talert_2() {
        // SLCO expression | ((chan[partner[2]]) % 20) != 2 -> (chan[partner[2]] % 20) != 2.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[2]], 20)) != 2;
        if(!(t_talert_2_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[2]], 20)) != 2);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[2]], 20)) != 2;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[2]] % 20) = 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[2]], 20)) == 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_0_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[2]], 20)) == 2;
    }

    // SLCO expression wrapper | (chan[partner[2]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[c.partner[2]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_0_s_0_n_1() {
        return (c.chan[c.partner[2]] / 20) == 0;
    }

    // SLCO expression wrapper | (chan[partner[2]] % 20) = 2 and (chan[partner[2]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[2]], 20)) == 2 && (c.chan[c.partner[2]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_0_s_0_n_2() {
        return t_tpickup_0_s_0_n_0() && t_tpickup_0_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    pure int value_tpickup_0_chan(int _i, int _index_1, int _rhs_1, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : ((_i == _index_1) ? _rhs_1 : v_old);
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[2]], 20)) == 2 && (c.chan[c.partner[2]] / 20) == 0);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_tpickup_0_chan(_i, _index_1, _rhs_1, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[2]] % 20) = 2 and (chan[partner[2]] / 20) = 0; dev := 0; chan[partner[2]] := (2 + 1 * 20); chan[2] := (partner[2] + 1 * 20)].
    private boolean execute_transition_tpickup_0() {
        // SLCO composite | [((chan[partner[2]]) % 20) = 2 and ((chan[partner[2]]) / 20) = 0; dev := 0; chan[partner[2]] := ((2) + (1) * 20); chan[2] := ((partner[2]) + (1) * 20)] -> [(chan[partner[2]] % 20) = 2 and (chan[partner[2]] / 20) = 0; dev := 0; chan[partner[2]] := (2 + 1 * 20); chan[2] := (partner[2] + 1 * 20)].
        // SLCO expression | (chan[partner[2]] % 20) = 2 and (chan[partner[2]] / 20) = 0.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[2]], 20)) == 2 && (c.chan[c.partner[2]] / 20) == 0;
        if(!(t_tpickup_0_s_0_n_2())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[2]], 20)) == 2 && (c.chan[c.partner[2]] / 20) == 0);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[2]], 20)) == 2 && (c.chan[c.partner[2]] / 20) == 0;
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        //@ ghost _rhs_0 = 0;
        dev = (0) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[partner[2]] := (2 + 1 * 20).
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_1 = (2 + 1 * 20);
        //@ ghost _index_1 = c.partner[2];
        c.chan[c.partner[2]] = ((2 + 1 * 20)) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | chan[2] := (partner[2] + 1 * 20).
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_2 = (c.partner[2] + 1 * 20);
        //@ ghost _index_2 = 2;
        c.chan[2] = ((c.partner[2] + 1 * 20)) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | chan[partner[2]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[2]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_1_s_0_n_0() {
        return c.chan[c.partner[2]] == 255;
    }

    // SLCO expression wrapper | (chan[partner[2]] % 20) != 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[2]], 20)) != 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_1_s_0_n_1() {
        return (Math.floorMod(c.chan[c.partner[2]], 20)) != 2;
    }

    // SLCO expression wrapper | chan[partner[2]] = 255 or (chan[partner[2]] % 20) != 2.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;
    context 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[2]] == 255 || (Math.floorMod(c.chan[c.partner[2]], 20)) != 2);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_1_s_0_n_2() {
        return t_tpickup_1_s_0_n_0() || t_tpickup_1_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;
    ensures 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
        //@ assume 0 <= c.partner[2] && c.partner[2] < 4;
    }

    /*@
    pure int value_tpickup_1_chan(int _i, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : v_old;
    pure int value_tpickup_1_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;
    requires 0 <= c.partner[2] && c.partner[2] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[c.partner[2]] == 255 || (Math.floorMod(c.chan[c.partner[2]], 20)) != 2);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_tpickup_1_chan(_i, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_tpickup_1_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[2]] = 255 or (chan[partner[2]] % 20) != 2; dev := 1; partner[2] := 255; chan[2] := 255].
    private boolean execute_transition_tpickup_1() {
        // SLCO composite | [chan[partner[2]] = 255 or ((chan[partner[2]]) % 20) != 2; dev := 1; partner[2] := 255; chan[2] := 255] -> [chan[partner[2]] = 255 or (chan[partner[2]] % 20) != 2; dev := 1; partner[2] := 255; chan[2] := 255].
        // SLCO expression | chan[partner[2]] = 255 or (chan[partner[2]] % 20) != 2.
        //@ ghost _guard = c.chan[c.partner[2]] == 255 || (Math.floorMod(c.chan[c.partner[2]], 20)) != 2;
        if(!(t_tpickup_1_s_0_n_2())) {
            //@ assert !(c.chan[c.partner[2]] == 255 || (Math.floorMod(c.chan[c.partner[2]], 20)) != 2);
            return false;
        }
        //@ assert c.chan[c.partner[2]] == 255 || (Math.floorMod(c.chan[c.partner[2]], 20)) != 2;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | partner[2] := 255.
        range_check_assumption_t_1_s_3();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 2;
        c.partner[2] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | chan[2] := 255.
        range_check_assumption_t_1_s_4();
        //@ ghost _rhs_2 = 255;
        //@ ghost _index_2 = 2;
        c.chan[2] = (255) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | (chan[2] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[2] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_0_s_0_n_0() {
        return (c.chan[2] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_0_s_0_n_1() {
        return dev == 0;
    }

    // SLCO expression wrapper | (chan[2] / 20) = 1 and dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[2] / 20) == 1 && dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_0_s_0_n_2() {
        return t_tconnected_0_s_0_n_0() && t_tconnected_0_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[2] / 20) == 1 && dev == 0);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[2] / 20) = 1 and dev = 0; dev := 1].
    private boolean execute_transition_tconnected_0() {
        // SLCO composite | [((chan[2]) / 20) = 1 and dev = 0; dev := 1] -> [(chan[2] / 20) = 1 and dev = 0; dev := 1].
        // SLCO expression | (chan[2] / 20) = 1 and dev = 0.
        //@ ghost _guard = (c.chan[2] / 20) == 1 && dev == 0;
        if(!(t_tconnected_0_s_0_n_2())) {
            //@ assert !((c.chan[2] / 20) == 1 && dev == 0);
            return false;
        }
        //@ assert (c.chan[2] / 20) == 1 && dev == 0;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_2();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | (chan[2] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[2] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_1_s_0_n_0() {
        return (c.chan[2] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_1_s_0_n_1() {
        return dev == 1;
    }

    // SLCO expression wrapper | (chan[2] / 20) = 1 and dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[2] / 20) == 1 && dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_1_s_0_n_2() {
        return t_tconnected_1_s_0_n_0() && t_tconnected_1_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[2] / 20) == 1 && dev == 1);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[2] / 20) = 1 and dev = 1; dev := 0].
    private boolean execute_transition_tconnected_1() {
        // SLCO composite | [((chan[2]) / 20) = 1 and dev = 1; dev := 0] -> [(chan[2] / 20) = 1 and dev = 1; dev := 0].
        // SLCO expression | (chan[2] / 20) = 1 and dev = 1.
        //@ ghost _guard = (c.chan[2] / 20) == 1 && dev == 1;
        if(!(t_tconnected_1_s_0_n_2())) {
            //@ assert !((c.chan[2] / 20) == 1 && dev == 1);
            return false;
        }
        //@ assert (c.chan[2] / 20) == 1 && dev == 1;
        // SLCO assignment | dev := 0.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 0;
        dev = (0) & 0xff;
        //@ assert dev == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | (chan[2] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[2] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_2_s_0_n_0() {
        return (c.chan[2] / 20) == 0;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 2 && 2 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 2 && 2 < 4;
    }

    /*@
    pure int value_tconnected_2_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    pure int value_tconnected_2_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[2] / 20) == 0);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_tconnected_2_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_tconnected_2_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[2] / 20) = 0; partner[2] := 255; chan[2] := 255].
    private boolean execute_transition_tconnected_2() {
        // SLCO composite | [((chan[2]) / 20) = 0; partner[2] := 255; chan[2] := 255] -> [(chan[2] / 20) = 0; partner[2] := 255; chan[2] := 255].
        // SLCO expression | (chan[2] / 20) = 0.
        //@ ghost _guard = (c.chan[2] / 20) == 0;
        if(!(t_tconnected_2_s_0_n_0())) {
            //@ assert !((c.chan[2] / 20) == 0);
            return false;
        }
        //@ assert (c.chan[2] / 20) == 0;
        // SLCO assignment | partner[2] := 255.
        range_check_assumption_t_2_s_2();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 2;
        c.partner[2] = (255) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;
        // SLCO assignment | chan[2] := 255.
        range_check_assumption_t_2_s_3();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 2;
        c.chan[2] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state idle.
    private void exec_idle() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | idle -> dialing | [chan[2] = 255; dev := 0; chan[2] := (2 + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | idle -> qi | [chan[2] != 255; partner[2] := (chan[2] % 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state dialing.
    private void exec_dialing() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[2] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[2] := 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[2] := 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_2()) {
            return;
        }
        // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[2] := 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[2] := 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[2] := 4.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_5()) {
            return;
        }
        // [SEQ.END]
    }

    // SLCO expression wrapper | partner[2] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 2 && 2 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[2] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean d_calling_0_n_0() {
        return c.partner[2] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state calling.
    private void exec_calling() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | calling -> busy | partner[2] = 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_0()) {
            return;
        }
        // SLCO expression | partner[2] = 4.
        if(d_calling_0_n_0()) {
            // [SEQ.START]
            // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[2] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_1()) {
                return;
            }
            // SLCO transition (p:0, id:2) | calling -> ringback | partner[2] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_2()) {
                return;
            }
            // [SEQ.END]
        }
        // SLCO transition (p:0, id:3) | calling -> busy | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] = 255; record[partner[2]] := 2].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | calling -> calling | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] != 255 and callforwardbusy[partner[2]] != 255; record[partner[2]] := 2; partner[2] := callforwardbusy[partner[2]]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | calling -> oalert | [partner[2] != 2 and partner[2] != 4 and chan[partner[2]] = 255; record[partner[2]] := 2; chan[partner[2]] := (2 + 0 * 20); chan[2] := (partner[2] + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_5()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state busy.
    private void exec_busy() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[2] := 255; partner[2] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_busy_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state qi.
    private void exec_qi() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[2]] % 20) = 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[2]] % 20) != 2; partner[2] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state talert.
    private void exec_talert() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[2] = 255.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_0()) {
            return;
        }
        // [DET.START]
        // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[2]] % 20) = 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[2]] % 20) != 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state unobtainable.
    private void exec_unobtainable() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[2] := 255; partner[2] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_unobtainable_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state oalert.
    private void exec_oalert() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[2] % 20) != partner[2].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[2] % 20) = partner[2] and (chan[2] / 20) = 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[2] % 20) = partner[2] and (chan[2] / 20) = 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state errorstate.
    private void exec_errorstate() {
        // There are no transitions starting in state errorstate.
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state oconnected.
    private void exec_oconnected() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[2] := 255; chan[partner[2]] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oconnected_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state dveoringout.
    private void exec_dveoringout() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[2] := 255; partner[2] := ((partner[2] % 20) + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dveoringout_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state tpickup.
    private void exec_tpickup() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[2]] % 20) = 2 and (chan[partner[2]] / 20) = 0; dev := 0; chan[partner[2]] := (2 + 1 * 20); chan[2] := (partner[2] + 1 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[2]] = 255 or (chan[partner[2]] % 20) != 2; dev := 1; partner[2] := 255; chan[2] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state tconnected.
    private void exec_tconnected() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[2] / 20) = 1 and dev = 0; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[2] / 20) = 1 and dev = 1; dev := 0].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[2] / 20) = 0; partner[2] := 255; chan[2] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state ringback.
    private void exec_ringback() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[2] := 255; partner[2] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | ringback -> calling | [record[2] != 255; partner[2] := record[2]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_1()) {
            return;
        }
        // [SEQ.END]
    }
}

// <<< STATE_MACHINE.END (User_2)

// >>> STATE_MACHINE.START (User_3)

// VerCors verification instructions for SLCO state machine User_3.
class GlobalClass_User_3Thread {
    // The class the state machine is a part of.
    private final GlobalClass c;

    // Thread local variables.
    private int dev;
    private int mbit;

    /*@
    // Ensure full access to the class members.
    ensures Perm(this.c, 1);

    // Require that the input class is a valid object.
    requires c != null;

    // Ensure that the appropriate starter values are assigned.
    ensures this.c == c;
    @*/
    GlobalClass_User_3Thread(GlobalClass c) {
        // Reference to the parent SLCO class.
        this.c = c;

        // Variable instantiations.
        dev = (char) 1;
        mbit = (char) 0;
    }

    // SLCO expression wrapper | chan[3] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[3] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_idle_0_s_0_n_0() {
        return c.chan[3] == 255;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    pure int value_idle_0_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[3] == 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_idle_0_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | idle -> dialing | [chan[3] = 255; dev := 0; chan[3] := (3 + 0 * 20)].
    private boolean execute_transition_idle_0() {
        // SLCO composite | [chan[3] = 255; dev := 0; chan[3] := ((3) + (0) * 20)] -> [chan[3] = 255; dev := 0; chan[3] := (3 + 0 * 20)].
        // SLCO expression | chan[3] = 255.
        //@ ghost _guard = c.chan[3] == 255;
        if(!(t_idle_0_s_0_n_0())) {
            //@ assert !(c.chan[3] == 255);
            return false;
        }
        //@ assert c.chan[3] == 255;
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        //@ ghost _rhs_0 = 0;
        dev = (0) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[3] := (3 + 0 * 20).
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_1 = (3 + 0 * 20);
        //@ ghost _index_1 = 3;
        c.chan[3] = ((3 + 0 * 20)) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;

        return true;
    }

    // SLCO expression wrapper | chan[3] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[3] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_idle_1_s_0_n_0() {
        return c.chan[3] != 255;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    pure int value_idle_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[3] != 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_idle_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | idle -> qi | [chan[3] != 255; partner[3] := (chan[3] % 20)].
    private boolean execute_transition_idle_1() {
        // SLCO composite | [chan[3] != 255; partner[3] := ((chan[3]) % 20)] -> [chan[3] != 255; partner[3] := (chan[3] % 20)].
        // SLCO expression | chan[3] != 255.
        //@ ghost _guard = c.chan[3] != 255;
        if(!(t_idle_1_s_0_n_0())) {
            //@ assert !(c.chan[3] != 255);
            return false;
        }
        //@ assert c.chan[3] != 255;
        // SLCO assignment | partner[3] := (chan[3] % 20).
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = (Math.floorMod(c.chan[3], 20));
        //@ ghost _index_0 = 3;
        c.partner[3] = ((Math.floorMod(c.chan[3], 20))) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[3]] % 20) = 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[3]], 20)) == 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_qi_0_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[3]], 20)) == 3;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[3]], 20)) == 3);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[3]] % 20) = 3.
    private boolean execute_transition_qi_0() {
        // SLCO expression | ((chan[partner[3]]) % 20) = 3 -> (chan[partner[3]] % 20) = 3.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[3]], 20)) == 3;
        if(!(t_qi_0_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[3]], 20)) == 3);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[3]], 20)) == 3;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[3]] % 20) != 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[3]], 20)) != 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_qi_1_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[3]], 20)) != 3;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    pure int value_qi_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[3]], 20)) != 3);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_qi_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[3]] % 20) != 3; partner[3] := 255].
    private boolean execute_transition_qi_1() {
        // SLCO composite | [((chan[partner[3]]) % 20) != 3; partner[3] := 255] -> [(chan[partner[3]] % 20) != 3; partner[3] := 255].
        // SLCO expression | (chan[partner[3]] % 20) != 3.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[3]], 20)) != 3;
        if(!(t_qi_1_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[3]], 20)) != 3);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[3]], 20)) != 3;
        // SLCO assignment | partner[3] := 255.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 3;
        c.partner[3] = (255) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_dialing_0_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_dialing_0_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[3] := 255].
    private boolean execute_transition_dialing_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [dev := 1; chan[3] := 255] -> [true; dev := 1; chan[3] := 255].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[3] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 3;
        c.chan[3] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        
    }

    /*@
    pure int value_dialing_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[3] := 0.
    private boolean execute_transition_dialing_1() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[3] := 0] -> partner[3] := 0.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 0;
        //@ ghost _index_0 = 3;
        c.partner[3] = (0) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        
    }

    /*@
    pure int value_dialing_2_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_2_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[3] := 1.
    private boolean execute_transition_dialing_2() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[3] := 1] -> partner[3] := 1.
        range_check_assumption_t_2_s_2();
        //@ ghost _rhs_0 = 1;
        //@ ghost _index_0 = 3;
        c.partner[3] = (1) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        
    }

    /*@
    pure int value_dialing_3_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_3_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[3] := 2.
    private boolean execute_transition_dialing_3() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[3] := 2] -> partner[3] := 2.
        range_check_assumption_t_3_s_2();
        //@ ghost _rhs_0 = 2;
        //@ ghost _index_0 = 3;
        c.partner[3] = (2) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        
    }

    /*@
    pure int value_dialing_4_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_4_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[3] := 3.
    private boolean execute_transition_dialing_4() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[3] := 3] -> partner[3] := 3.
        range_check_assumption_t_4_s_2();
        //@ ghost _rhs_0 = 3;
        //@ ghost _index_0 = 3;
        c.partner[3] = (3) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        
    }

    /*@
    pure int value_dialing_5_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dialing_5_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[3] := 4.
    private boolean execute_transition_dialing_5() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO assignment | [partner[3] := 4] -> partner[3] := 4.
        range_check_assumption_t_5_s_2();
        //@ ghost _rhs_0 = 4;
        //@ ghost _index_0 = 3;
        c.partner[3] = (4) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | partner[3] = 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] == 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_0_s_0_n_0() {
        return c.partner[3] == 3;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[3] == 3);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | calling -> busy | partner[3] = 3.
    private boolean execute_transition_calling_0() {
        // SLCO expression | partner[3] = 3.
        //@ ghost _guard = c.partner[3] == 3;
        if(!(t_calling_0_s_0_n_0())) {
            //@ assert !(c.partner[3] == 3);
            return false;
        }
        //@ assert c.partner[3] == 3;

        return true;
    }

    // SLCO expression wrapper | partner[3] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_1_s_0_n_0() {
        return c.partner[3] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[3] == 4);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[3] = 4.
    private boolean execute_transition_calling_1() {
        // SLCO expression | partner[3] = 4.
        //@ ghost _guard = c.partner[3] == 4;
        if(!(t_calling_1_s_0_n_0())) {
            //@ assert !(c.partner[3] == 4);
            return false;
        }
        //@ assert c.partner[3] == 4;

        return true;
    }

    // SLCO expression wrapper | partner[3] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_2_s_0_n_0() {
        return c.partner[3] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[3] == 4);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | calling -> ringback | partner[3] = 4.
    private boolean execute_transition_calling_2() {
        // SLCO expression | partner[3] = 4.
        //@ ghost _guard = c.partner[3] == 4;
        if(!(t_calling_2_s_0_n_0())) {
            //@ assert !(c.partner[3] == 4);
            return false;
        }
        //@ assert c.partner[3] == 4;

        return true;
    }

    // SLCO expression wrapper | partner[3] != 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_0() {
        return c.partner[3] != 3;
    }

    // SLCO expression wrapper | partner[3] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_1() {
        return c.partner[3] != 4;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_2() {
        return t_calling_3_s_0_n_0() && t_calling_3_s_0_n_1();
    }

    // SLCO expression wrapper | chan[partner[3]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[3]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_3() {
        return c.chan[c.partner[3]] != 255;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_4() {
        return t_calling_3_s_0_n_2() && t_calling_3_s_0_n_3();
    }

    // SLCO expression wrapper | callforwardbusy[partner[3]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[3]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_5() {
        return c.callforwardbusy[c.partner[3]] == 255;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255 && c.callforwardbusy[c.partner[3]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_3_s_0_n_6() {
        return t_calling_3_s_0_n_4() && t_calling_3_s_0_n_5();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    pure int value_calling_3_record(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255 && c.callforwardbusy[c.partner[3]] == 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == value_calling_3_record(_i, _index_0, _rhs_0, \old(c.record[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:3) | calling -> busy | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] = 255; record[partner[3]] := 3].
    private boolean execute_transition_calling_3() {
        // SLCO composite | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] = 255; record[partner[3]] := 3].
        // SLCO expression | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] = 255.
        //@ ghost _guard = c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255 && c.callforwardbusy[c.partner[3]] == 255;
        if(!(t_calling_3_s_0_n_6())) {
            //@ assert !(c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255 && c.callforwardbusy[c.partner[3]] == 255);
            return false;
        }
        //@ assert c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255 && c.callforwardbusy[c.partner[3]] == 255;
        // SLCO assignment | record[partner[3]] := 3.
        range_check_assumption_t_3_s_2();
        //@ ghost _rhs_0 = 3;
        //@ ghost _index_0 = c.partner[3];
        c.record[c.partner[3]] = (3) & 0xff;
        //@ assert c.record[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | partner[3] != 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_0() {
        return c.partner[3] != 3;
    }

    // SLCO expression wrapper | partner[3] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_1() {
        return c.partner[3] != 4;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_2() {
        return t_calling_4_s_0_n_0() && t_calling_4_s_0_n_1();
    }

    // SLCO expression wrapper | chan[partner[3]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[3]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_3() {
        return c.chan[c.partner[3]] != 255;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_4() {
        return t_calling_4_s_0_n_2() && t_calling_4_s_0_n_3();
    }

    // SLCO expression wrapper | callforwardbusy[partner[3]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.callforwardbusy[c.partner[3]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_5() {
        return c.callforwardbusy[c.partner[3]] != 255;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255 && c.callforwardbusy[c.partner[3]] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_4_s_0_n_6() {
        return t_calling_4_s_0_n_4() && t_calling_4_s_0_n_5();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    pure int value_calling_4_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    pure int value_calling_4_record(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255 && c.callforwardbusy[c.partner[3]] != 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_calling_4_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == value_calling_4_record(_i, _index_0, _rhs_0, \old(c.record[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:4) | calling -> calling | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] != 255; record[partner[3]] := 3; partner[3] := callforwardbusy[partner[3]]].
    private boolean execute_transition_calling_4() {
        // SLCO composite | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] != 255; record[partner[3]] := 3; partner[3] := callforwardbusy[partner[3]]].
        // SLCO expression | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] != 255.
        //@ ghost _guard = c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255 && c.callforwardbusy[c.partner[3]] != 255;
        if(!(t_calling_4_s_0_n_6())) {
            //@ assert !(c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255 && c.callforwardbusy[c.partner[3]] != 255);
            return false;
        }
        //@ assert c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] != 255 && c.callforwardbusy[c.partner[3]] != 255;
        // SLCO assignment | record[partner[3]] := 3.
        range_check_assumption_t_4_s_2();
        //@ ghost _rhs_0 = 3;
        //@ ghost _index_0 = c.partner[3];
        c.record[c.partner[3]] = (3) & 0xff;
        //@ assert c.record[_index_0] == _rhs_0;
        // SLCO assignment | partner[3] := callforwardbusy[partner[3]].
        range_check_assumption_t_4_s_3();
        //@ ghost _rhs_1 = c.callforwardbusy[c.partner[3]];
        //@ ghost _index_1 = 3;
        c.partner[3] = (c.callforwardbusy[c.partner[3]]) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;

        return true;
    }

    // SLCO expression wrapper | partner[3] != 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_0() {
        return c.partner[3] != 3;
    }

    // SLCO expression wrapper | partner[3] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_1() {
        return c.partner[3] != 4;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_2() {
        return t_calling_5_s_0_n_0() && t_calling_5_s_0_n_1();
    }

    // SLCO expression wrapper | chan[partner[3]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[3]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_3() {
        return c.chan[c.partner[3]] == 255;
    }

    // SLCO expression wrapper | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_calling_5_s_0_n_4() {
        return t_calling_5_s_0_n_2() && t_calling_5_s_0_n_3();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    pure int value_calling_5_chan(int _i, int _index_1, int _rhs_1, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : ((_i == _index_1) ? _rhs_1 : v_old);
    pure int value_calling_5_record(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] == 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_calling_5_chan(_i, _index_1, _rhs_1, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == value_calling_5_record(_i, _index_0, _rhs_0, \old(c.record[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:5) | calling -> oalert | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] = 255; record[partner[3]] := 3; chan[partner[3]] := (3 + 0 * 20); chan[3] := (partner[3] + 0 * 20)].
    private boolean execute_transition_calling_5() {
        // SLCO composite | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] = 255; record[partner[3]] := 3; chan[partner[3]] := ((3) + (0) * 20); chan[3] := ((partner[3]) + (0) * 20)] -> [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] = 255; record[partner[3]] := 3; chan[partner[3]] := (3 + 0 * 20); chan[3] := (partner[3] + 0 * 20)].
        // SLCO expression | partner[3] != 3 and partner[3] != 4 and chan[partner[3]] = 255.
        //@ ghost _guard = c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] == 255;
        if(!(t_calling_5_s_0_n_4())) {
            //@ assert !(c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] == 255);
            return false;
        }
        //@ assert c.partner[3] != 3 && c.partner[3] != 4 && c.chan[c.partner[3]] == 255;
        // SLCO assignment | record[partner[3]] := 3.
        range_check_assumption_t_5_s_2();
        //@ ghost _rhs_0 = 3;
        //@ ghost _index_0 = c.partner[3];
        c.record[c.partner[3]] = (3) & 0xff;
        //@ assert c.record[_index_0] == _rhs_0;
        // SLCO assignment | chan[partner[3]] := (3 + 0 * 20).
        range_check_assumption_t_5_s_3();
        //@ ghost _rhs_1 = (3 + 0 * 20);
        //@ ghost _index_1 = c.partner[3];
        c.chan[c.partner[3]] = ((3 + 0 * 20)) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | chan[3] := (partner[3] + 0 * 20).
        range_check_assumption_t_5_s_4();
        //@ ghost _rhs_2 = (c.partner[3] + 0 * 20);
        //@ ghost _index_2 = 3;
        c.chan[3] = ((c.partner[3] + 0 * 20)) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_busy_0_chan(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    pure int value_busy_0_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_busy_0_chan(_i, _index_0, _rhs_0, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_busy_0_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_2);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[3] := 255; partner[3] := 255; dev := 1].
    private boolean execute_transition_busy_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [chan[3] := 255; partner[3] := 255; dev := 1] -> [true; chan[3] := 255; partner[3] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | chan[3] := 255.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 3;
        c.chan[3] = (255) & 0xff;
        //@ assert c.chan[_index_0] == _rhs_0;
        // SLCO assignment | partner[3] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 3;
        c.partner[3] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | (chan[3] % 20) != partner[3].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[3], 20)) != c.partner[3]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_0_s_0_n_0() {
        return (Math.floorMod(c.chan[3], 20)) != c.partner[3];
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[3], 20)) != c.partner[3]);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[3] % 20) != partner[3].
    private boolean execute_transition_oalert_0() {
        // SLCO expression | ((chan[3]) % 20) != partner[3] -> (chan[3] % 20) != partner[3].
        //@ ghost _guard = (Math.floorMod(c.chan[3], 20)) != c.partner[3];
        if(!(t_oalert_0_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[3], 20)) != c.partner[3]);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[3], 20)) != c.partner[3];

        return true;
    }

    // SLCO expression wrapper | (chan[3] % 20) = partner[3].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[3], 20)) == c.partner[3]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_1_s_0_n_0() {
        return (Math.floorMod(c.chan[3], 20)) == c.partner[3];
    }

    // SLCO expression wrapper | (chan[3] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[3] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_1_s_0_n_1() {
        return (c.chan[3] / 20) == 1;
    }

    // SLCO expression wrapper | (chan[3] % 20) = partner[3] and (chan[3] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[3], 20)) == c.partner[3] && (c.chan[3] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_1_s_0_n_2() {
        return t_oalert_1_s_0_n_0() && t_oalert_1_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[3], 20)) == c.partner[3] && (c.chan[3] / 20) == 1);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[3] % 20) = partner[3] and (chan[3] / 20) = 1.
    private boolean execute_transition_oalert_1() {
        // SLCO expression | ((chan[3]) % 20) = partner[3] and ((chan[3]) / 20) = 1 -> (chan[3] % 20) = partner[3] and (chan[3] / 20) = 1.
        //@ ghost _guard = (Math.floorMod(c.chan[3], 20)) == c.partner[3] && (c.chan[3] / 20) == 1;
        if(!(t_oalert_1_s_0_n_2())) {
            //@ assert !((Math.floorMod(c.chan[3], 20)) == c.partner[3] && (c.chan[3] / 20) == 1);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[3], 20)) == c.partner[3] && (c.chan[3] / 20) == 1;

        return true;
    }

    // SLCO expression wrapper | (chan[3] % 20) = partner[3].
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[3], 20)) == c.partner[3]);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_2_s_0_n_0() {
        return (Math.floorMod(c.chan[3], 20)) == c.partner[3];
    }

    // SLCO expression wrapper | (chan[3] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[3] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_2_s_0_n_1() {
        return (c.chan[3] / 20) == 0;
    }

    // SLCO expression wrapper | (chan[3] % 20) = partner[3] and (chan[3] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[3], 20)) == c.partner[3] && (c.chan[3] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_oalert_2_s_0_n_2() {
        return t_oalert_2_s_0_n_0() && t_oalert_2_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[3], 20)) == c.partner[3] && (c.chan[3] / 20) == 0);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[3] % 20) = partner[3] and (chan[3] / 20) = 0.
    private boolean execute_transition_oalert_2() {
        // SLCO expression | ((chan[3]) % 20) = partner[3] and ((chan[3]) / 20) = 0 -> (chan[3] % 20) = partner[3] and (chan[3] / 20) = 0.
        //@ ghost _guard = (Math.floorMod(c.chan[3], 20)) == c.partner[3] && (c.chan[3] / 20) == 0;
        if(!(t_oalert_2_s_0_n_2())) {
            //@ assert !((Math.floorMod(c.chan[3], 20)) == c.partner[3] && (c.chan[3] / 20) == 0);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[3], 20)) == c.partner[3] && (c.chan[3] / 20) == 0;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_oconnected_0_chan(int _i, int _index_1, int _rhs_1, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : ((_i == _index_1) ? _rhs_1 : v_old);
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_oconnected_0_chan(_i, _index_1, _rhs_1, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[3] := 255; chan[partner[3]] := 255].
    private boolean execute_transition_oconnected_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [dev := 1; chan[3] := 255; chan[partner[3]] := 255] -> [true; dev := 1; chan[3] := 255; chan[partner[3]] := 255].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[3] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 3;
        c.chan[3] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | chan[partner[3]] := 255.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 255;
        //@ ghost _index_2 = c.partner[3];
        c.chan[c.partner[3]] = (255) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_dveoringout_0_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    pure int value_dveoringout_0_partner(int _i, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_dveoringout_0_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_dveoringout_0_partner(_i, _index_2, _rhs_2, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[3] := 255; partner[3] := ((partner[3] % 20) + 0 * 20)].
    private boolean execute_transition_dveoringout_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [dev := 1; chan[3] := 255; partner[3] := ((((partner[3]) % 20)) + (0) * 20)] -> [true; dev := 1; chan[3] := 255; partner[3] := ((partner[3] % 20) + 0 * 20)].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[3] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 3;
        c.chan[3] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | partner[3] := ((partner[3] % 20) + 0 * 20).
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = ((Math.floorMod(c.partner[3], 20)) + 0 * 20);
        //@ ghost _index_2 = 3;
        c.partner[3] = (((Math.floorMod(c.partner[3], 20)) + 0 * 20)) & 0xff;
        //@ assert c.partner[_index_2] == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_unobtainable_0_chan(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    pure int value_unobtainable_0_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_unobtainable_0_chan(_i, _index_0, _rhs_0, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_unobtainable_0_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_2);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[3] := 255; partner[3] := 255; dev := 1].
    private boolean execute_transition_unobtainable_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [chan[3] := 255; partner[3] := 255; dev := 1] -> [true; chan[3] := 255; partner[3] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | chan[3] := 255.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 3;
        c.chan[3] = (255) & 0xff;
        //@ assert c.chan[_index_0] == _rhs_0;
        // SLCO assignment | partner[3] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 3;
        c.partner[3] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_2;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_5() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        
    }

    /*@
    pure int value_ringback_0_chan(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    pure int value_ringback_0_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(true);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_ringback_0_chan(_i, _index_0, _rhs_0, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_ringback_0_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_2);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[3] := 255; partner[3] := 255; dev := 1].
    private boolean execute_transition_ringback_0() {
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;

        // SLCO composite | [chan[3] := 255; partner[3] := 255; dev := 1] -> [true; chan[3] := 255; partner[3] := 255; dev := 1].
        // (Superfluous) SLCO expression | true.
        //@ ghost _guard = true;
        // SLCO assignment | chan[3] := 255.
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 3;
        c.chan[3] = (255) & 0xff;
        //@ assert c.chan[_index_0] == _rhs_0;
        // SLCO assignment | partner[3] := 255.
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 3;
        c.partner[3] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_5();
        //@ ghost _rhs_2 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | record[3] != 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.record[3] != 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_ringback_1_s_0_n_0() {
        return c.record[3] != 255;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    pure int value_ringback_1_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.record[3] != 255);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_ringback_1_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | ringback -> calling | [record[3] != 255; partner[3] := record[3]].
    private boolean execute_transition_ringback_1() {
        // SLCO composite | [record[3] != 255; partner[3] := record[3]].
        // SLCO expression | record[3] != 255.
        //@ ghost _guard = c.record[3] != 255;
        if(!(t_ringback_1_s_0_n_0())) {
            //@ assert !(c.record[3] != 255);
            return false;
        }
        //@ assert c.record[3] != 255;
        // SLCO assignment | partner[3] := record[3].
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = c.record[3];
        //@ ghost _index_0 = 3;
        c.partner[3] = (c.record[3]) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | dev != 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_0_s_0_n_0() {
        return dev != 1;
    }

    // SLCO expression wrapper | chan[3] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[3] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_0_s_0_n_1() {
        return c.chan[3] == 255;
    }

    // SLCO expression wrapper | dev != 1 or chan[3] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev != 1 || c.chan[3] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_0_s_0_n_2() {
        return t_talert_0_s_0_n_0() || t_talert_0_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(dev != 1 || c.chan[3] == 255);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[3] = 255.
    private boolean execute_transition_talert_0() {
        // SLCO expression | dev != 1 or chan[3] = 255.
        //@ ghost _guard = dev != 1 || c.chan[3] == 255;
        if(!(t_talert_0_s_0_n_2())) {
            //@ assert !(dev != 1 || c.chan[3] == 255);
            return false;
        }
        //@ assert dev != 1 || c.chan[3] == 255;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[3]] % 20) = 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[3]], 20)) == 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_1_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[3]], 20)) == 3;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[3]], 20)) == 3);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[3]] % 20) = 3.
    private boolean execute_transition_talert_1() {
        // SLCO expression | ((chan[partner[3]]) % 20) = 3 -> (chan[partner[3]] % 20) = 3.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[3]], 20)) == 3;
        if(!(t_talert_1_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[3]], 20)) == 3);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[3]], 20)) == 3;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[3]] % 20) != 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[3]], 20)) != 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_talert_2_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[3]], 20)) != 3;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[3]], 20)) != 3);

    // Declare the support variables.
    yields boolean _guard;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[3]] % 20) != 3.
    private boolean execute_transition_talert_2() {
        // SLCO expression | ((chan[partner[3]]) % 20) != 3 -> (chan[partner[3]] % 20) != 3.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[3]], 20)) != 3;
        if(!(t_talert_2_s_0_n_0())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[3]], 20)) != 3);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[3]], 20)) != 3;

        return true;
    }

    // SLCO expression wrapper | (chan[partner[3]] % 20) = 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[3]], 20)) == 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_0_s_0_n_0() {
        return (Math.floorMod(c.chan[c.partner[3]], 20)) == 3;
    }

    // SLCO expression wrapper | (chan[partner[3]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[c.partner[3]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_0_s_0_n_1() {
        return (c.chan[c.partner[3]] / 20) == 0;
    }

    // SLCO expression wrapper | (chan[partner[3]] % 20) = 3 and (chan[partner[3]] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[3]], 20)) == 3 && (c.chan[c.partner[3]] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_0_s_0_n_2() {
        return t_tpickup_0_s_0_n_0() && t_tpickup_0_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    pure int value_tpickup_0_chan(int _i, int _index_1, int _rhs_1, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : ((_i == _index_1) ? _rhs_1 : v_old);
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((Math.floorMod(c.chan[c.partner[3]], 20)) == 3 && (c.chan[c.partner[3]] / 20) == 0);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_tpickup_0_chan(_i, _index_1, _rhs_1, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[3]] % 20) = 3 and (chan[partner[3]] / 20) = 0; dev := 0; chan[partner[3]] := (3 + 1 * 20); chan[3] := (partner[3] + 1 * 20)].
    private boolean execute_transition_tpickup_0() {
        // SLCO composite | [((chan[partner[3]]) % 20) = 3 and ((chan[partner[3]]) / 20) = 0; dev := 0; chan[partner[3]] := ((3) + (1) * 20); chan[3] := ((partner[3]) + (1) * 20)] -> [(chan[partner[3]] % 20) = 3 and (chan[partner[3]] / 20) = 0; dev := 0; chan[partner[3]] := (3 + 1 * 20); chan[3] := (partner[3] + 1 * 20)].
        // SLCO expression | (chan[partner[3]] % 20) = 3 and (chan[partner[3]] / 20) = 0.
        //@ ghost _guard = (Math.floorMod(c.chan[c.partner[3]], 20)) == 3 && (c.chan[c.partner[3]] / 20) == 0;
        if(!(t_tpickup_0_s_0_n_2())) {
            //@ assert !((Math.floorMod(c.chan[c.partner[3]], 20)) == 3 && (c.chan[c.partner[3]] / 20) == 0);
            return false;
        }
        //@ assert (Math.floorMod(c.chan[c.partner[3]], 20)) == 3 && (c.chan[c.partner[3]] / 20) == 0;
        // SLCO assignment | dev := 0.
        range_check_assumption_t_0_s_2();
        //@ ghost _rhs_0 = 0;
        dev = (0) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | chan[partner[3]] := (3 + 1 * 20).
        range_check_assumption_t_0_s_3();
        //@ ghost _rhs_1 = (3 + 1 * 20);
        //@ ghost _index_1 = c.partner[3];
        c.chan[c.partner[3]] = ((3 + 1 * 20)) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;
        // SLCO assignment | chan[3] := (partner[3] + 1 * 20).
        range_check_assumption_t_0_s_4();
        //@ ghost _rhs_2 = (c.partner[3] + 1 * 20);
        //@ ghost _index_2 = 3;
        c.chan[3] = ((c.partner[3] + 1 * 20)) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | chan[partner[3]] = 255.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[3]] == 255);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_1_s_0_n_0() {
        return c.chan[c.partner[3]] == 255;
    }

    // SLCO expression wrapper | (chan[partner[3]] % 20) != 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((Math.floorMod(c.chan[c.partner[3]], 20)) != 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_1_s_0_n_1() {
        return (Math.floorMod(c.chan[c.partner[3]], 20)) != 3;
    }

    // SLCO expression wrapper | chan[partner[3]] = 255 or (chan[partner[3]] % 20) != 3.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;
    context 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.chan[c.partner[3]] == 255 || (Math.floorMod(c.chan[c.partner[3]], 20)) != 3);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tpickup_1_s_0_n_2() {
        return t_tpickup_1_s_0_n_0() || t_tpickup_1_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_4() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;
    ensures 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
        //@ assume 0 <= c.partner[3] && c.partner[3] < 4;
    }

    /*@
    pure int value_tpickup_1_chan(int _i, int _index_2, int _rhs_2, int v_old) = (_i == _index_2) ? _rhs_2 : v_old;
    pure int value_tpickup_1_partner(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;
    requires 0 <= c.partner[3] && c.partner[3] < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old(c.chan[c.partner[3]] == 255 || (Math.floorMod(c.chan[c.partner[3]], 20)) != 3);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_2;
    yields int _index_2;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_tpickup_1_chan(_i, _index_2, _rhs_2, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_tpickup_1_partner(_i, _index_1, _rhs_1, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[3]] = 255 or (chan[partner[3]] % 20) != 3; dev := 1; partner[3] := 255; chan[3] := 255].
    private boolean execute_transition_tpickup_1() {
        // SLCO composite | [chan[partner[3]] = 255 or ((chan[partner[3]]) % 20) != 3; dev := 1; partner[3] := 255; chan[3] := 255] -> [chan[partner[3]] = 255 or (chan[partner[3]] % 20) != 3; dev := 1; partner[3] := 255; chan[3] := 255].
        // SLCO expression | chan[partner[3]] = 255 or (chan[partner[3]] % 20) != 3.
        //@ ghost _guard = c.chan[c.partner[3]] == 255 || (Math.floorMod(c.chan[c.partner[3]], 20)) != 3;
        if(!(t_tpickup_1_s_0_n_2())) {
            //@ assert !(c.chan[c.partner[3]] == 255 || (Math.floorMod(c.chan[c.partner[3]], 20)) != 3);
            return false;
        }
        //@ assert c.chan[c.partner[3]] == 255 || (Math.floorMod(c.chan[c.partner[3]], 20)) != 3;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;
        // SLCO assignment | partner[3] := 255.
        range_check_assumption_t_1_s_3();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 3;
        c.partner[3] = (255) & 0xff;
        //@ assert c.partner[_index_1] == _rhs_1;
        // SLCO assignment | chan[3] := 255.
        range_check_assumption_t_1_s_4();
        //@ ghost _rhs_2 = 255;
        //@ ghost _index_2 = 3;
        c.chan[3] = (255) & 0xff;
        //@ assert c.chan[_index_2] == _rhs_2;

        return true;
    }

    // SLCO expression wrapper | (chan[3] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[3] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_0_s_0_n_0() {
        return (c.chan[3] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_0_s_0_n_1() {
        return dev == 0;
    }

    // SLCO expression wrapper | (chan[3] / 20) = 1 and dev = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[3] / 20) == 1 && dev == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_0_s_0_n_2() {
        return t_tconnected_0_s_0_n_0() && t_tconnected_0_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_0() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[3] / 20) == 1 && dev == 0);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[3] / 20) = 1 and dev = 0; dev := 1].
    private boolean execute_transition_tconnected_0() {
        // SLCO composite | [((chan[3]) / 20) = 1 and dev = 0; dev := 1] -> [(chan[3] / 20) = 1 and dev = 0; dev := 1].
        // SLCO expression | (chan[3] / 20) = 1 and dev = 0.
        //@ ghost _guard = (c.chan[3] / 20) == 1 && dev == 0;
        if(!(t_tconnected_0_s_0_n_2())) {
            //@ assert !((c.chan[3] / 20) == 1 && dev == 0);
            return false;
        }
        //@ assert (c.chan[3] / 20) == 1 && dev == 0;
        // SLCO assignment | dev := 1.
        range_check_assumption_t_0_s_2();
        //@ ghost _rhs_0 = 1;
        dev = (1) & 0xff;
        //@ assert dev == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | (chan[3] / 20) = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[3] / 20) == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_1_s_0_n_0() {
        return (c.chan[3] / 20) == 1;
    }

    // SLCO expression wrapper | dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_1_s_0_n_1() {
        return dev == 1;
    }

    // SLCO expression wrapper | (chan[3] / 20) = 1 and dev = 1.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[3] / 20) == 1 && dev == 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_1_s_0_n_2() {
        return t_tconnected_1_s_0_n_0() && t_tconnected_1_s_0_n_1();
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1_s_2() {
        
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_1() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[3] / 20) == 1 && dev == 1);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures _guard ==> (dev == _rhs_0);
    ensures !_guard ==> (dev == \old(dev));
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[3] / 20) = 1 and dev = 1; dev := 0].
    private boolean execute_transition_tconnected_1() {
        // SLCO composite | [((chan[3]) / 20) = 1 and dev = 1; dev := 0] -> [(chan[3] / 20) = 1 and dev = 1; dev := 0].
        // SLCO expression | (chan[3] / 20) = 1 and dev = 1.
        //@ ghost _guard = (c.chan[3] / 20) == 1 && dev == 1;
        if(!(t_tconnected_1_s_0_n_2())) {
            //@ assert !((c.chan[3] / 20) == 1 && dev == 1);
            return false;
        }
        //@ assert (c.chan[3] / 20) == 1 && dev == 1;
        // SLCO assignment | dev := 0.
        range_check_assumption_t_1_s_2();
        //@ ghost _rhs_0 = 0;
        dev = (0) & 0xff;
        //@ assert dev == _rhs_0;

        return true;
    }

    // SLCO expression wrapper | (chan[3] / 20) = 0.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == ((c.chan[3] / 20) == 0);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean t_tconnected_2_s_0_n_0() {
        return (c.chan[3] / 20) == 0;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2_s_3() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    ensures 0 <= 3 && 3 < 4;

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private void range_check_assumption_t_2() {
        // Assume that all of the accessed indices are within range.
        //@ assume 0 <= 3 && 3 < 4;
    }

    /*@
    pure int value_tconnected_2_chan(int _i, int _index_1, int _rhs_1, int v_old) = (_i == _index_1) ? _rhs_1 : v_old;
    pure int value_tconnected_2_partner(int _i, int _index_0, int _rhs_0, int v_old) = (_i == _index_0) ? _rhs_0 : v_old;
    @*/
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    requires 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == \old((c.chan[3] / 20) == 0);

    // Declare the support variables.
    yields boolean _guard;
    yields int _rhs_1;
    yields int _index_1;
    yields int _rhs_0;
    yields int _index_0;

    // Ensure that the transition's return value is equivalent to the value of the guard.
    ensures \result == _guard;

    // Ensure that the appropriate values are changed, and if so, only when the guard holds true.
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == value_tconnected_2_chan(_i, _index_1, _rhs_1, \old(c.chan[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures _guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == value_tconnected_2_partner(_i, _index_0, _rhs_0, \old(c.partner[_i])));
    ensures !_guard ==> (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);
    @*/
    // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[3] / 20) = 0; partner[3] := 255; chan[3] := 255].
    private boolean execute_transition_tconnected_2() {
        // SLCO composite | [((chan[3]) / 20) = 0; partner[3] := 255; chan[3] := 255] -> [(chan[3] / 20) = 0; partner[3] := 255; chan[3] := 255].
        // SLCO expression | (chan[3] / 20) = 0.
        //@ ghost _guard = (c.chan[3] / 20) == 0;
        if(!(t_tconnected_2_s_0_n_0())) {
            //@ assert !((c.chan[3] / 20) == 0);
            return false;
        }
        //@ assert (c.chan[3] / 20) == 0;
        // SLCO assignment | partner[3] := 255.
        range_check_assumption_t_2_s_2();
        //@ ghost _rhs_0 = 255;
        //@ ghost _index_0 = 3;
        c.partner[3] = (255) & 0xff;
        //@ assert c.partner[_index_0] == _rhs_0;
        // SLCO assignment | chan[3] := 255.
        range_check_assumption_t_2_s_3();
        //@ ghost _rhs_1 = 255;
        //@ ghost _index_1 = 3;
        c.chan[3] = (255) & 0xff;
        //@ assert c.chan[_index_1] == _rhs_1;

        return true;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state idle.
    private void exec_idle() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | idle -> dialing | [chan[3] = 255; dev := 0; chan[3] := (3 + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | idle -> qi | [chan[3] != 255; partner[3] := (chan[3] % 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_idle_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state dialing.
    private void exec_dialing() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dialing -> idle | true | [true; dev := 1; chan[3] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | dialing -> calling | true | partner[3] := 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | dialing -> calling | true | partner[3] := 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_2()) {
            return;
        }
        // SLCO transition (p:0, id:3) | dialing -> calling | true | partner[3] := 2.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | dialing -> calling | true | partner[3] := 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | dialing -> calling | true | partner[3] := 4.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dialing_5()) {
            return;
        }
        // [SEQ.END]
    }

    // SLCO expression wrapper | partner[3] = 4.
    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);

    // Require and ensure that all of the accessed indices are within range.
    context 0 <= 3 && 3 < 4;

    // Ensure that the result of the function is equivalent to the target statement.
    ensures \result == (c.partner[3] == 4);

    // Ensure that all state machine variable values remain unchanged.
    ensures dev == \old(dev);
    ensures mbit == \old(mbit);

    // Ensure that all class variable values remain unchanged.
    ensures (\forall* int _i; 0 <= _i && _i < c.chan.length; c.chan[_i] == \old(c.chan[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.partner.length; c.partner[_i] == \old(c.partner[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.callforwardbusy.length; c.callforwardbusy[_i] == \old(c.callforwardbusy[_i]));
    ensures (\forall* int _i; 0 <= _i && _i < c.record.length; c.record[_i] == \old(c.record[_i]));
    @*/
    private boolean d_calling_0_n_0() {
        return c.partner[3] == 4;
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state calling.
    private void exec_calling() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | calling -> busy | partner[3] = 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_0()) {
            return;
        }
        // SLCO expression | partner[3] = 4.
        if(d_calling_0_n_0()) {
            // [SEQ.START]
            // SLCO transition (p:0, id:1) | calling -> unobtainable | partner[3] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_1()) {
                return;
            }
            // SLCO transition (p:0, id:2) | calling -> ringback | partner[3] = 4.
            //@ ghost range_check_assumption_t_2();
            if(execute_transition_calling_2()) {
                return;
            }
            // [SEQ.END]
        }
        // SLCO transition (p:0, id:3) | calling -> busy | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] = 255; record[partner[3]] := 3].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_3()) {
            return;
        }
        // SLCO transition (p:0, id:4) | calling -> calling | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] != 255 and callforwardbusy[partner[3]] != 255; record[partner[3]] := 3; partner[3] := callforwardbusy[partner[3]]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_4()) {
            return;
        }
        // SLCO transition (p:0, id:5) | calling -> oalert | [partner[3] != 3 and partner[3] != 4 and chan[partner[3]] = 255; record[partner[3]] := 3; chan[partner[3]] := (3 + 0 * 20); chan[3] := (partner[3] + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_calling_5()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state busy.
    private void exec_busy() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | busy -> idle | true | [true; chan[3] := 255; partner[3] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_busy_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state qi.
    private void exec_qi() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | qi -> talert | (chan[partner[3]] % 20) = 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | qi -> idle | [(chan[partner[3]] % 20) != 3; partner[3] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_qi_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state talert.
    private void exec_talert() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | talert -> errorstate | dev != 1 or chan[3] = 255.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_0()) {
            return;
        }
        // [DET.START]
        // SLCO transition (p:0, id:1) | talert -> tpickup | (chan[partner[3]] % 20) = 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | talert -> idle | (chan[partner[3]] % 20) != 3.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_talert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state unobtainable.
    private void exec_unobtainable() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | unobtainable -> idle | true | [true; chan[3] := 255; partner[3] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_unobtainable_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state oalert.
    private void exec_oalert() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | oalert -> errorstate | (chan[3] % 20) != partner[3].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | oalert -> oconnected | (chan[3] % 20) = partner[3] and (chan[3] / 20) = 1.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | oalert -> dveoringout | (chan[3] % 20) = partner[3] and (chan[3] / 20) = 0.
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oalert_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state errorstate.
    private void exec_errorstate() {
        // There are no transitions starting in state errorstate.
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state oconnected.
    private void exec_oconnected() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | oconnected -> idle | true | [true; dev := 1; chan[3] := 255; chan[partner[3]] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_oconnected_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state dveoringout.
    private void exec_dveoringout() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | dveoringout -> idle | true | [true; dev := 1; chan[3] := 255; partner[3] := ((partner[3] % 20) + 0 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_dveoringout_0()) {
            return;
        }
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state tpickup.
    private void exec_tpickup() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tpickup -> tconnected | [(chan[partner[3]] % 20) = 3 and (chan[partner[3]] / 20) = 0; dev := 0; chan[partner[3]] := (3 + 1 * 20); chan[3] := (partner[3] + 1 * 20)].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tpickup -> idle | [chan[partner[3]] = 255 or (chan[partner[3]] % 20) != 3; dev := 1; partner[3] := 255; chan[3] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tpickup_1()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state tconnected.
    private void exec_tconnected() {
        // [SEQ.START]
        // [DET.START]
        // SLCO transition (p:0, id:0) | tconnected -> tconnected | [(chan[3] / 20) = 1 and dev = 0; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | tconnected -> tconnected | [(chan[3] / 20) = 1 and dev = 1; dev := 0].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_1()) {
            return;
        }
        // SLCO transition (p:0, id:2) | tconnected -> idle | [(chan[3] / 20) = 0; partner[3] := 255; chan[3] := 255].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_tconnected_2()) {
            return;
        }
        // [DET.END]
        // [SEQ.END]
    }

    /*@
    // Require and ensure full access to the target class.
    context Perm(c, 1);

    // Require and ensure the permission of writing to all state machine variables.
    context Perm(dev, 1);
    context Perm(mbit, 1);

    // Require and ensure that the state machine has full access to the array variables within the target class.
    context Perm(c.chan, 1);
    context Perm(c.partner, 1);
    context Perm(c.callforwardbusy, 1);
    context Perm(c.record, 1);

    // Require and ensure that the class variable arrays are not null and of the appropriate size.
    context c.chan != null && c.chan.length == 4;
    context c.partner != null && c.partner.length == 4;
    context c.callforwardbusy != null && c.callforwardbusy.length == 4;
    context c.record != null && c.record.length == 4;

    // Require and ensure the permission of writing to all class variables.
    context Perm(c.chan[*], 1);
    context Perm(c.partner[*], 1);
    context Perm(c.callforwardbusy[*], 1);
    context Perm(c.record[*], 1);
    @*/
    // Attempt to fire a transition starting in state ringback.
    private void exec_ringback() {
        // [SEQ.START]
        // SLCO transition (p:0, id:0) | ringback -> idle | true | [true; chan[3] := 255; partner[3] := 255; dev := 1].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_0()) {
            return;
        }
        // SLCO transition (p:0, id:1) | ringback -> calling | [record[3] != 255; partner[3] := record[3]].
        //@ ghost range_check_assumption_t_2();
        if(execute_transition_ringback_1()) {
            return;
        }
        // [SEQ.END]
    }
}

// <<< STATE_MACHINE.END (User_3)

// << CLASS.END (GlobalClass)

// < MODEL.END (Telephony)