model bakery.3 {
classes
	GlobalClass {
		variables
			Integer[3] choosing
			Integer[3] number
		state machines
			P_0 {
				variables
					Integer j
					Integer max
				initial NCS
				states  choose for_loop wait CS
				transitions
					from NCS to choose {
						[choosing[0] := 1;j := 0;max := 0]
					}
	
					from choose to choose {
						[j<3 and number[j]>max; max := number[j];j := j +1]
					}
	
					from choose to choose {
						[j<3 and number[j]<=max; j := j+1]
					}
	
					from choose to for_loop {
						[j = 3 and max < 4; number[0] := max + 1;j := 0;choosing[0] := 0]
					}
	
					from for_loop to wait {
						[j<3 and choosing[j]=0]
					}
	
					from wait to for_loop {
						[number[j] = 0 or (number[j] > number[0]) or
			(number[j] = number[0] and 0 <= j); j := j+1]
					}
	
					from for_loop to CS {
						[j=3]
					}
	
					from CS to NCS {
						[number[0] := 0]
					}
	
				}
	
			P_1 {
				variables
					Integer j
					Integer max
				initial NCS
				states  choose for_loop wait CS
				transitions
					from NCS to choose {
						[choosing[1] := 1;j := 0;max := 0]
					}
	
					from choose to choose {
						[j<3 and number[j]>max; max := number[j];j := j +1]
					}
	
					from choose to choose {
						[j<3 and number[j]<=max; j := j+1]
					}
	
					from choose to for_loop {
						[j = 3 and max < 4; number[1] := max + 1;j := 0;choosing[1] := 0]
					}
	
					from for_loop to wait {
						[j<3 and choosing[j]=0]
					}
	
					from wait to for_loop {
						[number[j] = 0 or (number[j] > number[1]) or
			(number[j] = number[1] and 1 <= j); j := j+1]
					}
	
					from for_loop to CS {
						[j=3]
					}
	
					from CS to NCS {
						[number[1] := 0]
					}
	
				}
	
			P_2 {
				variables
					Integer j
					Integer max
				initial NCS
				states  choose for_loop wait CS
				transitions
					from NCS to choose {
						[choosing[2] := 1;j := 0;max := 0]
					}
	
					from choose to choose {
						[j<3 and number[j]>max; max := number[j];j := j +1]
					}
	
					from choose to choose {
						[j<3 and number[j]<=max; j := j+1]
					}
	
					from choose to for_loop {
						[j = 3 and max < 4; number[2] := max + 1;j := 0;choosing[2] := 0]
					}
	
					from for_loop to wait {
						[j<3 and choosing[j]=0]
					}
	
					from wait to for_loop {
						[number[j] = 0 or (number[j] > number[2]) or
			(number[j] = number[2] and 2 <= j); j := j+1]
					}
	
					from for_loop to CS {
						[j=3]
					}
	
					from CS to NCS {
						[number[2] := 0]
					}
	
				}
	
	}

objects
	globalObject : GlobalClass
}
