model elevator_planning.1 {
classes
	GlobalClass {
		variables
			Integer[5] person := [0,1,2,3,4]
			Integer[5] conflictA := [1,0,0,1,1]
			Integer[5] conflictB := [0,1,1]
			Integer[5] not_alone := [1,1,0,0,0]
			Integer at := 0
			Integer inA := 0
			Integer inB := 0
			Integer in := 0
			Integer alone := 0
			Integer i := 0
		state machines
			Elevator {
				variables
					
				initial q
				states  done
				transitions
					from q to done {
						[person[0]=0  and person[1]=0  and person[2]=0  and person[3]=0  and person[4]=0]
					}
	
					from q to q {
						[person[0] = at and in <3 and 
		(conflictA[0]=0 or inB=0) and 
		(conflictB[0]=0 or inA=0) and 
		(not_alone[0]=0 or in>0); person[0] := 255;in := in+1;inA := inA + conflictA[0];inB := inB + conflictB[0];alone := alone + not_alone[0]]
					}
	
					from q to q {
						[person[1] = at and in <3 and 
		(conflictA[1]=0 or inB=0) and 
		(conflictB[1]=0 or inA=0) and 
		(not_alone[1]=0 or in>0); person[1] := 255;in := in+1;inA := inA + conflictA[1];inB := inB + conflictB[1];alone := alone + not_alone[1]]
					}
	
					from q to q {
						[person[2] = at and in <3 and 
		(conflictA[2]=0 or inB=0) and 
		(conflictB[2]=0 or inA=0) and 
		(not_alone[2]=0 or in>0); person[2] := 255;in := in+1;inA := inA + conflictA[2];inB := inB + conflictB[2];alone := alone + not_alone[2]]
					}
	
					from q to q {
						[person[3] = at and in <3 and 
		(conflictA[3]=0 or inB=0) and 
		(conflictB[3]=0 or inA=0) and 
		(not_alone[3]=0 or in>0); person[3] := 255;in := in+1;inA := inA + conflictA[3];inB := inB + conflictB[3];alone := alone + not_alone[3]]
					}
	
					from q to q {
						[person[4] = at and in <3 and 
		(conflictA[4]=0 or inB=0) and 
		(conflictB[4]=0 or inA=0) and 
		(not_alone[4]=0 or in>0); person[4] := 255;in := in+1;inA := inA + conflictA[4];inB := inB + conflictB[4];alone := alone + not_alone[4]]
					}
	
					from q to q {
						[person[0] = 255 and 
		(in>2 or (alone - not_alone[0]=0)); person[0] := at;in := in-1;inA := inA - conflictA[0];inB := inB - conflictB[0];alone := alone - not_alone[0]]
					}
	
					from q to q {
						[person[1] = 255 and 
		(in>2 or (alone - not_alone[1]=0)); person[1] := at;in := in-1;inA := inA - conflictA[1];inB := inB - conflictB[1];alone := alone - not_alone[1]]
					}
	
					from q to q {
						[person[2] = 255 and 
		(in>2 or (alone - not_alone[2]=0)); person[2] := at;in := in-1;inA := inA - conflictA[2];inB := inB - conflictB[2];alone := alone - not_alone[2]]
					}
	
					from q to q {
						[person[3] = 255 and 
		(in>2 or (alone - not_alone[3]=0)); person[3] := at;in := in-1;inA := inA - conflictA[3];inB := inB - conflictB[3];alone := alone - not_alone[3]]
					}
	
					from q to q {
						[person[4] = 255 and 
		(in>2 or (alone - not_alone[4]=0)); person[4] := at;in := in-1;inA := inA - conflictA[4];inB := inB - conflictB[4];alone := alone - not_alone[4]]
					}
	
					from q to q {
						[at := 0]
					}
	
					from q to q {
						[at := 1]
					}
	
					from q to q {
						[at := 2]
					}
	
					from q to q {
						[at := 3]
					}
	
					from q to q {
						[at := 4]
					}
	
				}
	
	}

objects
	globalObject : GlobalClass
}
