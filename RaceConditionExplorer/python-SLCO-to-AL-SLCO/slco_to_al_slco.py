# Race Condition Explorer tool, v0.1, 2017
#
# Update History:
#

# Start of program

import argparse
import logging
import logging.config
import sys
from os.path import dirname, join
from textx.metamodel import metamodel_from_file
from textx.model import children_of_type

from help_on_error_argument_parser import HelpOnErrorArgumentParser
from suggestions import *

this_folder = dirname(__file__)
slco_mm = metamodel_from_file(join(this_folder,'slco2.tx'))



# def un_composite_statement_list(statement_list):
# 	statements = []
# 	for statement in statement_list:
# 		if statement.__class__.__name__ != "Composite":
# 			statements.append(statement)
# 			continue
# 		# statement is a Composite statement
# 		if statement.guard:
# 			statement.append(statement.guard)
# 		statements.extend(statement.assignments)
# 	return statements
	

def translate(model, suggestions):
	print(model.name)
	
	# Currently only 1 class is supported
	global_class = model.classes[0]
	print("class name: "+global_class.name)
	#print([(x.type.base, x.type.size, x.name, x.defvalue, x.defvalues) for x in globalClass.variables])
	global_vars = [x.name for x in global_class.variables]
	
	transitions = children_of_type("Transition", global_class)
	for t in transitions:
		#print((t.priority, t.source, t.target, t.statements))
		# process suggestions
		ad = suggestions.get(t._tx_position, None)
		if ad: # atomicity violations, apply advice
			composites = children_of_type("Composite", t)
			# We assume that a transition only contains one statement.
			# Hence, we can simply assign the new statements
			if composites:
				composite = composites[0]
				print(composite)
				print(composite.assignments)
				new_statements = ad.apply(composite)
				print (new_statements)
	
	# We do not support actions
	#model.actions
	# We do not support multiple objects
	#model.objects
	# We do not support channels
	#model.channels
	#globalClass.ports
	return ""

def main():
	# setup logging
	file_handler    = logging.FileHandler(filename='rc_explorer.log', mode='w')
	console_handler = logging.StreamHandler(stream=sys.stdout)
	file_handler.setLevel(logging.INFO)
	console_handler.setLevel(logging.DEBUG)
	logging.basicConfig(format='%(asctime)s - %(levelname)s: %(message)s',
						datefmt='%Y-%m-%d %H:%M:%S',
						level=logging.DEBUG,
						handlers=[file_handler, console_handler])
	
	# parse arguments
	parser = HelpOnErrorArgumentParser(
		description='Core-SLCO to Atomicity-Level-SLCO transformation',
		formatter_class=argparse.ArgumentDefaultsHelpFormatter
	)
	parser.add_argument("INPUT_MODEL", type=str, help="SLCO input model")
	parser.add_argument("INPUT_SUGGESTIONS", type=str, help="Suggestions file generated by mCRL2 analysis")
	parser.add_argument("-o", "--out", type=str, default="INPUT_MODEL", help="Output slco model")
	parser.add_argument("-q", "--quiet", action='store_true', help="Quiet mode, print no messages to screen")
	parser.add_argument("-m", "--mute", action='store_true', help="Mute mode, no messages are printed or logged")
	
	args = vars(parser.parse_args())
	# set options
	if args['quiet']:
		console_handler.setLevel(logging.CRITICAL + 1)

	if args['mute']:
		console_handler.setLevel(logging.CRITICAL + 1)
		file_handler.setLevel(logging.CRITICAL + 1)
	
	slco_path = args['INPUT_MODEL']
	sugg_path = args['INPUT_SUGGESTIONS']
	
	out_path = args['out']
	if out_path == 'INPUT_MODEL':
		out_path = slco_path[:-5] + '_AL.slco'
	elif not out_path.endswith('.slco'):
		out_path = out_path + '.slco'
	
	logging.info('Starting SLCO Atomicity-free code generator')
	logging.info('Input model       : %s', slco_path)
	logging.info('Input suggestions : %s', sugg_path)
	logging.info('Output File       : %s', out_path)

	# read models
	model = slco_mm.model_from_file(slco_path)
	suggestions = parse_suggestions(sugg_path)
	# translate
	out_model = translate(model, suggestions)

	outFile = open(out_path, 'w')
	outFile.write(out_model)
	outFile.close()
	
	logging.info('Finished, output written to %s', out_path)
	logging.shutdown()


if __name__ == '__main__':
	main()
