# Race Condition Explorer tool, v0.1, 2017
#
# Update History:
#

# Start of program

import argparse
import logging
import logging.config
import re
import sys
from os.path import dirname, join
from textx.metamodel import metamodel_from_file

from help_on_error_argument_parser import HelpOnErrorArgumentParser

this_folder = dirname(__file__)
slco_mm = metamodel_from_file(join(this_folder,'slco2.tx'))

class AccessPattern:
	r = set()
	w = set()

	def __init__(self, r, w):
		self.r = r
		self.w = w

class AD():
	atomics = set()
	shuffles = set()

	def __init__(self, atomics, shuffles):
		self.atomics = atomics
		self.shuffles = shuffles


def get_and_remove_up_to_first(string, sub, skip):
	idx = string.find(sub)
	ret1 = string[:idx]
	ret2 = string[idx + skip:]
	return ret1, ret2


def parse_A(text):
	text = text[3:]
	splt = text.split('], [')
	rtxt = splt[0][1:]
	wtxt = splt[1][:-1]
	return AccessPattern(set(rtxt.split(', ')), set(wtxt.split(', ')))


def parse_AD(text):
	text = text[4:-1]
	print(text)
	# TODO, what are the two elements of AD?
	alist = []
	#while text.startswith("A'("):
	#	a, text = get_and_remove_up_to_first(text, ')', 3)
	#	alist.append(parse_A(a))

	return AD([], [])


def parse_SH():
	return ""


def parse_suggestions(sugg_path):
	file = open(sugg_path, 'r')
	lines = file.readlines()
	file.close()

	atomics = []
	shuffles = []
	for line in lines:
		start = line.find(",") + 2
		end = line.rfind("'") - 1
		line = line[start:end]
		sm, line = get_and_remove_up_to_first(line, ',', 2)
		statement, line = get_and_remove_up_to_first(line, ',', 2)

		if line.startswith('AD'):
			atomics.append(parse_AD(line))
		elif line.startswith('SH'):
			shuffles.append(parse_SH(line))
	print(atomics)
	print(shuffles)
	return atomics, shuffles

def translate(model, suggestions):

	return ""

def main():
	# setup logging
	file_handler    = logging.FileHandler(filename='rc_explorer.log', mode='w')
	console_handler = logging.StreamHandler(stream=sys.stdout)
	file_handler.setLevel(logging.INFO)
	console_handler.setLevel(logging.DEBUG)
	logging.basicConfig(format='%(asctime)s - %(levelname)s: %(message)s',
						datefmt='%Y-%m-%d %H:%M:%S',
						level=logging.DEBUG,
						handlers=[file_handler, console_handler])
	
	# parse arguments
	parser = HelpOnErrorArgumentParser(
		description='Core-SLCO to Atomicity-Level-SLCO transformation',
		formatter_class=argparse.ArgumentDefaultsHelpFormatter
	)
	parser.add_argument("INPUT_MODEL", type=str, help="SLCO input model")
	parser.add_argument("INPUT_SUGGESTIONS", type=str, help="Suggestions file generated by mCRL2 analysis")
	parser.add_argument("-o", "--out", type=str, default="INPUT_MODEL", help="Output slco model")
	parser.add_argument("-q", "--quiet", action='store_true', help="Quiet mode, print no messages to screen")
	parser.add_argument("-m", "--mute", action='store_true', help="Mute mode, no messages are printed or logged")
	
	args = vars(parser.parse_args())

	# set options
	if args['quiet']:
		console_handler.setLevel(logging.CRITICAL + 1)

	if args['mute']:
		console_handler.setLevel(logging.CRITICAL + 1)
		file_handler.setLevel(logging.CRITICAL + 1)
	
	slco_path = args['INPUT_MODEL']
	sugg_path = args['INPUT_SUGGESTIONS']
	
	out_path = args['out']
	if out_path == 'INPUT_MODEL':
		out_path = slco_path[:-5] + '_AL.slco'
	elif not out_path.endswith('.slco'):
		out_path = out_path + '.slco'
	
	logging.info('Starting SLCO Atomicity-free code generator')
	logging.info('Input model       : %s', slco_path)
	logging.info('Input suggestions : %s', sugg_path)
	logging.info('Output File       : %s', out_path)

	# read models
	model = slco_mm.model_from_file(slco_path)
	suggestions = parse_suggestions(sugg_path)
	# translate
	out_model = translate(model, suggestions)

	outFile = open(out_path, 'w')
	outFile.write(out_model)
	outFile.close()
	
	logging.info('Finished, output written to %s', out_path + '_[quick/minimal].rc')
	logging.shutdown()


if __name__ == '__main__':
	main()
